// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]

type Op_StderrWrite = roc_std::RocStr;
type Op_StdoutWrite = roc_std::RocStr;
type TODO_roc_function_69 = roc_std::RocStr;
type TODO_roc_function_70 = roc_std::RocStr;

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Expr {
    Concat = 0,
    String = 1,
}

impl core::fmt::Debug for discriminant_Expr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Concat => f.write_str("discriminant_Expr::Concat"),
            Self::String => f.write_str("discriminant_Expr::String"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(transparent)]
pub struct Expr {
    pointer: *mut union_Expr,
}


#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
union union_Expr {
    Concat: core::mem::ManuallyDrop<Expr_Concat>,
    String: core::mem::ManuallyDrop<Expr_String>,
    _sizer: [u8; 8],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(transparent)]
struct Expr_String {
    pub f0: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[repr(C)]
struct Expr_Concat {
    pub f0: Expr,
    pub f1: Expr,
}

impl Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    #[inline(always)]
    fn storage(&self) -> Option<&core::cell::Cell<roc_std::Storage>> {
        let mask = match std::mem::size_of::<usize>() {
            4 => 0b11,
            8 => 0b111,
            _ => unreachable!(),
        };

        // NOTE: pointer provenance is probably lost here
        let unmasked_address = (self.pointer as usize) & !mask;
        let untagged = unmasked_address as *const core::cell::Cell<roc_std::Storage>;

        if untagged.is_null() {
            None
        } else {
            unsafe {
                Some(&*untagged.sub(1))
            }
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Expr {
        // The discriminant is stored in the unused bytes at the end of the recursive pointer
        unsafe { core::mem::transmute::<u8, discriminant_Expr>((self.pointer as u8) & 0b11) }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn tag_discriminant(pointer: *mut union_Expr, discriminant: discriminant_Expr) -> *mut union_Expr {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        let untagged = (pointer as usize) & (!0b11 as usize);
        let tagged = untagged | (discriminant as usize);

        tagged as *mut union_Expr
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Internal helper
    fn union_pointer(&self) -> *mut union_Expr {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        ((self.pointer as usize) & (!0b11 as usize)) as *mut union_Expr
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Concat`, with the appropriate payload
    pub fn Concat(arg0: Expr, arg1: Expr) -> Self {
            let size = core::mem::size_of::<union_Expr>();
            let align = core::mem::align_of::<union_Expr>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Expr>();

                *ptr = union_Expr {
                    Concat: core::mem::ManuallyDrop::new(Expr_Concat {
                    f0: arg0,
                    f1: arg1,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, discriminant_Expr::Concat),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `Concat` and convert it to `Concat`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Concat`.
            pub unsafe fn into_Concat(mut self) -> (Expr, Expr) {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::Concat);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Expr;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Concat,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `Concat` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Concat`.
            pub unsafe fn as_Concat(&self) -> (&Expr, &Expr) {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::Concat);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Expr;

            unsafe { &(*ptr).Concat }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `String`, with the appropriate payload
    pub fn String(arg0: roc_std::RocStr) -> Self {
            let size = core::mem::size_of::<union_Expr>();
            let align = core::mem::align_of::<union_Expr>() as u32;

            unsafe {
                let ptr = roc_std::roc_alloc_refcounted::<union_Expr>();

                *ptr = union_Expr {
                    String: core::mem::ManuallyDrop::new(Expr_String {
                    f0: arg0,
                })
                };

                Self {
                    pointer: Self::tag_discriminant(ptr, discriminant_Expr::String),
                }
            }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `String` and convert it to `String`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `String`.
            pub unsafe fn into_String(mut self) -> roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::String);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Expr;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).String,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "wasm32",
        target_arch = "x86"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `String` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `String`.
            pub unsafe fn as_String(&self) -> &roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::String);
        let payload = {
            let ptr = (self.pointer as usize & !0b11) as *mut union_Expr;

            unsafe { &(*ptr).String }
        };

        
        &payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Expr {
        // The discriminant is stored in the unused bytes at the end of the recursive pointer
        unsafe { core::mem::transmute::<u8, discriminant_Expr>((self.pointer as u8) & 0b111) }
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn tag_discriminant(pointer: *mut union_Expr, discriminant: discriminant_Expr) -> *mut union_Expr {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        let untagged = (pointer as usize) & (!0b111 as usize);
        let tagged = untagged | (discriminant as usize);

        tagged as *mut union_Expr
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn union_pointer(&self) -> *mut union_Expr {
        // The discriminant is stored in the unused bytes at the end of the union pointer
        ((self.pointer as usize) & (!0b111 as usize)) as *mut union_Expr
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `Concat` and convert it to `Concat`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Concat`.
            pub unsafe fn into_Concat(mut self) -> (Expr, Expr) {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::Concat);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Expr;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).Concat,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        (
            payload.f0, 
            payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `Concat` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `Concat`.
            pub unsafe fn as_Concat(&self) -> (&Expr, &Expr) {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::Concat);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Expr;

            unsafe { &(*ptr).Concat }
        };

        (
            &payload.f0, 
            &payload.f1
        )
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `String` and convert it to `String`'s payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `String`.
            pub unsafe fn into_String(mut self) -> roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::String);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Expr;
            let mut uninitialized = core::mem::MaybeUninit::uninit();
            let swapped = unsafe {
                core::mem::replace(
                    &mut (*ptr).String,
                    core::mem::ManuallyDrop::new(uninitialized.assume_init()),
                )
            };

            core::mem::forget(self);

            core::mem::ManuallyDrop::into_inner(swapped)
        };

        
        payload.f0
    }

    #[cfg(any(
        target_arch = "aarch64",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume this `Expr` has a `.discriminant()` of `String` and return its payload.
            /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
            /// Panics in debug builds if the `.discriminant()` doesn't return `String`.
            pub unsafe fn as_String(&self) -> &roc_std::RocStr {
                debug_assert_eq!(self.discriminant(), discriminant_Expr::String);
        let payload = {
            let ptr = (self.pointer as usize & !0b111) as *mut union_Expr;

            unsafe { &(*ptr).String }
        };

        
        &payload.f0
    }
}

impl Drop for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // We only need to do any work if there's actually a heap-allocated payload.
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();

            // Decrement the refcount
            let needs_dealloc = !new_storage.is_readonly() && new_storage.decrease();

            if needs_dealloc {
                // Drop the payload first.
                            match self.discriminant() {
                discriminant_Expr::Concat => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).Concat) },
                discriminant_Expr::String => unsafe { core::mem::ManuallyDrop::drop(&mut (&mut *self.union_pointer()).String) },
            }


                // Dealloc the pointer
                let alignment = core::mem::align_of::<Self>().max(core::mem::align_of::<roc_std::Storage>());

                unsafe { crate::roc_dealloc(storage.as_ptr().cast(), alignment as u32); }
            } else {
                // Write the storage back.
                storage.set(new_storage);
            }
        }
    }
}

impl Eq for Expr {}

impl PartialEq for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
            if self.discriminant() != other.discriminant() {
                return false;
            }

            unsafe {
            match self.discriminant() {
                discriminant_Expr::Concat => (&*self.union_pointer()).Concat == (&*other.union_pointer()).Concat,
                discriminant_Expr::String => (&*self.union_pointer()).String == (&*other.union_pointer()).String,
            }
        }
    }
}

impl PartialOrd for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Expr::Concat => (&*self.union_pointer()).Concat.partial_cmp(&(&*other.union_pointer()).Concat),
                discriminant_Expr::String => (&*self.union_pointer()).String.partial_cmp(&(&*other.union_pointer()).String),
            }
        }
    }
}

impl Ord for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            match self.discriminant().cmp(&other.discriminant()) {
                core::cmp::Ordering::Equal => {}
                not_eq => return not_eq,
            }

            unsafe {
            match self.discriminant() {
                discriminant_Expr::Concat => (&*self.union_pointer()).Concat.cmp(&(&*other.union_pointer()).Concat),
                discriminant_Expr::String => (&*self.union_pointer()).String.cmp(&(&*other.union_pointer()).String),
            }
        }
    }
}

impl Clone for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        if let Some(storage) = self.storage() {
            let mut new_storage = storage.get();
            if !new_storage.is_readonly() {
                new_storage.increment_reference_count();
                storage.set(new_storage);
            }
        }

        Self {
            pointer: self.pointer
        }
    }
}

impl core::hash::Hash for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {        match self.discriminant() {
            discriminant_Expr::Concat => unsafe {
                    discriminant_Expr::Concat.hash(state);
                    (&*self.union_pointer()).Concat.hash(state);
                },
            discriminant_Expr::String => unsafe {
                    discriminant_Expr::String.hash(state);
                    (&*self.union_pointer()).String.hash(state);
                },
        }
    }
}

impl core::fmt::Debug for Expr {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Expr::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Expr::Concat => f.debug_tuple("Concat")
        .field(&(&*(&*self.union_pointer()).Concat).f0)
.field(&(&*(&*self.union_pointer()).Concat).f1)
        .finish(),
                discriminant_Expr::String => f.debug_tuple("String")
        .field(&(&*(&*self.union_pointer()).String).f0)
        .finish(),
            }
        }
    }
}
