procedure Bool.1 ():
    let Bool.55 : Int1 = false;
    ret Bool.55;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    dec #Attr.3;
    dec #Attr.2;
    ret Bool.23;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.46 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.46;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.66 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.66;

procedure Bool.2 ():
    let Bool.54 : Int1 = true;
    ret Bool.54;

procedure Bool.3 (#Attr.2, #Attr.3):
    let Bool.37 : Int1 = lowlevel And #Attr.2 #Attr.3;
    ret Bool.37;

procedure Bool.4 (#Attr.2, #Attr.3):
    let Bool.57 : Int1 = lowlevel Or #Attr.2 #Attr.3;
    ret Bool.57;

procedure Decode.24 (Decode.101):
    ret Decode.101;

procedure Decode.25 (Decode.102, Decode.121, Decode.104):
    let Decode.134 : {List U8, [C {}, C Str]} = CallByName Json.448 Decode.102 Decode.104;
    ret Decode.134;

procedure Decode.26 (Decode.105, Decode.106):
    let Decode.133 : {} = CallByName Json.55;
    let Decode.132 : {List U8, [C {}, C Str]} = CallByName Decode.25 Decode.105 Decode.133 Decode.106;
    ret Decode.132;

procedure Decode.27 (Decode.107, Decode.108):
    let Decode.122 : {List U8, [C {}, C Str]} = CallByName Decode.26 Decode.107 Decode.108;
    let Decode.110 : List U8 = StructAtIndex 0 Decode.122;
    inc Decode.110;
    let Decode.109 : [C {}, C Str] = StructAtIndex 1 Decode.122;
    inc Decode.109;
    dec Decode.122;
    let Decode.125 : Int1 = CallByName List.1 Decode.110;
    if Decode.125 then
        dec Decode.110;
        let Decode.129 : U8 = 1i64;
        let Decode.130 : U8 = GetTagId Decode.109;
        let Decode.131 : Int1 = lowlevel Eq Decode.129 Decode.130;
        if Decode.131 then
            let Decode.111 : Str = UnionAtIndex (Id 1) (Index 0) Decode.109;
            inc Decode.111;
            dec Decode.109;
            let Decode.126 : [C [C List U8, C ], C Str] = TagId(1) Decode.111;
            ret Decode.126;
        else
            dec Decode.109;
            let Decode.128 : [C List U8, C ] = TagId(1) ;
            let Decode.127 : [C [C List U8, C ], C Str] = TagId(0) Decode.128;
            ret Decode.127;
    else
        dec Decode.109;
        let Decode.124 : [C List U8, C ] = TagId(0) Decode.110;
        let Decode.123 : [C [C List U8, C ], C Str] = TagId(0) Decode.124;
        ret Decode.123;

procedure Json.2 ():
    let Json.901 : {} = Struct {};
    ret Json.901;

procedure Json.448 (Json.449, Json.904):
    inc Json.449;
    let Json.1041 : {List U8, List U8} = CallByName Json.56 Json.449;
    let Json.452 : List U8 = StructAtIndex 0 Json.1041;
    inc Json.452;
    let Json.451 : List U8 = StructAtIndex 1 Json.1041;
    inc Json.451;
    dec Json.1041;
    let Json.1037 : Int1 = CallByName List.1 Json.451;
    if Json.1037 then
        dec Json.452;
        dec Json.451;
        let Json.1040 : {} = Struct {};
        let Json.1039 : [C {}, C Str] = TagId(0) Json.1040;
        let Json.1038 : {List U8, [C {}, C Str]} = Struct {Json.449, Json.1039};
        ret Json.1038;
    else
        let Json.1036 : List U8 = Array [];
        let Json.916 : {List U8, List U8} = Struct {Json.451, Json.1036};
        let Json.915 : {List U8, List U8} = CallByName Json.65 Json.916;
        let Json.456 : List U8 = StructAtIndex 1 Json.915;
        inc Json.456;
        dec Json.915;
        let Json.914 : List U8 = CallByName List.38 Json.456;
        let Json.913 : List U8 = CallByName List.32 Json.914;
        let Json.457 : [C {U64, U8}, C Str] = CallByName Str.9 Json.913;
        let Json.910 : U8 = 1i64;
        let Json.911 : U8 = GetTagId Json.457;
        let Json.912 : Int1 = lowlevel Eq Json.910 Json.911;
        if Json.912 then
            dec Json.449;
            let Json.458 : Str = UnionAtIndex (Id 1) (Index 0) Json.457;
            inc Json.458;
            dec Json.457;
            let Json.906 : [C {}, C Str] = TagId(1) Json.458;
            let Json.905 : {List U8, [C {}, C Str]} = Struct {Json.452, Json.906};
            ret Json.905;
        else
            dec Json.457;
            dec Json.452;
            let Json.909 : {} = Struct {};
            let Json.908 : [C {}, C Str] = TagId(0) Json.909;
            let Json.907 : {List U8, [C {}, C Str]} = Struct {Json.449, Json.908};
            ret Json.907;

procedure Json.55 ():
    let Json.903 : {} = Struct {};
    let Json.902 : {} = CallByName Decode.24 Json.903;
    ret Json.902;

procedure Json.56 (Json.462):
    let Json.1053 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(4) ;
    let Json.1054 : {} = Struct {};
    let Json.1042 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = CallByName List.26 Json.462 Json.1053 Json.1054;
    let Json.1050 : U8 = 2i64;
    let Json.1051 : U8 = GetTagId Json.1042;
    let Json.1052 : Int1 = lowlevel Eq Json.1050 Json.1051;
    if Json.1052 then
        let Json.464 : U64 = UnionAtIndex (Id 2) (Index 0) Json.1042;
        inc Json.462;
        let Json.1044 : List U8 = CallByName List.29 Json.462 Json.464;
        let Json.1047 : U64 = 0i64;
        let Json.1046 : {U64, U64} = Struct {Json.464, Json.1047};
        let Json.1045 : List U8 = CallByName List.49 Json.462 Json.1046;
        let Json.1043 : {List U8, List U8} = Struct {Json.1044, Json.1045};
        ret Json.1043;
    else
        let Json.1049 : List U8 = Array [];
        let Json.1048 : {List U8, List U8} = Struct {Json.462, Json.1049};
        ret Json.1048;

procedure Json.57 (Json.465, Json.466):
    let Json.1055 : {[C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], U8} = Struct {Json.465, Json.466};
    joinpoint Json.1098:
        let Json.1096 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(3) ;
        let Json.1095 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1096;
        ret Json.1095;
    in
    let Json.1099 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
    let Json.1157 : U8 = GetTagId Json.1099;
    switch Json.1157:
        case 4:
            let Json.467 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1101 Json.1100:
                if Json.1100 then
                    let Json.1058 : U64 = 1i64;
                    let Json.1057 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1058;
                    let Json.1056 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1057;
                    ret Json.1056;
                else
                    jump Json.1098;
            in
            let Json.1103 : U8 = 34i64;
            let Json.1102 : Int1 = CallByName Bool.11 Json.467 Json.1103;
            jump Json.1101 Json.1102;
    
        case 0:
            let Json.1114 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
            let Json.470 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1114;
            let Json.471 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1111 Json.1105:
                if Json.1105 then
                    let Json.1062 : U64 = 1i64;
                    let Json.1061 : U64 = CallByName Num.19 Json.470 Json.1062;
                    let Json.1060 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(2) Json.1061;
                    let Json.1059 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1060;
                    ret Json.1059;
                else
                    let Json.1110 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
                    let Json.474 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1110;
                    let Json.475 : U8 = StructAtIndex 1 Json.1055;
                    joinpoint Json.1107 Json.1106:
                        if Json.1106 then
                            let Json.1066 : U64 = 1i64;
                            let Json.1065 : U64 = CallByName Num.19 Json.474 Json.1066;
                            let Json.1064 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(1) Json.1065;
                            let Json.1063 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1064;
                            ret Json.1063;
                        else
                            let Json.1097 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
                            let Json.478 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1097;
                            let Json.1070 : U64 = 1i64;
                            let Json.1069 : U64 = CallByName Num.19 Json.478 Json.1070;
                            let Json.1068 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1069;
                            let Json.1067 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1068;
                            ret Json.1067;
                    in
                    let Json.1109 : U8 = 92i64;
                    let Json.1108 : Int1 = CallByName Bool.11 Json.475 Json.1109;
                    jump Json.1107 Json.1108;
            in
            let Json.1113 : U8 = 34i64;
            let Json.1112 : Int1 = CallByName Bool.11 Json.471 Json.1113;
            jump Json.1111 Json.1112;
    
        case 1:
            let Json.1123 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
            let Json.481 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1123;
            let Json.482 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1121 Json.1115:
                if Json.1115 then
                    let Json.1074 : U64 = 1i64;
                    let Json.1073 : U64 = CallByName Num.19 Json.481 Json.1074;
                    let Json.1072 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1073;
                    let Json.1071 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1072;
                    ret Json.1071;
                else
                    let Json.1120 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
                    let Json.485 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1120;
                    let Json.486 : U8 = StructAtIndex 1 Json.1055;
                    joinpoint Json.1117 Json.1116:
                        if Json.1116 then
                            let Json.1078 : U64 = 1i64;
                            let Json.1077 : U64 = CallByName Num.19 Json.485 Json.1078;
                            let Json.1076 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(5) Json.1077;
                            let Json.1075 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1076;
                            ret Json.1075;
                        else
                            jump Json.1098;
                    in
                    let Json.1119 : U8 = 117i64;
                    let Json.1118 : Int1 = CallByName Bool.11 Json.486 Json.1119;
                    jump Json.1117 Json.1118;
            in
            let Json.1122 : Int1 = CallByName Json.58 Json.482;
            jump Json.1121 Json.1122;
    
        case 5:
            let Json.1144 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
            let Json.489 : U64 = UnionAtIndex (Id 5) (Index 0) Json.1144;
            let Json.490 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1125 Json.1124:
                if Json.1124 then
                    let Json.1082 : U64 = 1i64;
                    let Json.1081 : U64 = CallByName Num.19 Json.489 Json.1082;
                    let Json.1080 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(6) Json.1081;
                    let Json.1079 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1080;
                    ret Json.1079;
                else
                    jump Json.1098;
            in
            let Json.1126 : Int1 = CallByName Json.60 Json.490;
            jump Json.1125 Json.1126;
    
        case 6:
            let Json.1148 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
            let Json.493 : U64 = UnionAtIndex (Id 6) (Index 0) Json.1148;
            let Json.494 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1146 Json.1145:
                if Json.1145 then
                    let Json.1086 : U64 = 1i64;
                    let Json.1085 : U64 = CallByName Num.19 Json.493 Json.1086;
                    let Json.1084 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(7) Json.1085;
                    let Json.1083 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1084;
                    ret Json.1083;
                else
                    jump Json.1098;
            in
            let Json.1147 : Int1 = CallByName Json.60 Json.494;
            jump Json.1146 Json.1147;
    
        case 7:
            let Json.1152 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
            let Json.497 : U64 = UnionAtIndex (Id 7) (Index 0) Json.1152;
            let Json.498 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1150 Json.1149:
                if Json.1149 then
                    let Json.1090 : U64 = 1i64;
                    let Json.1089 : U64 = CallByName Num.19 Json.497 Json.1090;
                    let Json.1088 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(8) Json.1089;
                    let Json.1087 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1088;
                    ret Json.1087;
                else
                    jump Json.1098;
            in
            let Json.1151 : Int1 = CallByName Json.60 Json.498;
            jump Json.1150 Json.1151;
    
        case 8:
            let Json.1156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1055;
            let Json.501 : U64 = UnionAtIndex (Id 8) (Index 0) Json.1156;
            let Json.502 : U8 = StructAtIndex 1 Json.1055;
            joinpoint Json.1154 Json.1153:
                if Json.1153 then
                    let Json.1094 : U64 = 1i64;
                    let Json.1093 : U64 = CallByName Num.19 Json.501 Json.1094;
                    let Json.1092 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1093;
                    let Json.1091 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1092;
                    ret Json.1091;
                else
                    jump Json.1098;
            in
            let Json.1155 : Int1 = CallByName Json.60 Json.502;
            jump Json.1154 Json.1155;
    
        default:
            jump Json.1098;
    

procedure Json.58 (Json.507):
    switch Json.507:
        case 34:
            let Json.1004 : Int1 = CallByName Bool.2;
            ret Json.1004;
    
        case 92:
            let Json.1005 : Int1 = CallByName Bool.2;
            ret Json.1005;
    
        case 47:
            let Json.1006 : Int1 = CallByName Bool.2;
            ret Json.1006;
    
        case 98:
            let Json.1007 : Int1 = CallByName Bool.2;
            ret Json.1007;
    
        case 102:
            let Json.1008 : Int1 = CallByName Bool.2;
            ret Json.1008;
    
        case 110:
            let Json.1009 : Int1 = CallByName Bool.2;
            ret Json.1009;
    
        case 114:
            let Json.1010 : Int1 = CallByName Bool.2;
            ret Json.1010;
    
        case 116:
            let Json.1011 : Int1 = CallByName Bool.2;
            ret Json.1011;
    
        default:
            let Json.1012 : Int1 = CallByName Bool.1;
            ret Json.1012;
    

procedure Json.59 (Json.508):
    switch Json.508:
        case 34:
            let Json.982 : U8 = 34i64;
            ret Json.982;
    
        case 92:
            let Json.983 : U8 = 92i64;
            ret Json.983;
    
        case 47:
            let Json.984 : U8 = 47i64;
            ret Json.984;
    
        case 98:
            let Json.985 : U8 = 8i64;
            ret Json.985;
    
        case 102:
            let Json.986 : U8 = 12i64;
            ret Json.986;
    
        case 110:
            let Json.987 : U8 = 10i64;
            ret Json.987;
    
        case 114:
            let Json.988 : U8 = 13i64;
            ret Json.988;
    
        case 116:
            let Json.989 : U8 = 9i64;
            ret Json.989;
    
        default:
            ret Json.508;
    

procedure Json.60 (Json.509):
    let Json.1143 : U8 = 48i64;
    let Json.1140 : Int1 = CallByName Num.25 Json.509 Json.1143;
    let Json.1142 : U8 = 57i64;
    let Json.1141 : Int1 = CallByName Num.23 Json.509 Json.1142;
    let Json.1128 : Int1 = CallByName Bool.3 Json.1140 Json.1141;
    let Json.1139 : U8 = 97i64;
    let Json.1136 : Int1 = CallByName Num.25 Json.509 Json.1139;
    let Json.1138 : U8 = 102i64;
    let Json.1137 : Int1 = CallByName Num.23 Json.509 Json.1138;
    let Json.1130 : Int1 = CallByName Bool.3 Json.1136 Json.1137;
    let Json.1135 : U8 = 65i64;
    let Json.1132 : Int1 = CallByName Num.25 Json.509 Json.1135;
    let Json.1134 : U8 = 70i64;
    let Json.1133 : Int1 = CallByName Num.23 Json.509 Json.1134;
    let Json.1131 : Int1 = CallByName Bool.3 Json.1132 Json.1133;
    let Json.1129 : Int1 = CallByName Bool.4 Json.1130 Json.1131;
    let Json.1127 : Int1 = CallByName Bool.4 Json.1128 Json.1129;
    ret Json.1127;

procedure Json.61 (Json.510):
    let Json.961 : U8 = 48i64;
    let Json.958 : Int1 = CallByName Num.25 Json.510 Json.961;
    let Json.960 : U8 = 57i64;
    let Json.959 : Int1 = CallByName Num.23 Json.510 Json.960;
    let Json.955 : Int1 = CallByName Bool.3 Json.958 Json.959;
    if Json.955 then
        let Json.957 : U8 = 48i64;
        let Json.956 : U8 = CallByName Num.20 Json.510 Json.957;
        ret Json.956;
    else
        let Json.954 : U8 = 97i64;
        let Json.951 : Int1 = CallByName Num.25 Json.510 Json.954;
        let Json.953 : U8 = 102i64;
        let Json.952 : Int1 = CallByName Num.23 Json.510 Json.953;
        let Json.946 : Int1 = CallByName Bool.3 Json.951 Json.952;
        if Json.946 then
            let Json.950 : U8 = 97i64;
            let Json.948 : U8 = CallByName Num.20 Json.510 Json.950;
            let Json.949 : U8 = 10i64;
            let Json.947 : U8 = CallByName Num.19 Json.948 Json.949;
            ret Json.947;
        else
            let Json.945 : U8 = 65i64;
            let Json.942 : Int1 = CallByName Num.25 Json.510 Json.945;
            let Json.944 : U8 = 70i64;
            let Json.943 : Int1 = CallByName Num.23 Json.510 Json.944;
            let Json.937 : Int1 = CallByName Bool.3 Json.942 Json.943;
            if Json.937 then
                let Json.941 : U8 = 65i64;
                let Json.939 : U8 = CallByName Num.20 Json.510 Json.941;
                let Json.940 : U8 = 10i64;
                let Json.938 : U8 = CallByName Num.19 Json.939 Json.940;
                ret Json.938;
            else
                let Json.936 : Str = "got an invalid hex char";
                Crash Json.936

procedure Json.62 (Json.511, Json.512):
    let Json.927 : U8 = 4i64;
    let Json.926 : U8 = CallByName Num.72 Json.511 Json.927;
    let Json.925 : U8 = CallByName Num.71 Json.926 Json.512;
    ret Json.925;

procedure Json.63 (Json.513, Json.514, Json.515, Json.516):
    let Json.517 : U8 = CallByName Json.61 Json.513;
    let Json.518 : U8 = CallByName Json.61 Json.514;
    let Json.519 : U8 = CallByName Json.61 Json.515;
    let Json.520 : U8 = CallByName Json.61 Json.516;
    let Json.934 : U8 = 0i64;
    let Json.931 : Int1 = CallByName Bool.11 Json.517 Json.934;
    let Json.933 : U8 = 0i64;
    let Json.932 : Int1 = CallByName Bool.11 Json.518 Json.933;
    let Json.928 : Int1 = CallByName Bool.3 Json.931 Json.932;
    if Json.928 then
        let Json.930 : U8 = CallByName Json.62 Json.519 Json.520;
        let Json.929 : List U8 = Array [Json.930];
        ret Json.929;
    else
        let Json.923 : U8 = CallByName Json.62 Json.517 Json.518;
        let Json.924 : U8 = CallByName Json.62 Json.519 Json.520;
        let Json.922 : List U8 = Array [Json.923, Json.924];
        ret Json.922;

procedure Json.64 ():
    let Json.967 : U8 = 102i64;
    let Json.968 : U8 = 102i64;
    let Json.969 : U8 = 100i64;
    let Json.970 : U8 = 100i64;
    let Json.966 : List U8 = CallByName Json.63 Json.967 Json.968 Json.969 Json.970;
    ret Json.966;

procedure Json.65 (Json.1160):
    joinpoint Json.917 Json.899:
        let Json.521 : List U8 = StructAtIndex 0 Json.899;
        inc Json.521;
        let Json.522 : List U8 = StructAtIndex 1 Json.899;
        inc Json.522;
        dec Json.899;
        let Json.1035 : U64 = 0i64;
        let Json.523 : [C {}, C U8] = CallByName List.2 Json.521 Json.1035;
        let Json.1034 : U64 = 1i64;
        let Json.524 : [C {}, C U8] = CallByName List.2 Json.521 Json.1034;
        let Json.1033 : U64 = 2i64;
        inc Json.521;
        let Json.525 : List U8 = CallByName List.29 Json.521 Json.1033;
        let Json.1032 : U64 = 6i64;
        inc Json.521;
        let Json.526 : List U8 = CallByName List.29 Json.521 Json.1032;
        let Json.918 : {[C {}, C U8], [C {}, C U8]} = Struct {Json.523, Json.524};
        joinpoint Json.997:
            let Json.996 : [C {}, C U8] = StructAtIndex 0 Json.918;
            let Json.537 : U8 = UnionAtIndex (Id 1) (Index 0) Json.996;
            let Json.993 : List U8 = CallByName List.38 Json.521;
            let Json.994 : List U8 = CallByName List.4 Json.522 Json.537;
            let Json.992 : {List U8, List U8} = Struct {Json.993, Json.994};
            jump Json.917 Json.992;
        in
        let Json.1028 : [C {}, C U8] = StructAtIndex 0 Json.918;
        let Json.1029 : U8 = 1i64;
        let Json.1030 : U8 = GetTagId Json.1028;
        let Json.1031 : Int1 = lowlevel Eq Json.1029 Json.1030;
        if Json.1031 then
            let Json.1024 : [C {}, C U8] = StructAtIndex 1 Json.918;
            let Json.1025 : U8 = 1i64;
            let Json.1026 : U8 = GetTagId Json.1024;
            let Json.1027 : Int1 = lowlevel Eq Json.1025 Json.1026;
            if Json.1027 then
                let Json.1023 : [C {}, C U8] = StructAtIndex 0 Json.918;
                let Json.528 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1023;
                let Json.1022 : [C {}, C U8] = StructAtIndex 1 Json.918;
                let Json.529 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1022;
                joinpoint Json.1016 Json.998:
                    if Json.998 then
                        dec Json.521;
                        let Json.975 : U64 = lowlevel ListLen Json.525;
                        let Json.976 : U64 = 4i64;
                        let Json.977 : Int1 = lowlevel NumGte Json.975 Json.976;
                        if Json.977 then
                            let Json.974 : U64 = 0i64;
                            let Json.530 : U8 = lowlevel ListGetUnsafe Json.525 Json.974;
                            let Json.973 : U64 = 1i64;
                            let Json.531 : U8 = lowlevel ListGetUnsafe Json.525 Json.973;
                            let Json.972 : U64 = 2i64;
                            let Json.532 : U8 = lowlevel ListGetUnsafe Json.525 Json.972;
                            let Json.971 : U64 = 3i64;
                            let Json.533 : U8 = lowlevel ListGetUnsafe Json.525 Json.971;
                            dec Json.525;
                            let Json.534 : List U8 = CallByName Json.63 Json.530 Json.531 Json.532 Json.533;
                            let Json.921 : List U8 = CallByName List.8 Json.522 Json.534;
                            let Json.920 : {List U8, List U8} = Struct {Json.526, Json.921};
                            jump Json.917 Json.920;
                        else
                            dec Json.526;
                            let Json.965 : List U8 = CallByName Json.64;
                            let Json.964 : List U8 = CallByName List.8 Json.522 Json.965;
                            let Json.963 : {List U8, List U8} = Struct {Json.525, Json.964};
                            jump Json.917 Json.963;
                    else
                        dec Json.526;
                        let Json.1015 : [C {}, C U8] = StructAtIndex 0 Json.918;
                        let Json.535 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1015;
                        let Json.1014 : [C {}, C U8] = StructAtIndex 1 Json.918;
                        let Json.536 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1014;
                        joinpoint Json.1000 Json.999:
                            if Json.999 then
                                dec Json.521;
                                let Json.981 : U8 = CallByName Json.59 Json.536;
                                let Json.980 : List U8 = CallByName List.4 Json.522 Json.981;
                                let Json.979 : {List U8, List U8} = Struct {Json.525, Json.980};
                                jump Json.917 Json.979;
                            else
                                dec Json.525;
                                jump Json.997;
                        in
                        let Json.1013 : U8 = 92i64;
                        let Json.1002 : Int1 = CallByName Bool.11 Json.535 Json.1013;
                        let Json.1003 : Int1 = CallByName Json.58 Json.536;
                        let Json.1001 : Int1 = CallByName Bool.3 Json.1002 Json.1003;
                        jump Json.1000 Json.1001;
                in
                let Json.1021 : U8 = 92i64;
                let Json.1018 : Int1 = CallByName Bool.11 Json.528 Json.1021;
                let Json.1020 : U8 = 117i64;
                let Json.1019 : Int1 = CallByName Bool.11 Json.529 Json.1020;
                let Json.1017 : Int1 = CallByName Bool.3 Json.1018 Json.1019;
                jump Json.1016 Json.1017;
            else
                dec Json.526;
                dec Json.525;
                jump Json.997;
        else
            dec Json.526;
            dec Json.525;
            let Json.995 : {List U8, List U8} = Struct {Json.521, Json.522};
            ret Json.995;
    in
    jump Json.917 Json.1160;

procedure List.1 (List.95):
    let List.552 : U64 = CallByName List.6 List.95;
    let List.553 : U64 = 0i64;
    let List.551 : Int1 = CallByName Bool.11 List.552 List.553;
    ret List.551;

procedure List.2 (List.96, List.97):
    let List.550 : U64 = CallByName List.6 List.96;
    let List.547 : Int1 = CallByName Num.22 List.97 List.550;
    if List.547 then
        let List.549 : U8 = CallByName List.66 List.96 List.97;
        let List.548 : [C {}, C U8] = TagId(1) List.549;
        ret List.548;
    else
        let List.546 : {} = Struct {};
        let List.545 : [C {}, C U8] = TagId(0) List.546;
        ret List.545;

procedure List.26 (List.153, List.154, List.155):
    let List.561 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.92 List.153 List.154 List.155;
    let List.564 : U8 = 1i64;
    let List.565 : U8 = GetTagId List.561;
    let List.566 : Int1 = lowlevel Eq List.564 List.565;
    if List.566 then
        let List.156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.561;
        ret List.156;
    else
        let List.157 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.561;
        ret List.157;

procedure List.29 (List.298, List.299):
    let List.537 : U64 = CallByName List.6 List.298;
    let List.300 : U64 = CallByName Num.77 List.537 List.299;
    let List.536 : List U8 = CallByName List.43 List.298 List.300;
    ret List.536;

procedure List.31 (#Attr.2, #Attr.3):
    let List.502 : List U8 = lowlevel ListDropAt #Attr.2 #Attr.3;
    ret List.502;

procedure List.32 (List.293):
    let List.503 : U64 = CallByName List.6 List.293;
    let List.504 : U64 = 1i64;
    let List.501 : U64 = CallByName Num.77 List.503 List.504;
    let List.500 : List U8 = CallByName List.31 List.293 List.501;
    ret List.500;

procedure List.38 (List.292):
    let List.509 : U64 = 0i64;
    let List.508 : List U8 = CallByName List.31 List.292 List.509;
    ret List.508;

procedure List.4 (List.107, List.108):
    let List.519 : U64 = 1i64;
    let List.518 : List U8 = CallByName List.70 List.107 List.519;
    let List.517 : List U8 = CallByName List.71 List.518 List.108;
    ret List.517;

procedure List.43 (List.296, List.297):
    let List.532 : U64 = CallByName List.6 List.296;
    let List.531 : U64 = CallByName Num.77 List.532 List.297;
    let List.522 : {U64, U64} = Struct {List.297, List.531};
    let List.521 : List U8 = CallByName List.49 List.296 List.522;
    ret List.521;

procedure List.49 (List.370, List.371):
    let List.559 : U64 = StructAtIndex 0 List.371;
    let List.560 : U64 = 0i64;
    let List.557 : Int1 = CallByName Bool.11 List.559 List.560;
    if List.557 then
        dec List.370;
        let List.558 : List U8 = Array [];
        ret List.558;
    else
        let List.555 : U64 = StructAtIndex 1 List.371;
        let List.556 : U64 = StructAtIndex 0 List.371;
        let List.554 : List U8 = CallByName List.72 List.370 List.555 List.556;
        ret List.554;

procedure List.6 (#Attr.2):
    let List.620 : U64 = lowlevel ListLen #Attr.2;
    ret List.620;

procedure List.66 (#Attr.2, #Attr.3):
    let List.543 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.543;

procedure List.70 (#Attr.2, #Attr.3):
    let List.516 : List U8 = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.516;

procedure List.71 (#Attr.2, #Attr.3):
    let List.514 : List U8 = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.514;

procedure List.72 (#Attr.2, #Attr.3, #Attr.4):
    let List.526 : List U8 = lowlevel ListSublist #Attr.2 #Attr.3 #Attr.4;
    ret List.526;

procedure List.8 (#Attr.2, #Attr.3):
    let List.511 : List U8 = lowlevel ListConcat #Attr.2 #Attr.3;
    ret List.511;

procedure List.80 (List.612, List.613, List.614, List.615, List.616):
    joinpoint List.570 List.433 List.434 List.435 List.436 List.437:
        let List.572 : Int1 = CallByName Num.22 List.436 List.437;
        if List.572 then
            let List.581 : U8 = CallByName List.66 List.433 List.436;
            let List.573 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName Json.57 List.434 List.581;
            let List.578 : U8 = 1i64;
            let List.579 : U8 = GetTagId List.573;
            let List.580 : Int1 = lowlevel Eq List.578 List.579;
            if List.580 then
                let List.438 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.573;
                let List.576 : U64 = 1i64;
                let List.575 : U64 = CallByName Num.19 List.436 List.576;
                jump List.570 List.433 List.438 List.435 List.575 List.437;
            else
                let List.439 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.573;
                let List.577 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) List.439;
                ret List.577;
        else
            let List.571 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) List.434;
            ret List.571;
    in
    jump List.570 List.612 List.613 List.614 List.615 List.616;

procedure List.92 (List.430, List.431, List.432):
    let List.568 : U64 = 0i64;
    let List.569 : U64 = CallByName List.6 List.430;
    let List.567 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.80 List.430 List.431 List.432 List.568 List.569;
    ret List.567;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.278 : U8 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.278;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.325 : U64 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.325;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.290 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.290;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.324 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.324;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.296 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.296;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.302 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.302;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.275 : U8 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.275;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.276 : U8 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.276;

procedure Num.77 (#Attr.2, #Attr.3):
    let Num.321 : U64 = lowlevel NumSubSaturated #Attr.2 #Attr.3;
    ret Num.321;

procedure Str.48 (#Attr.2, #Attr.3, #Attr.4):
    let Str.307 : {U64, Str, Int1, U8} = lowlevel StrFromUtf8Range #Attr.2 #Attr.3 #Attr.4;
    ret Str.307;

procedure Str.9 (Str.79):
    let Str.305 : U64 = 0i64;
    let Str.306 : U64 = CallByName List.6 Str.79;
    let Str.80 : {U64, Str, Int1, U8} = CallByName Str.48 Str.79 Str.305 Str.306;
    let Str.302 : Int1 = StructAtIndex 2 Str.80;
    if Str.302 then
        let Str.304 : Str = StructAtIndex 1 Str.80;
        inc Str.304;
        dec Str.80;
        let Str.303 : [C {U64, U8}, C Str] = TagId(1) Str.304;
        ret Str.303;
    else
        let Str.300 : U8 = StructAtIndex 3 Str.80;
        let Str.301 : U64 = StructAtIndex 0 Str.80;
        dec Str.80;
        let Str.299 : {U64, U8} = Struct {Str.301, Str.300};
        let Str.298 : [C {U64, U8}, C Str] = TagId(0) Str.299;
        ret Str.298;

procedure Test.3 ():
    let Test.0 : List U8 = Array [82i64, 111i64, 99i64];
    let Test.8 : {} = CallByName Json.2;
    inc Test.0;
    let Test.1 : [C [C List U8, C ], C Str] = CallByName Decode.27 Test.0 Test.8;
    let Test.7 : Str = "Roc";
    let Test.6 : [C [C List U8, C ], C Str] = TagId(1) Test.7;
    inc Test.1;
    let Test.5 : Int1 = CallByName Bool.11 Test.1 Test.6;
    expect Test.5;
    let Test.4 : {} = Struct {};
    ret Test.4;
