procedure Bool.1 ():
    let Bool.55 : Int1 = false;
    ret Bool.55;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    dec #Attr.3;
    dec #Attr.2;
    ret Bool.23;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.46 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.46;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.66 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.66;

procedure Bool.2 ():
    let Bool.54 : Int1 = true;
    ret Bool.54;

procedure Bool.3 (#Attr.2, #Attr.3):
    let Bool.37 : Int1 = lowlevel And #Attr.2 #Attr.3;
    ret Bool.37;

procedure Bool.4 (#Attr.2, #Attr.3):
    let Bool.57 : Int1 = lowlevel Or #Attr.2 #Attr.3;
    ret Bool.57;

procedure Decode.24 (Decode.101):
    ret Decode.101;

procedure Decode.25 (Decode.102, Decode.121, Decode.104):
    let Decode.134 : {List U8, [C {}, C Str]} = CallByName Json.448 Decode.102 Decode.104;
    ret Decode.134;

procedure Decode.26 (Decode.105, Decode.106):
    let Decode.133 : {} = CallByName Json.55;
    let Decode.132 : {List U8, [C {}, C Str]} = CallByName Decode.25 Decode.105 Decode.133 Decode.106;
    ret Decode.132;

procedure Decode.27 (Decode.107, Decode.108):
    let Decode.122 : {List U8, [C {}, C Str]} = CallByName Decode.26 Decode.107 Decode.108;
    let Decode.110 : List U8 = StructAtIndex 0 Decode.122;
    inc Decode.110;
    let Decode.109 : [C {}, C Str] = StructAtIndex 1 Decode.122;
    inc Decode.109;
    dec Decode.122;
    let Decode.125 : Int1 = CallByName List.1 Decode.110;
    if Decode.125 then
        dec Decode.110;
        let Decode.129 : U8 = 1i64;
        let Decode.130 : U8 = GetTagId Decode.109;
        let Decode.131 : Int1 = lowlevel Eq Decode.129 Decode.130;
        if Decode.131 then
            let Decode.111 : Str = UnionAtIndex (Id 1) (Index 0) Decode.109;
            inc Decode.111;
            dec Decode.109;
            let Decode.126 : [C [C List U8, C ], C Str] = TagId(1) Decode.111;
            ret Decode.126;
        else
            dec Decode.109;
            let Decode.128 : [C List U8, C ] = TagId(1) ;
            let Decode.127 : [C [C List U8, C ], C Str] = TagId(0) Decode.128;
            ret Decode.127;
    else
        dec Decode.109;
        let Decode.124 : [C List U8, C ] = TagId(0) Decode.110;
        let Decode.123 : [C [C List U8, C ], C Str] = TagId(0) Decode.124;
        ret Decode.123;

procedure Json.2 ():
    let Json.888 : {} = Struct {};
    ret Json.888;

procedure Json.448 (Json.449, Json.891):
    inc Json.449;
    let Json.1028 : {List U8, List U8} = CallByName Json.56 Json.449;
    let Json.452 : List U8 = StructAtIndex 0 Json.1028;
    inc Json.452;
    let Json.451 : List U8 = StructAtIndex 1 Json.1028;
    inc Json.451;
    dec Json.1028;
    let Json.1024 : Int1 = CallByName List.1 Json.451;
    if Json.1024 then
        dec Json.452;
        dec Json.451;
        let Json.1027 : {} = Struct {};
        let Json.1026 : [C {}, C Str] = TagId(0) Json.1027;
        let Json.1025 : {List U8, [C {}, C Str]} = Struct {Json.449, Json.1026};
        ret Json.1025;
    else
        let Json.1023 : List U8 = Array [];
        let Json.903 : {List U8, List U8} = Struct {Json.451, Json.1023};
        let Json.902 : {List U8, List U8} = CallByName Json.65 Json.903;
        let Json.456 : List U8 = StructAtIndex 1 Json.902;
        inc Json.456;
        dec Json.902;
        let Json.901 : List U8 = CallByName List.38 Json.456;
        let Json.900 : List U8 = CallByName List.32 Json.901;
        let Json.457 : [C {U64, U8}, C Str] = CallByName Str.9 Json.900;
        let Json.897 : U8 = 1i64;
        let Json.898 : U8 = GetTagId Json.457;
        let Json.899 : Int1 = lowlevel Eq Json.897 Json.898;
        if Json.899 then
            dec Json.449;
            let Json.458 : Str = UnionAtIndex (Id 1) (Index 0) Json.457;
            inc Json.458;
            dec Json.457;
            let Json.893 : [C {}, C Str] = TagId(1) Json.458;
            let Json.892 : {List U8, [C {}, C Str]} = Struct {Json.452, Json.893};
            ret Json.892;
        else
            dec Json.457;
            dec Json.452;
            let Json.896 : {} = Struct {};
            let Json.895 : [C {}, C Str] = TagId(0) Json.896;
            let Json.894 : {List U8, [C {}, C Str]} = Struct {Json.449, Json.895};
            ret Json.894;

procedure Json.55 ():
    let Json.890 : {} = Struct {};
    let Json.889 : {} = CallByName Decode.24 Json.890;
    ret Json.889;

procedure Json.56 (Json.462):
    let Json.1040 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(4) ;
    let Json.1041 : {} = Struct {};
    let Json.1029 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = CallByName List.26 Json.462 Json.1040 Json.1041;
    let Json.1037 : U8 = 2i64;
    let Json.1038 : U8 = GetTagId Json.1029;
    let Json.1039 : Int1 = lowlevel Eq Json.1037 Json.1038;
    if Json.1039 then
        let Json.464 : U64 = UnionAtIndex (Id 2) (Index 0) Json.1029;
        inc Json.462;
        let Json.1031 : List U8 = CallByName List.29 Json.462 Json.464;
        let Json.1034 : U64 = 0i64;
        let Json.1033 : {U64, U64} = Struct {Json.464, Json.1034};
        let Json.1032 : List U8 = CallByName List.49 Json.462 Json.1033;
        let Json.1030 : {List U8, List U8} = Struct {Json.1031, Json.1032};
        ret Json.1030;
    else
        let Json.1036 : List U8 = Array [];
        let Json.1035 : {List U8, List U8} = Struct {Json.462, Json.1036};
        ret Json.1035;

procedure Json.57 (Json.465, Json.466):
    let Json.1042 : {[C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], U8} = Struct {Json.465, Json.466};
    joinpoint Json.1085:
        let Json.1083 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(3) ;
        let Json.1082 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1083;
        ret Json.1082;
    in
    let Json.1086 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
    let Json.1144 : U8 = GetTagId Json.1086;
    switch Json.1144:
        case 4:
            let Json.467 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1088 Json.1087:
                if Json.1087 then
                    let Json.1045 : U64 = 1i64;
                    let Json.1044 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1045;
                    let Json.1043 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1044;
                    ret Json.1043;
                else
                    jump Json.1085;
            in
            let Json.1090 : U8 = 34i64;
            let Json.1089 : Int1 = CallByName Bool.11 Json.467 Json.1090;
            jump Json.1088 Json.1089;
    
        case 0:
            let Json.1101 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
            let Json.470 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1101;
            let Json.471 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1098 Json.1092:
                if Json.1092 then
                    let Json.1049 : U64 = 1i64;
                    let Json.1048 : U64 = CallByName Num.19 Json.470 Json.1049;
                    let Json.1047 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(2) Json.1048;
                    let Json.1046 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1047;
                    ret Json.1046;
                else
                    let Json.1097 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
                    let Json.474 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1097;
                    let Json.475 : U8 = StructAtIndex 1 Json.1042;
                    joinpoint Json.1094 Json.1093:
                        if Json.1093 then
                            let Json.1053 : U64 = 1i64;
                            let Json.1052 : U64 = CallByName Num.19 Json.474 Json.1053;
                            let Json.1051 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(1) Json.1052;
                            let Json.1050 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1051;
                            ret Json.1050;
                        else
                            let Json.1084 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
                            let Json.478 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1084;
                            let Json.1057 : U64 = 1i64;
                            let Json.1056 : U64 = CallByName Num.19 Json.478 Json.1057;
                            let Json.1055 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1056;
                            let Json.1054 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1055;
                            ret Json.1054;
                    in
                    let Json.1096 : U8 = 92i64;
                    let Json.1095 : Int1 = CallByName Bool.11 Json.475 Json.1096;
                    jump Json.1094 Json.1095;
            in
            let Json.1100 : U8 = 34i64;
            let Json.1099 : Int1 = CallByName Bool.11 Json.471 Json.1100;
            jump Json.1098 Json.1099;
    
        case 1:
            let Json.1110 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
            let Json.481 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1110;
            let Json.482 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1108 Json.1102:
                if Json.1102 then
                    let Json.1061 : U64 = 1i64;
                    let Json.1060 : U64 = CallByName Num.19 Json.481 Json.1061;
                    let Json.1059 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1060;
                    let Json.1058 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1059;
                    ret Json.1058;
                else
                    let Json.1107 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
                    let Json.485 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1107;
                    let Json.486 : U8 = StructAtIndex 1 Json.1042;
                    joinpoint Json.1104 Json.1103:
                        if Json.1103 then
                            let Json.1065 : U64 = 1i64;
                            let Json.1064 : U64 = CallByName Num.19 Json.485 Json.1065;
                            let Json.1063 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(5) Json.1064;
                            let Json.1062 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1063;
                            ret Json.1062;
                        else
                            jump Json.1085;
                    in
                    let Json.1106 : U8 = 117i64;
                    let Json.1105 : Int1 = CallByName Bool.11 Json.486 Json.1106;
                    jump Json.1104 Json.1105;
            in
            let Json.1109 : Int1 = CallByName Json.58 Json.482;
            jump Json.1108 Json.1109;
    
        case 5:
            let Json.1131 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
            let Json.489 : U64 = UnionAtIndex (Id 5) (Index 0) Json.1131;
            let Json.490 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1112 Json.1111:
                if Json.1111 then
                    let Json.1069 : U64 = 1i64;
                    let Json.1068 : U64 = CallByName Num.19 Json.489 Json.1069;
                    let Json.1067 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(6) Json.1068;
                    let Json.1066 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1067;
                    ret Json.1066;
                else
                    jump Json.1085;
            in
            let Json.1113 : Int1 = CallByName Json.60 Json.490;
            jump Json.1112 Json.1113;
    
        case 6:
            let Json.1135 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
            let Json.493 : U64 = UnionAtIndex (Id 6) (Index 0) Json.1135;
            let Json.494 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1133 Json.1132:
                if Json.1132 then
                    let Json.1073 : U64 = 1i64;
                    let Json.1072 : U64 = CallByName Num.19 Json.493 Json.1073;
                    let Json.1071 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(7) Json.1072;
                    let Json.1070 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1071;
                    ret Json.1070;
                else
                    jump Json.1085;
            in
            let Json.1134 : Int1 = CallByName Json.60 Json.494;
            jump Json.1133 Json.1134;
    
        case 7:
            let Json.1139 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
            let Json.497 : U64 = UnionAtIndex (Id 7) (Index 0) Json.1139;
            let Json.498 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1137 Json.1136:
                if Json.1136 then
                    let Json.1077 : U64 = 1i64;
                    let Json.1076 : U64 = CallByName Num.19 Json.497 Json.1077;
                    let Json.1075 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(8) Json.1076;
                    let Json.1074 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1075;
                    ret Json.1074;
                else
                    jump Json.1085;
            in
            let Json.1138 : Int1 = CallByName Json.60 Json.498;
            jump Json.1137 Json.1138;
    
        case 8:
            let Json.1143 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1042;
            let Json.501 : U64 = UnionAtIndex (Id 8) (Index 0) Json.1143;
            let Json.502 : U8 = StructAtIndex 1 Json.1042;
            joinpoint Json.1141 Json.1140:
                if Json.1140 then
                    let Json.1081 : U64 = 1i64;
                    let Json.1080 : U64 = CallByName Num.19 Json.501 Json.1081;
                    let Json.1079 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1080;
                    let Json.1078 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1079;
                    ret Json.1078;
                else
                    jump Json.1085;
            in
            let Json.1142 : Int1 = CallByName Json.60 Json.502;
            jump Json.1141 Json.1142;
    
        default:
            jump Json.1085;
    

procedure Json.58 (Json.507):
    switch Json.507:
        case 34:
            let Json.991 : Int1 = CallByName Bool.2;
            ret Json.991;
    
        case 92:
            let Json.992 : Int1 = CallByName Bool.2;
            ret Json.992;
    
        case 47:
            let Json.993 : Int1 = CallByName Bool.2;
            ret Json.993;
    
        case 98:
            let Json.994 : Int1 = CallByName Bool.2;
            ret Json.994;
    
        case 102:
            let Json.995 : Int1 = CallByName Bool.2;
            ret Json.995;
    
        case 110:
            let Json.996 : Int1 = CallByName Bool.2;
            ret Json.996;
    
        case 114:
            let Json.997 : Int1 = CallByName Bool.2;
            ret Json.997;
    
        case 116:
            let Json.998 : Int1 = CallByName Bool.2;
            ret Json.998;
    
        default:
            let Json.999 : Int1 = CallByName Bool.1;
            ret Json.999;
    

procedure Json.59 (Json.508):
    switch Json.508:
        case 34:
            let Json.969 : U8 = 34i64;
            ret Json.969;
    
        case 92:
            let Json.970 : U8 = 92i64;
            ret Json.970;
    
        case 47:
            let Json.971 : U8 = 47i64;
            ret Json.971;
    
        case 98:
            let Json.972 : U8 = 8i64;
            ret Json.972;
    
        case 102:
            let Json.973 : U8 = 12i64;
            ret Json.973;
    
        case 110:
            let Json.974 : U8 = 10i64;
            ret Json.974;
    
        case 114:
            let Json.975 : U8 = 13i64;
            ret Json.975;
    
        case 116:
            let Json.976 : U8 = 9i64;
            ret Json.976;
    
        default:
            ret Json.508;
    

procedure Json.60 (Json.509):
    let Json.1130 : U8 = 48i64;
    let Json.1127 : Int1 = CallByName Num.25 Json.509 Json.1130;
    let Json.1129 : U8 = 57i64;
    let Json.1128 : Int1 = CallByName Num.23 Json.509 Json.1129;
    let Json.1115 : Int1 = CallByName Bool.3 Json.1127 Json.1128;
    let Json.1126 : U8 = 97i64;
    let Json.1123 : Int1 = CallByName Num.25 Json.509 Json.1126;
    let Json.1125 : U8 = 102i64;
    let Json.1124 : Int1 = CallByName Num.23 Json.509 Json.1125;
    let Json.1117 : Int1 = CallByName Bool.3 Json.1123 Json.1124;
    let Json.1122 : U8 = 65i64;
    let Json.1119 : Int1 = CallByName Num.25 Json.509 Json.1122;
    let Json.1121 : U8 = 70i64;
    let Json.1120 : Int1 = CallByName Num.23 Json.509 Json.1121;
    let Json.1118 : Int1 = CallByName Bool.3 Json.1119 Json.1120;
    let Json.1116 : Int1 = CallByName Bool.4 Json.1117 Json.1118;
    let Json.1114 : Int1 = CallByName Bool.4 Json.1115 Json.1116;
    ret Json.1114;

procedure Json.61 (Json.510):
    let Json.948 : U8 = 48i64;
    let Json.945 : Int1 = CallByName Num.25 Json.510 Json.948;
    let Json.947 : U8 = 57i64;
    let Json.946 : Int1 = CallByName Num.23 Json.510 Json.947;
    let Json.942 : Int1 = CallByName Bool.3 Json.945 Json.946;
    if Json.942 then
        let Json.944 : U8 = 48i64;
        let Json.943 : U8 = CallByName Num.20 Json.510 Json.944;
        ret Json.943;
    else
        let Json.941 : U8 = 97i64;
        let Json.938 : Int1 = CallByName Num.25 Json.510 Json.941;
        let Json.940 : U8 = 102i64;
        let Json.939 : Int1 = CallByName Num.23 Json.510 Json.940;
        let Json.933 : Int1 = CallByName Bool.3 Json.938 Json.939;
        if Json.933 then
            let Json.937 : U8 = 97i64;
            let Json.935 : U8 = CallByName Num.20 Json.510 Json.937;
            let Json.936 : U8 = 10i64;
            let Json.934 : U8 = CallByName Num.19 Json.935 Json.936;
            ret Json.934;
        else
            let Json.932 : U8 = 65i64;
            let Json.929 : Int1 = CallByName Num.25 Json.510 Json.932;
            let Json.931 : U8 = 70i64;
            let Json.930 : Int1 = CallByName Num.23 Json.510 Json.931;
            let Json.924 : Int1 = CallByName Bool.3 Json.929 Json.930;
            if Json.924 then
                let Json.928 : U8 = 65i64;
                let Json.926 : U8 = CallByName Num.20 Json.510 Json.928;
                let Json.927 : U8 = 10i64;
                let Json.925 : U8 = CallByName Num.19 Json.926 Json.927;
                ret Json.925;
            else
                let Json.923 : Str = "got an invalid hex char";
                Crash Json.923

procedure Json.62 (Json.511, Json.512):
    let Json.914 : U8 = 4i64;
    let Json.913 : U8 = CallByName Num.72 Json.511 Json.914;
    let Json.912 : U8 = CallByName Num.71 Json.913 Json.512;
    ret Json.912;

procedure Json.63 (Json.513, Json.514, Json.515, Json.516):
    let Json.517 : U8 = CallByName Json.61 Json.513;
    let Json.518 : U8 = CallByName Json.61 Json.514;
    let Json.519 : U8 = CallByName Json.61 Json.515;
    let Json.520 : U8 = CallByName Json.61 Json.516;
    let Json.921 : U8 = 0i64;
    let Json.918 : Int1 = CallByName Bool.11 Json.517 Json.921;
    let Json.920 : U8 = 0i64;
    let Json.919 : Int1 = CallByName Bool.11 Json.518 Json.920;
    let Json.915 : Int1 = CallByName Bool.3 Json.918 Json.919;
    if Json.915 then
        let Json.917 : U8 = CallByName Json.62 Json.519 Json.520;
        let Json.916 : List U8 = Array [Json.917];
        ret Json.916;
    else
        let Json.910 : U8 = CallByName Json.62 Json.517 Json.518;
        let Json.911 : U8 = CallByName Json.62 Json.519 Json.520;
        let Json.909 : List U8 = Array [Json.910, Json.911];
        ret Json.909;

procedure Json.64 ():
    let Json.954 : U8 = 102i64;
    let Json.955 : U8 = 102i64;
    let Json.956 : U8 = 100i64;
    let Json.957 : U8 = 100i64;
    let Json.953 : List U8 = CallByName Json.63 Json.954 Json.955 Json.956 Json.957;
    ret Json.953;

procedure Json.65 (Json.1147):
    joinpoint Json.904 Json.886:
        let Json.521 : List U8 = StructAtIndex 0 Json.886;
        inc Json.521;
        let Json.522 : List U8 = StructAtIndex 1 Json.886;
        inc Json.522;
        dec Json.886;
        let Json.1022 : U64 = 0i64;
        let Json.523 : [C {}, C U8] = CallByName List.2 Json.521 Json.1022;
        let Json.1021 : U64 = 1i64;
        let Json.524 : [C {}, C U8] = CallByName List.2 Json.521 Json.1021;
        let Json.1020 : U64 = 2i64;
        inc Json.521;
        let Json.525 : List U8 = CallByName List.29 Json.521 Json.1020;
        let Json.1019 : U64 = 6i64;
        inc Json.521;
        let Json.526 : List U8 = CallByName List.29 Json.521 Json.1019;
        let Json.905 : {[C {}, C U8], [C {}, C U8]} = Struct {Json.523, Json.524};
        joinpoint Json.984:
            let Json.983 : [C {}, C U8] = StructAtIndex 0 Json.905;
            let Json.537 : U8 = UnionAtIndex (Id 1) (Index 0) Json.983;
            let Json.980 : List U8 = CallByName List.38 Json.521;
            let Json.981 : List U8 = CallByName List.4 Json.522 Json.537;
            let Json.979 : {List U8, List U8} = Struct {Json.980, Json.981};
            jump Json.904 Json.979;
        in
        let Json.1015 : [C {}, C U8] = StructAtIndex 0 Json.905;
        let Json.1016 : U8 = 1i64;
        let Json.1017 : U8 = GetTagId Json.1015;
        let Json.1018 : Int1 = lowlevel Eq Json.1016 Json.1017;
        if Json.1018 then
            let Json.1011 : [C {}, C U8] = StructAtIndex 1 Json.905;
            let Json.1012 : U8 = 1i64;
            let Json.1013 : U8 = GetTagId Json.1011;
            let Json.1014 : Int1 = lowlevel Eq Json.1012 Json.1013;
            if Json.1014 then
                let Json.1010 : [C {}, C U8] = StructAtIndex 0 Json.905;
                let Json.528 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1010;
                let Json.1009 : [C {}, C U8] = StructAtIndex 1 Json.905;
                let Json.529 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1009;
                joinpoint Json.1003 Json.985:
                    if Json.985 then
                        dec Json.521;
                        let Json.962 : U64 = lowlevel ListLen Json.525;
                        let Json.963 : U64 = 4i64;
                        let Json.964 : Int1 = lowlevel NumGte Json.962 Json.963;
                        if Json.964 then
                            let Json.961 : U64 = 0i64;
                            let Json.530 : U8 = lowlevel ListGetUnsafe Json.525 Json.961;
                            let Json.960 : U64 = 1i64;
                            let Json.531 : U8 = lowlevel ListGetUnsafe Json.525 Json.960;
                            let Json.959 : U64 = 2i64;
                            let Json.532 : U8 = lowlevel ListGetUnsafe Json.525 Json.959;
                            let Json.958 : U64 = 3i64;
                            let Json.533 : U8 = lowlevel ListGetUnsafe Json.525 Json.958;
                            dec Json.525;
                            let Json.534 : List U8 = CallByName Json.63 Json.530 Json.531 Json.532 Json.533;
                            let Json.908 : List U8 = CallByName List.8 Json.522 Json.534;
                            let Json.907 : {List U8, List U8} = Struct {Json.526, Json.908};
                            jump Json.904 Json.907;
                        else
                            dec Json.526;
                            let Json.952 : List U8 = CallByName Json.64;
                            let Json.951 : List U8 = CallByName List.8 Json.522 Json.952;
                            let Json.950 : {List U8, List U8} = Struct {Json.525, Json.951};
                            jump Json.904 Json.950;
                    else
                        dec Json.526;
                        let Json.1002 : [C {}, C U8] = StructAtIndex 0 Json.905;
                        let Json.535 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1002;
                        let Json.1001 : [C {}, C U8] = StructAtIndex 1 Json.905;
                        let Json.536 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1001;
                        joinpoint Json.987 Json.986:
                            if Json.986 then
                                dec Json.521;
                                let Json.968 : U8 = CallByName Json.59 Json.536;
                                let Json.967 : List U8 = CallByName List.4 Json.522 Json.968;
                                let Json.966 : {List U8, List U8} = Struct {Json.525, Json.967};
                                jump Json.904 Json.966;
                            else
                                dec Json.525;
                                jump Json.984;
                        in
                        let Json.1000 : U8 = 92i64;
                        let Json.989 : Int1 = CallByName Bool.11 Json.535 Json.1000;
                        let Json.990 : Int1 = CallByName Json.58 Json.536;
                        let Json.988 : Int1 = CallByName Bool.3 Json.989 Json.990;
                        jump Json.987 Json.988;
                in
                let Json.1008 : U8 = 92i64;
                let Json.1005 : Int1 = CallByName Bool.11 Json.528 Json.1008;
                let Json.1007 : U8 = 117i64;
                let Json.1006 : Int1 = CallByName Bool.11 Json.529 Json.1007;
                let Json.1004 : Int1 = CallByName Bool.3 Json.1005 Json.1006;
                jump Json.1003 Json.1004;
            else
                dec Json.526;
                dec Json.525;
                jump Json.984;
        else
            dec Json.526;
            dec Json.525;
            let Json.982 : {List U8, List U8} = Struct {Json.521, Json.522};
            ret Json.982;
    in
    jump Json.904 Json.1147;

procedure List.1 (List.95):
    let List.552 : U64 = CallByName List.6 List.95;
    let List.553 : U64 = 0i64;
    let List.551 : Int1 = CallByName Bool.11 List.552 List.553;
    ret List.551;

procedure List.2 (List.96, List.97):
    let List.550 : U64 = CallByName List.6 List.96;
    let List.547 : Int1 = CallByName Num.22 List.97 List.550;
    if List.547 then
        let List.549 : U8 = CallByName List.66 List.96 List.97;
        let List.548 : [C {}, C U8] = TagId(1) List.549;
        ret List.548;
    else
        let List.546 : {} = Struct {};
        let List.545 : [C {}, C U8] = TagId(0) List.546;
        ret List.545;

procedure List.26 (List.153, List.154, List.155):
    let List.561 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.92 List.153 List.154 List.155;
    let List.564 : U8 = 1i64;
    let List.565 : U8 = GetTagId List.561;
    let List.566 : Int1 = lowlevel Eq List.564 List.565;
    if List.566 then
        let List.156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.561;
        ret List.156;
    else
        let List.157 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.561;
        ret List.157;

procedure List.29 (List.298, List.299):
    let List.537 : U64 = CallByName List.6 List.298;
    let List.300 : U64 = CallByName Num.77 List.537 List.299;
    let List.536 : List U8 = CallByName List.43 List.298 List.300;
    ret List.536;

procedure List.31 (#Attr.2, #Attr.3):
    let List.502 : List U8 = lowlevel ListDropAt #Attr.2 #Attr.3;
    ret List.502;

procedure List.32 (List.293):
    let List.503 : U64 = CallByName List.6 List.293;
    let List.504 : U64 = 1i64;
    let List.501 : U64 = CallByName Num.77 List.503 List.504;
    let List.500 : List U8 = CallByName List.31 List.293 List.501;
    ret List.500;

procedure List.38 (List.292):
    let List.509 : U64 = 0i64;
    let List.508 : List U8 = CallByName List.31 List.292 List.509;
    ret List.508;

procedure List.4 (List.107, List.108):
    let List.519 : U64 = 1i64;
    let List.518 : List U8 = CallByName List.70 List.107 List.519;
    let List.517 : List U8 = CallByName List.71 List.518 List.108;
    ret List.517;

procedure List.43 (List.296, List.297):
    let List.532 : U64 = CallByName List.6 List.296;
    let List.531 : U64 = CallByName Num.77 List.532 List.297;
    let List.522 : {U64, U64} = Struct {List.297, List.531};
    let List.521 : List U8 = CallByName List.49 List.296 List.522;
    ret List.521;

procedure List.49 (List.370, List.371):
    let List.559 : U64 = StructAtIndex 0 List.371;
    let List.560 : U64 = 0i64;
    let List.557 : Int1 = CallByName Bool.11 List.559 List.560;
    if List.557 then
        dec List.370;
        let List.558 : List U8 = Array [];
        ret List.558;
    else
        let List.555 : U64 = StructAtIndex 1 List.371;
        let List.556 : U64 = StructAtIndex 0 List.371;
        let List.554 : List U8 = CallByName List.72 List.370 List.555 List.556;
        ret List.554;

procedure List.6 (#Attr.2):
    let List.620 : U64 = lowlevel ListLen #Attr.2;
    ret List.620;

procedure List.66 (#Attr.2, #Attr.3):
    let List.543 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.543;

procedure List.70 (#Attr.2, #Attr.3):
    let List.516 : List U8 = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.516;

procedure List.71 (#Attr.2, #Attr.3):
    let List.514 : List U8 = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.514;

procedure List.72 (#Attr.2, #Attr.3, #Attr.4):
    let List.526 : List U8 = lowlevel ListSublist #Attr.2 #Attr.3 #Attr.4;
    ret List.526;

procedure List.8 (#Attr.2, #Attr.3):
    let List.511 : List U8 = lowlevel ListConcat #Attr.2 #Attr.3;
    ret List.511;

procedure List.80 (List.612, List.613, List.614, List.615, List.616):
    joinpoint List.570 List.433 List.434 List.435 List.436 List.437:
        let List.572 : Int1 = CallByName Num.22 List.436 List.437;
        if List.572 then
            let List.581 : U8 = CallByName List.66 List.433 List.436;
            let List.573 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName Json.57 List.434 List.581;
            let List.578 : U8 = 1i64;
            let List.579 : U8 = GetTagId List.573;
            let List.580 : Int1 = lowlevel Eq List.578 List.579;
            if List.580 then
                let List.438 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.573;
                let List.576 : U64 = 1i64;
                let List.575 : U64 = CallByName Num.19 List.436 List.576;
                jump List.570 List.433 List.438 List.435 List.575 List.437;
            else
                let List.439 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.573;
                let List.577 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) List.439;
                ret List.577;
        else
            let List.571 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) List.434;
            ret List.571;
    in
    jump List.570 List.612 List.613 List.614 List.615 List.616;

procedure List.92 (List.430, List.431, List.432):
    let List.568 : U64 = 0i64;
    let List.569 : U64 = CallByName List.6 List.430;
    let List.567 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.80 List.430 List.431 List.432 List.568 List.569;
    ret List.567;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.278 : U8 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.278;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.325 : U64 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.325;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.290 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.290;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.324 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.324;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.296 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.296;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.302 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.302;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.275 : U8 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.275;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.276 : U8 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.276;

procedure Num.77 (#Attr.2, #Attr.3):
    let Num.321 : U64 = lowlevel NumSubSaturated #Attr.2 #Attr.3;
    ret Num.321;

procedure Str.48 (#Attr.2, #Attr.3, #Attr.4):
    let Str.307 : {U64, Str, Int1, U8} = lowlevel StrFromUtf8Range #Attr.2 #Attr.3 #Attr.4;
    ret Str.307;

procedure Str.9 (Str.79):
    let Str.305 : U64 = 0i64;
    let Str.306 : U64 = CallByName List.6 Str.79;
    let Str.80 : {U64, Str, Int1, U8} = CallByName Str.48 Str.79 Str.305 Str.306;
    let Str.302 : Int1 = StructAtIndex 2 Str.80;
    if Str.302 then
        let Str.304 : Str = StructAtIndex 1 Str.80;
        inc Str.304;
        dec Str.80;
        let Str.303 : [C {U64, U8}, C Str] = TagId(1) Str.304;
        ret Str.303;
    else
        let Str.300 : U8 = StructAtIndex 3 Str.80;
        let Str.301 : U64 = StructAtIndex 0 Str.80;
        dec Str.80;
        let Str.299 : {U64, U8} = Struct {Str.301, Str.300};
        let Str.298 : [C {U64, U8}, C Str] = TagId(0) Str.299;
        ret Str.298;

procedure Test.3 ():
    let Test.0 : List U8 = Array [82i64, 111i64, 99i64];
    let Test.8 : {} = CallByName Json.2;
    inc Test.0;
    let Test.1 : [C [C List U8, C ], C Str] = CallByName Decode.27 Test.0 Test.8;
    let Test.7 : Str = "Roc";
    let Test.6 : [C [C List U8, C ], C Str] = TagId(1) Test.7;
    inc Test.1;
    let Test.5 : Int1 = CallByName Bool.11 Test.1 Test.6;
    expect Test.5;
    let Test.4 : {} = Struct {};
    ret Test.4;
