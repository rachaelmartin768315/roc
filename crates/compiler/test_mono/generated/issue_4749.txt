procedure Bool.1 ():
    let Bool.55 : Int1 = false;
    ret Bool.55;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.23;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.46 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.46;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.66 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.66;

procedure Bool.2 ():
    let Bool.54 : Int1 = true;
    ret Bool.54;

procedure Bool.3 (#Attr.2, #Attr.3):
    let Bool.37 : Int1 = lowlevel And #Attr.2 #Attr.3;
    ret Bool.37;

procedure Bool.4 (#Attr.2, #Attr.3):
    let Bool.57 : Int1 = lowlevel Or #Attr.2 #Attr.3;
    ret Bool.57;

procedure Decode.24 (Decode.101):
    ret Decode.101;

procedure Decode.25 (Decode.102, Decode.121, Decode.104):
    let Decode.134 : {List U8, [C {}, C Str]} = CallByName Json.467 Decode.102 Decode.104;
    ret Decode.134;

procedure Decode.26 (Decode.105, Decode.106):
    let Decode.133 : {} = CallByName Json.56;
    let Decode.132 : {List U8, [C {}, C Str]} = CallByName Decode.25 Decode.105 Decode.133 Decode.106;
    ret Decode.132;

procedure Decode.27 (Decode.107, Decode.108):
    let Decode.122 : {List U8, [C {}, C Str]} = CallByName Decode.26 Decode.107 Decode.108;
    let Decode.110 : List U8 = StructAtIndex 0 Decode.122;
    inc Decode.110;
    let Decode.109 : [C {}, C Str] = StructAtIndex 1 Decode.122;
    inc Decode.109;
    dec Decode.122;
    inc Decode.110;
    let Decode.125 : Int1 = CallByName List.1 Decode.110;
    if Decode.125 then
        dec Decode.110;
        let Decode.129 : U8 = 1i64;
        let Decode.130 : U8 = GetTagId Decode.109;
        let Decode.131 : Int1 = lowlevel Eq Decode.129 Decode.130;
        if Decode.131 then
            let Decode.111 : Str = UnionAtIndex (Id 1) (Index 0) Decode.109;
            inc Decode.111;
            dec Decode.109;
            let Decode.126 : [C [C List U8, C ], C Str] = TagId(1) Decode.111;
            ret Decode.126;
        else
            dec Decode.109;
            let Decode.128 : [C List U8, C ] = TagId(1) ;
            let Decode.127 : [C [C List U8, C ], C Str] = TagId(0) Decode.128;
            ret Decode.127;
    else
        dec Decode.109;
        let Decode.124 : [C List U8, C ] = TagId(0) Decode.110;
        let Decode.123 : [C [C List U8, C ], C Str] = TagId(0) Decode.124;
        ret Decode.123;

procedure Json.1 ():
    let Json.969 : [C , C [], C , C , C , C ] = TagId(2) ;
    ret Json.969;

procedure Json.467 (Json.468, Json.972):
    inc Json.468;
    let Json.1109 : {List U8, List U8} = CallByName Json.57 Json.468;
    let Json.471 : List U8 = StructAtIndex 0 Json.1109;
    inc Json.471;
    let Json.470 : List U8 = StructAtIndex 1 Json.1109;
    inc Json.470;
    dec Json.1109;
    inc Json.470;
    let Json.1105 : Int1 = CallByName List.1 Json.470;
    if Json.1105 then
        dec Json.471;
        dec Json.470;
        let Json.1108 : {} = Struct {};
        let Json.1107 : [C {}, C Str] = TagId(0) Json.1108;
        let Json.1106 : {List U8, [C {}, C Str]} = Struct {Json.468, Json.1107};
        ret Json.1106;
    else
        let Json.1104 : List U8 = Array [];
        let Json.984 : {List U8, List U8} = Struct {Json.470, Json.1104};
        let Json.983 : {List U8, List U8} = CallByName Json.66 Json.984;
        let Json.475 : List U8 = StructAtIndex 1 Json.983;
        inc Json.475;
        dec Json.983;
        let Json.982 : List U8 = CallByName List.38 Json.475;
        let Json.981 : List U8 = CallByName List.32 Json.982;
        let Json.476 : [C {U64, U8}, C Str] = CallByName Str.9 Json.981;
        let Json.978 : U8 = 1i64;
        let Json.979 : U8 = GetTagId Json.476;
        let Json.980 : Int1 = lowlevel Eq Json.978 Json.979;
        if Json.980 then
            dec Json.468;
            let Json.477 : Str = UnionAtIndex (Id 1) (Index 0) Json.476;
            inc Json.477;
            dec Json.476;
            let Json.974 : [C {}, C Str] = TagId(1) Json.477;
            let Json.973 : {List U8, [C {}, C Str]} = Struct {Json.471, Json.974};
            ret Json.973;
        else
            dec Json.471;
            dec Json.476;
            let Json.977 : {} = Struct {};
            let Json.976 : [C {}, C Str] = TagId(0) Json.977;
            let Json.975 : {List U8, [C {}, C Str]} = Struct {Json.468, Json.976};
            ret Json.975;

procedure Json.56 ():
    let Json.971 : {} = Struct {};
    let Json.970 : {} = CallByName Decode.24 Json.971;
    ret Json.970;

procedure Json.57 (Json.481):
    let Json.1121 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(4) ;
    let Json.1122 : {} = Struct {};
    inc Json.481;
    let Json.1110 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = CallByName List.26 Json.481 Json.1121 Json.1122;
    let Json.1118 : U8 = 2i64;
    let Json.1119 : U8 = GetTagId Json.1110;
    let Json.1120 : Int1 = lowlevel Eq Json.1118 Json.1119;
    if Json.1120 then
        let Json.483 : U64 = UnionAtIndex (Id 2) (Index 0) Json.1110;
        inc Json.481;
        let Json.1112 : List U8 = CallByName List.29 Json.481 Json.483;
        let Json.1115 : U64 = 0i64;
        let Json.1114 : {U64, U64} = Struct {Json.483, Json.1115};
        let Json.1113 : List U8 = CallByName List.49 Json.481 Json.1114;
        let Json.1111 : {List U8, List U8} = Struct {Json.1112, Json.1113};
        ret Json.1111;
    else
        let Json.1117 : List U8 = Array [];
        let Json.1116 : {List U8, List U8} = Struct {Json.481, Json.1117};
        ret Json.1116;

procedure Json.58 (Json.484, Json.485):
    let Json.1123 : {[C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], U8} = Struct {Json.484, Json.485};
    joinpoint Json.1166:
        let Json.1164 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(3) ;
        let Json.1163 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1164;
        ret Json.1163;
    in
    let Json.1167 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
    let Json.1225 : U8 = GetTagId Json.1167;
    switch Json.1225:
        case 4:
            let Json.486 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1169 Json.1168:
                if Json.1168 then
                    let Json.1126 : U64 = 1i64;
                    let Json.1125 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1126;
                    let Json.1124 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1125;
                    ret Json.1124;
                else
                    jump Json.1166;
            in
            let Json.1171 : U8 = 34i64;
            let Json.1170 : Int1 = CallByName Bool.11 Json.486 Json.1171;
            jump Json.1169 Json.1170;
    
        case 0:
            let Json.1182 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
            let Json.489 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1182;
            let Json.490 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1179 Json.1173:
                if Json.1173 then
                    let Json.1130 : U64 = 1i64;
                    let Json.1129 : U64 = CallByName Num.19 Json.489 Json.1130;
                    let Json.1128 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(2) Json.1129;
                    let Json.1127 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1128;
                    ret Json.1127;
                else
                    let Json.1178 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
                    let Json.493 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1178;
                    let Json.494 : U8 = StructAtIndex 1 Json.1123;
                    joinpoint Json.1175 Json.1174:
                        if Json.1174 then
                            let Json.1134 : U64 = 1i64;
                            let Json.1133 : U64 = CallByName Num.19 Json.493 Json.1134;
                            let Json.1132 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(1) Json.1133;
                            let Json.1131 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1132;
                            ret Json.1131;
                        else
                            let Json.1165 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
                            let Json.497 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1165;
                            let Json.1138 : U64 = 1i64;
                            let Json.1137 : U64 = CallByName Num.19 Json.497 Json.1138;
                            let Json.1136 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1137;
                            let Json.1135 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1136;
                            ret Json.1135;
                    in
                    let Json.1177 : U8 = 92i64;
                    let Json.1176 : Int1 = CallByName Bool.11 Json.494 Json.1177;
                    jump Json.1175 Json.1176;
            in
            let Json.1181 : U8 = 34i64;
            let Json.1180 : Int1 = CallByName Bool.11 Json.490 Json.1181;
            jump Json.1179 Json.1180;
    
        case 1:
            let Json.1191 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
            let Json.500 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1191;
            let Json.501 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1189 Json.1183:
                if Json.1183 then
                    let Json.1142 : U64 = 1i64;
                    let Json.1141 : U64 = CallByName Num.19 Json.500 Json.1142;
                    let Json.1140 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1141;
                    let Json.1139 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1140;
                    ret Json.1139;
                else
                    let Json.1188 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
                    let Json.504 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1188;
                    let Json.505 : U8 = StructAtIndex 1 Json.1123;
                    joinpoint Json.1185 Json.1184:
                        if Json.1184 then
                            let Json.1146 : U64 = 1i64;
                            let Json.1145 : U64 = CallByName Num.19 Json.504 Json.1146;
                            let Json.1144 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(5) Json.1145;
                            let Json.1143 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1144;
                            ret Json.1143;
                        else
                            jump Json.1166;
                    in
                    let Json.1187 : U8 = 117i64;
                    let Json.1186 : Int1 = CallByName Bool.11 Json.505 Json.1187;
                    jump Json.1185 Json.1186;
            in
            let Json.1190 : Int1 = CallByName Json.59 Json.501;
            jump Json.1189 Json.1190;
    
        case 5:
            let Json.1212 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
            let Json.508 : U64 = UnionAtIndex (Id 5) (Index 0) Json.1212;
            let Json.509 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1193 Json.1192:
                if Json.1192 then
                    let Json.1150 : U64 = 1i64;
                    let Json.1149 : U64 = CallByName Num.19 Json.508 Json.1150;
                    let Json.1148 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(6) Json.1149;
                    let Json.1147 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1148;
                    ret Json.1147;
                else
                    jump Json.1166;
            in
            let Json.1194 : Int1 = CallByName Json.61 Json.509;
            jump Json.1193 Json.1194;
    
        case 6:
            let Json.1216 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
            let Json.512 : U64 = UnionAtIndex (Id 6) (Index 0) Json.1216;
            let Json.513 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1214 Json.1213:
                if Json.1213 then
                    let Json.1154 : U64 = 1i64;
                    let Json.1153 : U64 = CallByName Num.19 Json.512 Json.1154;
                    let Json.1152 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(7) Json.1153;
                    let Json.1151 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1152;
                    ret Json.1151;
                else
                    jump Json.1166;
            in
            let Json.1215 : Int1 = CallByName Json.61 Json.513;
            jump Json.1214 Json.1215;
    
        case 7:
            let Json.1220 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
            let Json.516 : U64 = UnionAtIndex (Id 7) (Index 0) Json.1220;
            let Json.517 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1218 Json.1217:
                if Json.1217 then
                    let Json.1158 : U64 = 1i64;
                    let Json.1157 : U64 = CallByName Num.19 Json.516 Json.1158;
                    let Json.1156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(8) Json.1157;
                    let Json.1155 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1156;
                    ret Json.1155;
                else
                    jump Json.1166;
            in
            let Json.1219 : Int1 = CallByName Json.61 Json.517;
            jump Json.1218 Json.1219;
    
        case 8:
            let Json.1224 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1123;
            let Json.520 : U64 = UnionAtIndex (Id 8) (Index 0) Json.1224;
            let Json.521 : U8 = StructAtIndex 1 Json.1123;
            joinpoint Json.1222 Json.1221:
                if Json.1221 then
                    let Json.1162 : U64 = 1i64;
                    let Json.1161 : U64 = CallByName Num.19 Json.520 Json.1162;
                    let Json.1160 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1161;
                    let Json.1159 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1160;
                    ret Json.1159;
                else
                    jump Json.1166;
            in
            let Json.1223 : Int1 = CallByName Json.61 Json.521;
            jump Json.1222 Json.1223;
    
        default:
            jump Json.1166;
    

procedure Json.59 (Json.526):
    switch Json.526:
        case 34:
            let Json.1072 : Int1 = CallByName Bool.2;
            ret Json.1072;
    
        case 92:
            let Json.1073 : Int1 = CallByName Bool.2;
            ret Json.1073;
    
        case 47:
            let Json.1074 : Int1 = CallByName Bool.2;
            ret Json.1074;
    
        case 98:
            let Json.1075 : Int1 = CallByName Bool.2;
            ret Json.1075;
    
        case 102:
            let Json.1076 : Int1 = CallByName Bool.2;
            ret Json.1076;
    
        case 110:
            let Json.1077 : Int1 = CallByName Bool.2;
            ret Json.1077;
    
        case 114:
            let Json.1078 : Int1 = CallByName Bool.2;
            ret Json.1078;
    
        case 116:
            let Json.1079 : Int1 = CallByName Bool.2;
            ret Json.1079;
    
        default:
            let Json.1080 : Int1 = CallByName Bool.1;
            ret Json.1080;
    

procedure Json.60 (Json.527):
    switch Json.527:
        case 34:
            let Json.1050 : U8 = 34i64;
            ret Json.1050;
    
        case 92:
            let Json.1051 : U8 = 92i64;
            ret Json.1051;
    
        case 47:
            let Json.1052 : U8 = 47i64;
            ret Json.1052;
    
        case 98:
            let Json.1053 : U8 = 8i64;
            ret Json.1053;
    
        case 102:
            let Json.1054 : U8 = 12i64;
            ret Json.1054;
    
        case 110:
            let Json.1055 : U8 = 10i64;
            ret Json.1055;
    
        case 114:
            let Json.1056 : U8 = 13i64;
            ret Json.1056;
    
        case 116:
            let Json.1057 : U8 = 9i64;
            ret Json.1057;
    
        default:
            ret Json.527;
    

procedure Json.61 (Json.528):
    let Json.1211 : U8 = 48i64;
    let Json.1208 : Int1 = CallByName Num.25 Json.528 Json.1211;
    let Json.1210 : U8 = 57i64;
    let Json.1209 : Int1 = CallByName Num.23 Json.528 Json.1210;
    let Json.1196 : Int1 = CallByName Bool.3 Json.1208 Json.1209;
    let Json.1207 : U8 = 97i64;
    let Json.1204 : Int1 = CallByName Num.25 Json.528 Json.1207;
    let Json.1206 : U8 = 102i64;
    let Json.1205 : Int1 = CallByName Num.23 Json.528 Json.1206;
    let Json.1198 : Int1 = CallByName Bool.3 Json.1204 Json.1205;
    let Json.1203 : U8 = 65i64;
    let Json.1200 : Int1 = CallByName Num.25 Json.528 Json.1203;
    let Json.1202 : U8 = 70i64;
    let Json.1201 : Int1 = CallByName Num.23 Json.528 Json.1202;
    let Json.1199 : Int1 = CallByName Bool.3 Json.1200 Json.1201;
    let Json.1197 : Int1 = CallByName Bool.4 Json.1198 Json.1199;
    let Json.1195 : Int1 = CallByName Bool.4 Json.1196 Json.1197;
    ret Json.1195;

procedure Json.62 (Json.529):
    let Json.1029 : U8 = 48i64;
    let Json.1026 : Int1 = CallByName Num.25 Json.529 Json.1029;
    let Json.1028 : U8 = 57i64;
    let Json.1027 : Int1 = CallByName Num.23 Json.529 Json.1028;
    let Json.1023 : Int1 = CallByName Bool.3 Json.1026 Json.1027;
    if Json.1023 then
        let Json.1025 : U8 = 48i64;
        let Json.1024 : U8 = CallByName Num.20 Json.529 Json.1025;
        ret Json.1024;
    else
        let Json.1022 : U8 = 97i64;
        let Json.1019 : Int1 = CallByName Num.25 Json.529 Json.1022;
        let Json.1021 : U8 = 102i64;
        let Json.1020 : Int1 = CallByName Num.23 Json.529 Json.1021;
        let Json.1014 : Int1 = CallByName Bool.3 Json.1019 Json.1020;
        if Json.1014 then
            let Json.1018 : U8 = 97i64;
            let Json.1016 : U8 = CallByName Num.20 Json.529 Json.1018;
            let Json.1017 : U8 = 10i64;
            let Json.1015 : U8 = CallByName Num.19 Json.1016 Json.1017;
            ret Json.1015;
        else
            let Json.1013 : U8 = 65i64;
            let Json.1010 : Int1 = CallByName Num.25 Json.529 Json.1013;
            let Json.1012 : U8 = 70i64;
            let Json.1011 : Int1 = CallByName Num.23 Json.529 Json.1012;
            let Json.1005 : Int1 = CallByName Bool.3 Json.1010 Json.1011;
            if Json.1005 then
                let Json.1009 : U8 = 65i64;
                let Json.1007 : U8 = CallByName Num.20 Json.529 Json.1009;
                let Json.1008 : U8 = 10i64;
                let Json.1006 : U8 = CallByName Num.19 Json.1007 Json.1008;
                ret Json.1006;
            else
                let Json.1004 : Str = "got an invalid hex char";
                Crash Json.1004

procedure Json.63 (Json.530, Json.531):
    let Json.995 : U8 = 4i64;
    let Json.994 : U8 = CallByName Num.72 Json.530 Json.995;
    let Json.993 : U8 = CallByName Num.71 Json.994 Json.531;
    ret Json.993;

procedure Json.64 (Json.532, Json.533, Json.534, Json.535):
    let Json.536 : U8 = CallByName Json.62 Json.532;
    let Json.537 : U8 = CallByName Json.62 Json.533;
    let Json.538 : U8 = CallByName Json.62 Json.534;
    let Json.539 : U8 = CallByName Json.62 Json.535;
    let Json.1002 : U8 = 0i64;
    let Json.999 : Int1 = CallByName Bool.11 Json.536 Json.1002;
    let Json.1001 : U8 = 0i64;
    let Json.1000 : Int1 = CallByName Bool.11 Json.537 Json.1001;
    let Json.996 : Int1 = CallByName Bool.3 Json.999 Json.1000;
    if Json.996 then
        let Json.998 : U8 = CallByName Json.63 Json.538 Json.539;
        let Json.997 : List U8 = Array [Json.998];
        ret Json.997;
    else
        let Json.991 : U8 = CallByName Json.63 Json.536 Json.537;
        let Json.992 : U8 = CallByName Json.63 Json.538 Json.539;
        let Json.990 : List U8 = Array [Json.991, Json.992];
        ret Json.990;

procedure Json.65 ():
    let Json.1035 : U8 = 102i64;
    let Json.1036 : U8 = 102i64;
    let Json.1037 : U8 = 100i64;
    let Json.1038 : U8 = 100i64;
    let Json.1034 : List U8 = CallByName Json.64 Json.1035 Json.1036 Json.1037 Json.1038;
    ret Json.1034;

procedure Json.66 (Json.1228):
    joinpoint Json.985 Json.965:
        let Json.540 : List U8 = StructAtIndex 0 Json.965;
        inc Json.540;
        let Json.541 : List U8 = StructAtIndex 1 Json.965;
        inc Json.541;
        dec Json.965;
        let Json.1103 : U64 = 0i64;
        inc Json.540;
        let Json.542 : [C {}, C U8] = CallByName List.2 Json.540 Json.1103;
        let Json.1102 : U64 = 1i64;
        inc Json.540;
        let Json.543 : [C {}, C U8] = CallByName List.2 Json.540 Json.1102;
        let Json.1101 : U64 = 2i64;
        inc Json.540;
        let Json.544 : List U8 = CallByName List.29 Json.540 Json.1101;
        let Json.1100 : U64 = 6i64;
        inc Json.540;
        let Json.545 : List U8 = CallByName List.29 Json.540 Json.1100;
        let Json.986 : {[C {}, C U8], [C {}, C U8]} = Struct {Json.542, Json.543};
        joinpoint Json.1065:
            let Json.1064 : [C {}, C U8] = StructAtIndex 0 Json.986;
            let Json.556 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1064;
            let Json.1061 : List U8 = CallByName List.38 Json.540;
            let Json.1062 : List U8 = CallByName List.4 Json.541 Json.556;
            let Json.1060 : {List U8, List U8} = Struct {Json.1061, Json.1062};
            jump Json.985 Json.1060;
        in
        let Json.1096 : [C {}, C U8] = StructAtIndex 0 Json.986;
        let Json.1097 : U8 = 1i64;
        let Json.1098 : U8 = GetTagId Json.1096;
        let Json.1099 : Int1 = lowlevel Eq Json.1097 Json.1098;
        if Json.1099 then
            let Json.1092 : [C {}, C U8] = StructAtIndex 1 Json.986;
            let Json.1093 : U8 = 1i64;
            let Json.1094 : U8 = GetTagId Json.1092;
            let Json.1095 : Int1 = lowlevel Eq Json.1093 Json.1094;
            if Json.1095 then
                let Json.1091 : [C {}, C U8] = StructAtIndex 0 Json.986;
                let Json.547 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1091;
                let Json.1090 : [C {}, C U8] = StructAtIndex 1 Json.986;
                let Json.548 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1090;
                joinpoint Json.1084 Json.1066:
                    if Json.1066 then
                        dec Json.540;
                        let Json.1043 : U64 = lowlevel ListLen Json.544;
                        let Json.1044 : U64 = 4i64;
                        let Json.1045 : Int1 = lowlevel NumGte Json.1043 Json.1044;
                        if Json.1045 then
                            let Json.1042 : U64 = 0i64;
                            let Json.549 : U8 = lowlevel ListGetUnsafe Json.544 Json.1042;
                            let Json.1041 : U64 = 1i64;
                            let Json.550 : U8 = lowlevel ListGetUnsafe Json.544 Json.1041;
                            let Json.1040 : U64 = 2i64;
                            let Json.551 : U8 = lowlevel ListGetUnsafe Json.544 Json.1040;
                            let Json.1039 : U64 = 3i64;
                            let Json.552 : U8 = lowlevel ListGetUnsafe Json.544 Json.1039;
                            dec Json.544;
                            let Json.553 : List U8 = CallByName Json.64 Json.549 Json.550 Json.551 Json.552;
                            let Json.989 : List U8 = CallByName List.8 Json.541 Json.553;
                            let Json.988 : {List U8, List U8} = Struct {Json.545, Json.989};
                            jump Json.985 Json.988;
                        else
                            dec Json.545;
                            let Json.1033 : List U8 = CallByName Json.65;
                            let Json.1032 : List U8 = CallByName List.8 Json.541 Json.1033;
                            let Json.1031 : {List U8, List U8} = Struct {Json.544, Json.1032};
                            jump Json.985 Json.1031;
                    else
                        dec Json.545;
                        let Json.1083 : [C {}, C U8] = StructAtIndex 0 Json.986;
                        let Json.554 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1083;
                        let Json.1082 : [C {}, C U8] = StructAtIndex 1 Json.986;
                        let Json.555 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1082;
                        joinpoint Json.1068 Json.1067:
                            if Json.1067 then
                                dec Json.540;
                                let Json.1049 : U8 = CallByName Json.60 Json.555;
                                let Json.1048 : List U8 = CallByName List.4 Json.541 Json.1049;
                                let Json.1047 : {List U8, List U8} = Struct {Json.544, Json.1048};
                                jump Json.985 Json.1047;
                            else
                                dec Json.544;
                                jump Json.1065;
                        in
                        let Json.1081 : U8 = 92i64;
                        let Json.1070 : Int1 = CallByName Bool.11 Json.554 Json.1081;
                        let Json.1071 : Int1 = CallByName Json.59 Json.555;
                        let Json.1069 : Int1 = CallByName Bool.3 Json.1070 Json.1071;
                        jump Json.1068 Json.1069;
                in
                let Json.1089 : U8 = 92i64;
                let Json.1086 : Int1 = CallByName Bool.11 Json.547 Json.1089;
                let Json.1088 : U8 = 117i64;
                let Json.1087 : Int1 = CallByName Bool.11 Json.548 Json.1088;
                let Json.1085 : Int1 = CallByName Bool.3 Json.1086 Json.1087;
                jump Json.1084 Json.1085;
            else
                dec Json.544;
                dec Json.545;
                jump Json.1065;
        else
            dec Json.544;
            dec Json.545;
            let Json.1063 : {List U8, List U8} = Struct {Json.540, Json.541};
            ret Json.1063;
    in
    jump Json.985 Json.1228;

procedure List.1 (List.95):
    let List.552 : U64 = CallByName List.6 List.95;
    dec List.95;
    let List.553 : U64 = 0i64;
    let List.551 : Int1 = CallByName Bool.11 List.552 List.553;
    ret List.551;

procedure List.2 (List.96, List.97):
    let List.550 : U64 = CallByName List.6 List.96;
    let List.547 : Int1 = CallByName Num.22 List.97 List.550;
    if List.547 then
        let List.549 : U8 = CallByName List.66 List.96 List.97;
        dec List.96;
        let List.548 : [C {}, C U8] = TagId(1) List.549;
        ret List.548;
    else
        dec List.96;
        let List.546 : {} = Struct {};
        let List.545 : [C {}, C U8] = TagId(0) List.546;
        ret List.545;

procedure List.26 (List.153, List.154, List.155):
    let List.561 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.92 List.153 List.154 List.155;
    let List.564 : U8 = 1i64;
    let List.565 : U8 = GetTagId List.561;
    let List.566 : Int1 = lowlevel Eq List.564 List.565;
    if List.566 then
        let List.156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.561;
        ret List.156;
    else
        let List.157 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.561;
        ret List.157;

procedure List.29 (List.298, List.299):
    let List.537 : U64 = CallByName List.6 List.298;
    let List.300 : U64 = CallByName Num.77 List.537 List.299;
    let List.536 : List U8 = CallByName List.43 List.298 List.300;
    ret List.536;

procedure List.31 (#Attr.2, #Attr.3):
    let List.502 : List U8 = lowlevel ListDropAt #Attr.2 #Attr.3;
    ret List.502;

procedure List.32 (List.293):
    let List.503 : U64 = CallByName List.6 List.293;
    let List.504 : U64 = 1i64;
    let List.501 : U64 = CallByName Num.77 List.503 List.504;
    let List.500 : List U8 = CallByName List.31 List.293 List.501;
    ret List.500;

procedure List.38 (List.292):
    let List.509 : U64 = 0i64;
    let List.508 : List U8 = CallByName List.31 List.292 List.509;
    ret List.508;

procedure List.4 (List.107, List.108):
    let List.519 : U64 = 1i64;
    let List.518 : List U8 = CallByName List.70 List.107 List.519;
    let List.517 : List U8 = CallByName List.71 List.518 List.108;
    ret List.517;

procedure List.43 (List.296, List.297):
    let List.532 : U64 = CallByName List.6 List.296;
    let List.531 : U64 = CallByName Num.77 List.532 List.297;
    let List.522 : {U64, U64} = Struct {List.297, List.531};
    let List.521 : List U8 = CallByName List.49 List.296 List.522;
    ret List.521;

procedure List.49 (List.370, List.371):
    let List.559 : U64 = StructAtIndex 0 List.371;
    let List.560 : U64 = 0i64;
    let List.557 : Int1 = CallByName Bool.11 List.559 List.560;
    if List.557 then
        dec List.370;
        let List.558 : List U8 = Array [];
        ret List.558;
    else
        let List.555 : U64 = StructAtIndex 1 List.371;
        let List.556 : U64 = StructAtIndex 0 List.371;
        let List.554 : List U8 = CallByName List.72 List.370 List.555 List.556;
        ret List.554;

procedure List.6 (#Attr.2):
    let List.620 : U64 = lowlevel ListLen #Attr.2;
    ret List.620;

procedure List.66 (#Attr.2, #Attr.3):
    let List.543 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.543;

procedure List.70 (#Attr.2, #Attr.3):
    let List.516 : List U8 = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.516;

procedure List.71 (#Attr.2, #Attr.3):
    let List.514 : List U8 = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.514;

procedure List.72 (#Attr.2, #Attr.3, #Attr.4):
    let List.526 : List U8 = lowlevel ListSublist #Attr.2 #Attr.3 #Attr.4;
    ret List.526;

procedure List.8 (#Attr.2, #Attr.3):
    let List.511 : List U8 = lowlevel ListConcat #Attr.2 #Attr.3;
    ret List.511;

procedure List.80 (List.612, List.613, List.614, List.615, List.616):
    joinpoint List.570 List.433 List.434 List.435 List.436 List.437:
        let List.572 : Int1 = CallByName Num.22 List.436 List.437;
        if List.572 then
            let List.581 : U8 = CallByName List.66 List.433 List.436;
            let List.573 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName Json.58 List.434 List.581;
            let List.578 : U8 = 1i64;
            let List.579 : U8 = GetTagId List.573;
            let List.580 : Int1 = lowlevel Eq List.578 List.579;
            if List.580 then
                let List.438 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.573;
                let List.576 : U64 = 1i64;
                let List.575 : U64 = CallByName Num.19 List.436 List.576;
                jump List.570 List.433 List.438 List.435 List.575 List.437;
            else
                dec List.433;
                let List.439 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.573;
                let List.577 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) List.439;
                ret List.577;
        else
            dec List.433;
            let List.571 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) List.434;
            ret List.571;
    in
    jump List.570 List.612 List.613 List.614 List.615 List.616;

procedure List.92 (List.430, List.431, List.432):
    let List.568 : U64 = 0i64;
    let List.569 : U64 = CallByName List.6 List.430;
    let List.567 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.80 List.430 List.431 List.432 List.568 List.569;
    ret List.567;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.278 : U8 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.278;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.325 : U64 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.325;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.290 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.290;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.324 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.324;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.296 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.296;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.302 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.302;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.275 : U8 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.275;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.276 : U8 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.276;

procedure Num.77 (#Attr.2, #Attr.3):
    let Num.321 : U64 = lowlevel NumSubSaturated #Attr.2 #Attr.3;
    ret Num.321;

procedure Str.48 (#Attr.2, #Attr.3, #Attr.4):
    let Str.307 : {U64, Str, Int1, U8} = lowlevel StrFromUtf8Range #Attr.2 #Attr.3 #Attr.4;
    ret Str.307;

procedure Str.9 (Str.79):
    let Str.305 : U64 = 0i64;
    let Str.306 : U64 = CallByName List.6 Str.79;
    let Str.80 : {U64, Str, Int1, U8} = CallByName Str.48 Str.79 Str.305 Str.306;
    let Str.302 : Int1 = StructAtIndex 2 Str.80;
    if Str.302 then
        let Str.304 : Str = StructAtIndex 1 Str.80;
        inc Str.304;
        dec Str.80;
        let Str.303 : [C {U64, U8}, C Str] = TagId(1) Str.304;
        ret Str.303;
    else
        let Str.300 : U8 = StructAtIndex 3 Str.80;
        let Str.301 : U64 = StructAtIndex 0 Str.80;
        dec Str.80;
        let Str.299 : {U64, U8} = Struct {Str.301, Str.300};
        let Str.298 : [C {U64, U8}, C Str] = TagId(0) Str.299;
        ret Str.298;

procedure Test.3 ():
    let Test.0 : List U8 = Array [82i64, 111i64, 99i64];
    let Test.8 : [C , C [], C , C , C , C ] = CallByName Json.1;
    inc Test.0;
    let Test.1 : [C [C List U8, C ], C Str] = CallByName Decode.27 Test.0 Test.8;
    let Test.7 : Str = "Roc";
    let Test.6 : [C [C List U8, C ], C Str] = TagId(1) Test.7;
    let Test.5 : Int1 = CallByName Bool.11 Test.1 Test.6;
    dec Test.6;
    expect Test.5;
    let Test.4 : {} = Struct {};
    ret Test.4;
