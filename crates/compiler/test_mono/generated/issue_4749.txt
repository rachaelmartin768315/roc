procedure Bool.1 ():
    let Bool.51 : Int1 = false;
    ret Bool.51;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.23;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.42 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.42;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.54 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.54;

procedure Bool.2 ():
    let Bool.50 : Int1 = true;
    ret Bool.50;

procedure Bool.3 (#Attr.2, #Attr.3):
    let Bool.33 : Int1 = lowlevel And #Attr.2 #Attr.3;
    ret Bool.33;

procedure Bool.4 (#Attr.2, #Attr.3):
    let Bool.53 : Int1 = lowlevel Or #Attr.2 #Attr.3;
    ret Bool.53;

procedure Decode.24 (Decode.101):
    ret Decode.101;

procedure Decode.25 (Decode.102, Decode.121, Decode.104):
    let Decode.134 : {List U8, [C {}, C Str]} = CallByName TotallyNotJson.491 Decode.102 Decode.104;
    ret Decode.134;

procedure Decode.26 (Decode.105, Decode.106):
    let Decode.133 : {} = CallByName TotallyNotJson.59;
    let Decode.132 : {List U8, [C {}, C Str]} = CallByName Decode.25 Decode.105 Decode.133 Decode.106;
    ret Decode.132;

procedure Decode.27 (Decode.107, Decode.108):
    let Decode.122 : {List U8, [C {}, C Str]} = CallByName Decode.26 Decode.107 Decode.108;
    let Decode.110 : List U8 = StructAtIndex 0 Decode.122;
    inc Decode.110;
    let Decode.109 : [C {}, C Str] = StructAtIndex 1 Decode.122;
    let Decode.125 : Int1 = CallByName List.1 Decode.110;
    if Decode.125 then
        dec Decode.110;
        let Decode.129 : U8 = 1i64;
        let Decode.130 : U8 = GetTagId Decode.109;
        let Decode.131 : Int1 = lowlevel Eq Decode.129 Decode.130;
        if Decode.131 then
            let Decode.111 : Str = UnionAtIndex (Id 1) (Index 0) Decode.109;
            let Decode.126 : [C [C List U8, C ], C Str] = TagId(1) Decode.111;
            ret Decode.126;
        else
            dec Decode.109;
            let Decode.128 : [C List U8, C ] = TagId(1) ;
            let Decode.127 : [C [C List U8, C ], C Str] = TagId(0) Decode.128;
            ret Decode.127;
    else
        dec Decode.109;
        let Decode.124 : [C List U8, C ] = TagId(0) Decode.110;
        let Decode.123 : [C [C List U8, C ], C Str] = TagId(0) Decode.124;
        ret Decode.123;

procedure List.1 (List.106):
    let List.626 : U64 = CallByName List.6 List.106;
    dec List.106;
    let List.627 : U64 = 0i64;
    let List.625 : Int1 = CallByName Bool.11 List.626 List.627;
    ret List.625;

procedure List.103 (List.487, List.488, List.489):
    let List.635 : U64 = 0i64;
    let List.636 : U64 = CallByName List.6 List.487;
    let List.634 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.80 List.487 List.488 List.489 List.635 List.636;
    ret List.634;

procedure List.2 (List.107, List.108):
    let List.617 : U64 = CallByName List.6 List.107;
    let List.614 : Int1 = CallByName Num.22 List.108 List.617;
    if List.614 then
        let List.616 : U8 = CallByName List.66 List.107 List.108;
        dec List.107;
        let List.615 : [C {}, C U8] = TagId(1) List.616;
        ret List.615;
    else
        dec List.107;
        let List.613 : {} = Struct {};
        let List.612 : [C {}, C U8] = TagId(0) List.613;
        ret List.612;

procedure List.26 (List.200, List.201, List.202):
    let List.628 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.103 List.200 List.201 List.202;
    let List.631 : U8 = 1i64;
    let List.632 : U8 = GetTagId List.628;
    let List.633 : Int1 = lowlevel Eq List.631 List.632;
    if List.633 then
        let List.203 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.628;
        ret List.203;
    else
        let List.204 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.628;
        ret List.204;

procedure List.38 (List.343, List.344):
    let List.594 : U64 = CallByName List.6 List.343;
    let List.345 : U64 = CallByName Num.77 List.594 List.344;
    let List.593 : List U8 = CallByName List.43 List.343 List.345;
    ret List.593;

procedure List.4 (List.123, List.124):
    let List.604 : U64 = 1i64;
    let List.603 : List U8 = CallByName List.70 List.123 List.604;
    let List.602 : List U8 = CallByName List.71 List.603 List.124;
    ret List.602;

procedure List.43 (List.341, List.342):
    let List.584 : U64 = CallByName List.6 List.341;
    let List.583 : U64 = CallByName Num.77 List.584 List.342;
    let List.578 : {U64, U64} = Struct {List.342, List.583};
    let List.577 : List U8 = CallByName List.49 List.341 List.578;
    ret List.577;

procedure List.49 (List.419, List.420):
    let List.622 : U64 = StructAtIndex 1 List.420;
    let List.623 : U64 = StructAtIndex 0 List.420;
    let List.621 : List U8 = CallByName List.72 List.419 List.622 List.623;
    ret List.621;

procedure List.6 (#Attr.2):
    let List.624 : U64 = lowlevel ListLenU64 #Attr.2;
    ret List.624;

procedure List.66 (#Attr.2, #Attr.3):
    let List.610 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.610;

procedure List.70 (#Attr.2, #Attr.3):
    let List.601 : List U8 = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.601;

procedure List.71 (#Attr.2, #Attr.3):
    let List.599 : List U8 = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.599;

procedure List.72 (#Attr.2, #Attr.3, #Attr.4):
    let List.582 : List U8 = lowlevel ListSublist #Attr.2 #Attr.3 #Attr.4;
    ret List.582;

procedure List.8 (#Attr.2, #Attr.3):
    let List.596 : List U8 = lowlevel ListConcat #Attr.2 #Attr.3;
    ret List.596;

procedure List.80 (#Derived_gen.1, #Derived_gen.2, #Derived_gen.3, #Derived_gen.4, #Derived_gen.5):
    joinpoint List.637 List.490 List.491 List.492 List.493 List.494:
        let List.639 : Int1 = CallByName Num.22 List.493 List.494;
        if List.639 then
            let List.648 : U8 = CallByName List.66 List.490 List.493;
            let List.640 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName TotallyNotJson.61 List.491 List.648;
            let List.645 : U8 = 1i64;
            let List.646 : U8 = GetTagId List.640;
            let List.647 : Int1 = lowlevel Eq List.645 List.646;
            if List.647 then
                let List.495 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.640;
                let List.643 : U64 = 1i64;
                let List.642 : U64 = CallByName Num.51 List.493 List.643;
                jump List.637 List.490 List.495 List.492 List.642 List.494;
            else
                dec List.490;
                let List.496 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.640;
                let List.644 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) List.496;
                ret List.644;
        else
            dec List.490;
            let List.638 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) List.491;
            ret List.638;
    in
    jump List.637 #Derived_gen.1 #Derived_gen.2 #Derived_gen.3 #Derived_gen.4 #Derived_gen.5;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.282 : U8 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.282;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.291 : U64 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.291;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.294 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.294;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.316 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.316;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.300 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.300;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.306 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.306;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.317 : U64 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.317;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.279 : U8 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.279;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.280 : U8 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.280;

procedure Num.77 (#Attr.2, #Attr.3):
    let Num.313 : U64 = lowlevel NumSubSaturated #Attr.2 #Attr.3;
    ret Num.313;

procedure Str.43 (#Attr.2):
    let Str.239 : {U64, Str, Int1, U8} = lowlevel StrFromUtf8 #Attr.2;
    ret Str.239;

procedure Str.9 (Str.67):
    let Str.68 : {U64, Str, Int1, U8} = CallByName Str.43 Str.67;
    let Str.236 : Int1 = StructAtIndex 2 Str.68;
    if Str.236 then
        let Str.238 : Str = StructAtIndex 1 Str.68;
        let Str.237 : [C {U64, U8}, C Str] = TagId(1) Str.238;
        ret Str.237;
    else
        let Str.234 : U8 = StructAtIndex 3 Str.68;
        let Str.235 : U64 = StructAtIndex 0 Str.68;
        let #Derived_gen.7 : Str = StructAtIndex 1 Str.68;
        dec #Derived_gen.7;
        let Str.233 : {U64, U8} = Struct {Str.235, Str.234};
        let Str.232 : [C {U64, U8}, C Str] = TagId(0) Str.233;
        ret Str.232;

procedure Test.3 ():
    let Test.0 : List U8 = Array [82i64, 111i64, 99i64];
    let Test.8 : {} = CallByName TotallyNotJson.8;
    inc Test.0;
    let Test.1 : [C [C List U8, C ], C Str] = CallByName Decode.27 Test.0 Test.8;
    let Test.7 : Str = "Roc";
    let Test.6 : [C [C List U8, C ], C Str] = TagId(1) Test.7;
    let Test.5 : Int1 = CallByName Bool.11 Test.1 Test.6;
    dec Test.7;
    expect Test.5;
    dec Test.1;
    dec Test.0;
    let Test.4 : {} = Struct {};
    ret Test.4;

procedure TotallyNotJson.491 (TotallyNotJson.492, TotallyNotJson.976):
    joinpoint TotallyNotJson.1260:
        inc TotallyNotJson.492;
        let TotallyNotJson.1129 : {List U8, List U8} = CallByName TotallyNotJson.60 TotallyNotJson.492;
        let TotallyNotJson.496 : List U8 = StructAtIndex 0 TotallyNotJson.1129;
        let TotallyNotJson.495 : List U8 = StructAtIndex 1 TotallyNotJson.1129;
        inc TotallyNotJson.495;
        let TotallyNotJson.1125 : Int1 = CallByName List.1 TotallyNotJson.495;
        if TotallyNotJson.1125 then
            dec TotallyNotJson.495;
            dec TotallyNotJson.496;
            let TotallyNotJson.1128 : {} = Struct {};
            let TotallyNotJson.1127 : [C {}, C Str] = TagId(0) TotallyNotJson.1128;
            let TotallyNotJson.1126 : {List U8, [C {}, C Str]} = Struct {TotallyNotJson.492, TotallyNotJson.1127};
            ret TotallyNotJson.1126;
        else
            let TotallyNotJson.1123 : U64 = CallByName List.6 TotallyNotJson.495;
            let TotallyNotJson.1124 : U64 = 2i64;
            let TotallyNotJson.1121 : U64 = CallByName Num.77 TotallyNotJson.1123 TotallyNotJson.1124;
            let TotallyNotJson.1122 : U64 = 1i64;
            let TotallyNotJson.1120 : {U64, U64} = Struct {TotallyNotJson.1121, TotallyNotJson.1122};
            let TotallyNotJson.995 : List U8 = CallByName List.49 TotallyNotJson.495 TotallyNotJson.1120;
            let TotallyNotJson.996 : {} = Struct {};
            let TotallyNotJson.991 : {List U8, List U8} = CallByName TotallyNotJson.500 TotallyNotJson.995;
            let TotallyNotJson.992 : {} = Struct {};
            let TotallyNotJson.990 : List U8 = CallByName TotallyNotJson.502 TotallyNotJson.991;
            let TotallyNotJson.499 : [C {U64, U8}, C Str] = CallByName Str.9 TotallyNotJson.990;
            let TotallyNotJson.987 : U8 = 1i64;
            let TotallyNotJson.988 : U8 = GetTagId TotallyNotJson.499;
            let TotallyNotJson.989 : Int1 = lowlevel Eq TotallyNotJson.987 TotallyNotJson.988;
            if TotallyNotJson.989 then
                dec TotallyNotJson.492;
                let TotallyNotJson.503 : Str = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.499;
                let TotallyNotJson.983 : [C {}, C Str] = TagId(1) TotallyNotJson.503;
                let TotallyNotJson.982 : {List U8, [C {}, C Str]} = Struct {TotallyNotJson.496, TotallyNotJson.983};
                ret TotallyNotJson.982;
            else
                dec TotallyNotJson.499;
                dec TotallyNotJson.496;
                let TotallyNotJson.986 : {} = Struct {};
                let TotallyNotJson.985 : [C {}, C Str] = TagId(0) TotallyNotJson.986;
                let TotallyNotJson.984 : {List U8, [C {}, C Str]} = Struct {TotallyNotJson.492, TotallyNotJson.985};
                ret TotallyNotJson.984;
    in
    let TotallyNotJson.1258 : U64 = lowlevel ListLenUsize TotallyNotJson.492;
    let TotallyNotJson.1259 : U64 = 4i64;
    let TotallyNotJson.1265 : Int1 = lowlevel NumGte TotallyNotJson.1258 TotallyNotJson.1259;
    if TotallyNotJson.1265 then
        let TotallyNotJson.1255 : U64 = 3i64;
        let TotallyNotJson.1256 : U8 = lowlevel ListGetUnsafe TotallyNotJson.492 TotallyNotJson.1255;
        let TotallyNotJson.1257 : U8 = 108i64;
        let TotallyNotJson.1264 : Int1 = lowlevel Eq TotallyNotJson.1257 TotallyNotJson.1256;
        if TotallyNotJson.1264 then
            let TotallyNotJson.1252 : U64 = 2i64;
            let TotallyNotJson.1253 : U8 = lowlevel ListGetUnsafe TotallyNotJson.492 TotallyNotJson.1252;
            let TotallyNotJson.1254 : U8 = 108i64;
            let TotallyNotJson.1263 : Int1 = lowlevel Eq TotallyNotJson.1254 TotallyNotJson.1253;
            if TotallyNotJson.1263 then
                let TotallyNotJson.1249 : U64 = 1i64;
                let TotallyNotJson.1250 : U8 = lowlevel ListGetUnsafe TotallyNotJson.492 TotallyNotJson.1249;
                let TotallyNotJson.1251 : U8 = 117i64;
                let TotallyNotJson.1262 : Int1 = lowlevel Eq TotallyNotJson.1251 TotallyNotJson.1250;
                if TotallyNotJson.1262 then
                    let TotallyNotJson.1246 : U64 = 0i64;
                    let TotallyNotJson.1247 : U8 = lowlevel ListGetUnsafe TotallyNotJson.492 TotallyNotJson.1246;
                    let TotallyNotJson.1248 : U8 = 110i64;
                    let TotallyNotJson.1261 : Int1 = lowlevel Eq TotallyNotJson.1248 TotallyNotJson.1247;
                    if TotallyNotJson.1261 then
                        let TotallyNotJson.981 : U64 = 4i64;
                        let TotallyNotJson.978 : List U8 = CallByName List.38 TotallyNotJson.492 TotallyNotJson.981;
                        let TotallyNotJson.980 : Str = "null";
                        let TotallyNotJson.979 : [C {}, C Str] = TagId(1) TotallyNotJson.980;
                        let TotallyNotJson.977 : {List U8, [C {}, C Str]} = Struct {TotallyNotJson.978, TotallyNotJson.979};
                        ret TotallyNotJson.977;
                    else
                        jump TotallyNotJson.1260;
                else
                    jump TotallyNotJson.1260;
            else
                jump TotallyNotJson.1260;
        else
            jump TotallyNotJson.1260;
    else
        jump TotallyNotJson.1260;

procedure TotallyNotJson.500 (TotallyNotJson.501):
    let TotallyNotJson.1119 : List U8 = Array [];
    let TotallyNotJson.998 : {List U8, List U8} = Struct {TotallyNotJson.501, TotallyNotJson.1119};
    let TotallyNotJson.997 : {List U8, List U8} = CallByName TotallyNotJson.69 TotallyNotJson.998;
    ret TotallyNotJson.997;

procedure TotallyNotJson.502 (TotallyNotJson.993):
    let TotallyNotJson.994 : List U8 = StructAtIndex 1 TotallyNotJson.993;
    let #Derived_gen.6 : List U8 = StructAtIndex 0 TotallyNotJson.993;
    dec #Derived_gen.6;
    ret TotallyNotJson.994;

procedure TotallyNotJson.59 ():
    let TotallyNotJson.975 : {} = Struct {};
    let TotallyNotJson.974 : {} = CallByName Decode.24 TotallyNotJson.975;
    ret TotallyNotJson.974;

procedure TotallyNotJson.60 (TotallyNotJson.507):
    let TotallyNotJson.1141 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(4) ;
    let TotallyNotJson.1142 : {} = Struct {};
    inc TotallyNotJson.507;
    let TotallyNotJson.1130 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = CallByName List.26 TotallyNotJson.507 TotallyNotJson.1141 TotallyNotJson.1142;
    let TotallyNotJson.1138 : U8 = 2i64;
    let TotallyNotJson.1139 : U8 = GetTagId TotallyNotJson.1130;
    let TotallyNotJson.1140 : Int1 = lowlevel Eq TotallyNotJson.1138 TotallyNotJson.1139;
    if TotallyNotJson.1140 then
        inc TotallyNotJson.507;
        let TotallyNotJson.509 : U64 = UnionAtIndex (Id 2) (Index 0) TotallyNotJson.1130;
        let TotallyNotJson.1132 : List U8 = CallByName List.38 TotallyNotJson.507 TotallyNotJson.509;
        let TotallyNotJson.1135 : U64 = 0i64;
        let TotallyNotJson.1134 : {U64, U64} = Struct {TotallyNotJson.509, TotallyNotJson.1135};
        let TotallyNotJson.1133 : List U8 = CallByName List.49 TotallyNotJson.507 TotallyNotJson.1134;
        let TotallyNotJson.1131 : {List U8, List U8} = Struct {TotallyNotJson.1132, TotallyNotJson.1133};
        ret TotallyNotJson.1131;
    else
        let TotallyNotJson.1137 : List U8 = Array [];
        let TotallyNotJson.1136 : {List U8, List U8} = Struct {TotallyNotJson.507, TotallyNotJson.1137};
        ret TotallyNotJson.1136;

procedure TotallyNotJson.61 (TotallyNotJson.510, TotallyNotJson.511):
    let TotallyNotJson.1143 : {[C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], U8} = Struct {TotallyNotJson.510, TotallyNotJson.511};
    joinpoint TotallyNotJson.1186:
        let TotallyNotJson.1184 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(3) ;
        let TotallyNotJson.1183 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) TotallyNotJson.1184;
        ret TotallyNotJson.1183;
    in
    let TotallyNotJson.1187 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
    let TotallyNotJson.1245 : U8 = GetTagId TotallyNotJson.1187;
    switch TotallyNotJson.1245:
        case 4:
            let TotallyNotJson.512 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1189 TotallyNotJson.1188:
                if TotallyNotJson.1188 then
                    let TotallyNotJson.1146 : U64 = 1i64;
                    let TotallyNotJson.1145 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) TotallyNotJson.1146;
                    let TotallyNotJson.1144 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1145;
                    ret TotallyNotJson.1144;
                else
                    jump TotallyNotJson.1186;
            in
            let TotallyNotJson.1191 : U8 = 34i64;
            let TotallyNotJson.1190 : Int1 = CallByName Bool.11 TotallyNotJson.512 TotallyNotJson.1191;
            jump TotallyNotJson.1189 TotallyNotJson.1190;
    
        case 0:
            let TotallyNotJson.1202 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
            let TotallyNotJson.515 : U64 = UnionAtIndex (Id 0) (Index 0) TotallyNotJson.1202;
            let TotallyNotJson.516 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1199 TotallyNotJson.1193:
                if TotallyNotJson.1193 then
                    let TotallyNotJson.1150 : U64 = 1i64;
                    let TotallyNotJson.1149 : U64 = CallByName Num.19 TotallyNotJson.515 TotallyNotJson.1150;
                    let TotallyNotJson.1148 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(2) TotallyNotJson.1149;
                    let TotallyNotJson.1147 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) TotallyNotJson.1148;
                    ret TotallyNotJson.1147;
                else
                    let TotallyNotJson.1198 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
                    let TotallyNotJson.519 : U64 = UnionAtIndex (Id 0) (Index 0) TotallyNotJson.1198;
                    let TotallyNotJson.520 : U8 = StructAtIndex 1 TotallyNotJson.1143;
                    joinpoint TotallyNotJson.1195 TotallyNotJson.1194:
                        if TotallyNotJson.1194 then
                            let TotallyNotJson.1154 : U64 = 1i64;
                            let TotallyNotJson.1153 : U64 = CallByName Num.19 TotallyNotJson.519 TotallyNotJson.1154;
                            let TotallyNotJson.1152 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(1) TotallyNotJson.1153;
                            let TotallyNotJson.1151 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1152;
                            ret TotallyNotJson.1151;
                        else
                            let TotallyNotJson.1185 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
                            let TotallyNotJson.523 : U64 = UnionAtIndex (Id 0) (Index 0) TotallyNotJson.1185;
                            let TotallyNotJson.1158 : U64 = 1i64;
                            let TotallyNotJson.1157 : U64 = CallByName Num.19 TotallyNotJson.523 TotallyNotJson.1158;
                            let TotallyNotJson.1156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) TotallyNotJson.1157;
                            let TotallyNotJson.1155 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1156;
                            ret TotallyNotJson.1155;
                    in
                    let TotallyNotJson.1197 : U8 = 92i64;
                    let TotallyNotJson.1196 : Int1 = CallByName Bool.11 TotallyNotJson.520 TotallyNotJson.1197;
                    jump TotallyNotJson.1195 TotallyNotJson.1196;
            in
            let TotallyNotJson.1201 : U8 = 34i64;
            let TotallyNotJson.1200 : Int1 = CallByName Bool.11 TotallyNotJson.516 TotallyNotJson.1201;
            jump TotallyNotJson.1199 TotallyNotJson.1200;
    
        case 1:
            let TotallyNotJson.1211 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
            let TotallyNotJson.526 : U64 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1211;
            let TotallyNotJson.527 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1209 TotallyNotJson.1203:
                if TotallyNotJson.1203 then
                    let TotallyNotJson.1162 : U64 = 1i64;
                    let TotallyNotJson.1161 : U64 = CallByName Num.19 TotallyNotJson.526 TotallyNotJson.1162;
                    let TotallyNotJson.1160 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) TotallyNotJson.1161;
                    let TotallyNotJson.1159 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1160;
                    ret TotallyNotJson.1159;
                else
                    let TotallyNotJson.1208 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
                    let TotallyNotJson.530 : U64 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1208;
                    let TotallyNotJson.531 : U8 = StructAtIndex 1 TotallyNotJson.1143;
                    joinpoint TotallyNotJson.1205 TotallyNotJson.1204:
                        if TotallyNotJson.1204 then
                            let TotallyNotJson.1166 : U64 = 1i64;
                            let TotallyNotJson.1165 : U64 = CallByName Num.19 TotallyNotJson.530 TotallyNotJson.1166;
                            let TotallyNotJson.1164 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(5) TotallyNotJson.1165;
                            let TotallyNotJson.1163 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1164;
                            ret TotallyNotJson.1163;
                        else
                            jump TotallyNotJson.1186;
                    in
                    let TotallyNotJson.1207 : U8 = 117i64;
                    let TotallyNotJson.1206 : Int1 = CallByName Bool.11 TotallyNotJson.531 TotallyNotJson.1207;
                    jump TotallyNotJson.1205 TotallyNotJson.1206;
            in
            let TotallyNotJson.1210 : Int1 = CallByName TotallyNotJson.62 TotallyNotJson.527;
            jump TotallyNotJson.1209 TotallyNotJson.1210;
    
        case 5:
            let TotallyNotJson.1232 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
            let TotallyNotJson.534 : U64 = UnionAtIndex (Id 5) (Index 0) TotallyNotJson.1232;
            let TotallyNotJson.535 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1213 TotallyNotJson.1212:
                if TotallyNotJson.1212 then
                    let TotallyNotJson.1170 : U64 = 1i64;
                    let TotallyNotJson.1169 : U64 = CallByName Num.19 TotallyNotJson.534 TotallyNotJson.1170;
                    let TotallyNotJson.1168 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(6) TotallyNotJson.1169;
                    let TotallyNotJson.1167 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1168;
                    ret TotallyNotJson.1167;
                else
                    jump TotallyNotJson.1186;
            in
            let TotallyNotJson.1214 : Int1 = CallByName TotallyNotJson.64 TotallyNotJson.535;
            jump TotallyNotJson.1213 TotallyNotJson.1214;
    
        case 6:
            let TotallyNotJson.1236 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
            let TotallyNotJson.538 : U64 = UnionAtIndex (Id 6) (Index 0) TotallyNotJson.1236;
            let TotallyNotJson.539 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1234 TotallyNotJson.1233:
                if TotallyNotJson.1233 then
                    let TotallyNotJson.1174 : U64 = 1i64;
                    let TotallyNotJson.1173 : U64 = CallByName Num.19 TotallyNotJson.538 TotallyNotJson.1174;
                    let TotallyNotJson.1172 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(7) TotallyNotJson.1173;
                    let TotallyNotJson.1171 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1172;
                    ret TotallyNotJson.1171;
                else
                    jump TotallyNotJson.1186;
            in
            let TotallyNotJson.1235 : Int1 = CallByName TotallyNotJson.64 TotallyNotJson.539;
            jump TotallyNotJson.1234 TotallyNotJson.1235;
    
        case 7:
            let TotallyNotJson.1240 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
            let TotallyNotJson.542 : U64 = UnionAtIndex (Id 7) (Index 0) TotallyNotJson.1240;
            let TotallyNotJson.543 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1238 TotallyNotJson.1237:
                if TotallyNotJson.1237 then
                    let TotallyNotJson.1178 : U64 = 1i64;
                    let TotallyNotJson.1177 : U64 = CallByName Num.19 TotallyNotJson.542 TotallyNotJson.1178;
                    let TotallyNotJson.1176 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(8) TotallyNotJson.1177;
                    let TotallyNotJson.1175 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1176;
                    ret TotallyNotJson.1175;
                else
                    jump TotallyNotJson.1186;
            in
            let TotallyNotJson.1239 : Int1 = CallByName TotallyNotJson.64 TotallyNotJson.543;
            jump TotallyNotJson.1238 TotallyNotJson.1239;
    
        case 8:
            let TotallyNotJson.1244 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 TotallyNotJson.1143;
            let TotallyNotJson.546 : U64 = UnionAtIndex (Id 8) (Index 0) TotallyNotJson.1244;
            let TotallyNotJson.547 : U8 = StructAtIndex 1 TotallyNotJson.1143;
            joinpoint TotallyNotJson.1242 TotallyNotJson.1241:
                if TotallyNotJson.1241 then
                    let TotallyNotJson.1182 : U64 = 1i64;
                    let TotallyNotJson.1181 : U64 = CallByName Num.19 TotallyNotJson.546 TotallyNotJson.1182;
                    let TotallyNotJson.1180 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) TotallyNotJson.1181;
                    let TotallyNotJson.1179 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) TotallyNotJson.1180;
                    ret TotallyNotJson.1179;
                else
                    jump TotallyNotJson.1186;
            in
            let TotallyNotJson.1243 : Int1 = CallByName TotallyNotJson.64 TotallyNotJson.547;
            jump TotallyNotJson.1242 TotallyNotJson.1243;
    
        default:
            jump TotallyNotJson.1186;
    

procedure TotallyNotJson.62 (TotallyNotJson.552):
    switch TotallyNotJson.552:
        case 34:
            let TotallyNotJson.1087 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1087;
    
        case 92:
            let TotallyNotJson.1088 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1088;
    
        case 47:
            let TotallyNotJson.1089 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1089;
    
        case 98:
            let TotallyNotJson.1090 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1090;
    
        case 102:
            let TotallyNotJson.1091 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1091;
    
        case 110:
            let TotallyNotJson.1092 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1092;
    
        case 114:
            let TotallyNotJson.1093 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1093;
    
        case 116:
            let TotallyNotJson.1094 : Int1 = CallByName Bool.2;
            ret TotallyNotJson.1094;
    
        default:
            let TotallyNotJson.1095 : Int1 = CallByName Bool.1;
            ret TotallyNotJson.1095;
    

procedure TotallyNotJson.63 (TotallyNotJson.553):
    switch TotallyNotJson.553:
        case 34:
            let TotallyNotJson.1064 : U8 = 34i64;
            ret TotallyNotJson.1064;
    
        case 92:
            let TotallyNotJson.1065 : U8 = 92i64;
            ret TotallyNotJson.1065;
    
        case 47:
            let TotallyNotJson.1066 : U8 = 47i64;
            ret TotallyNotJson.1066;
    
        case 98:
            let TotallyNotJson.1067 : U8 = 8i64;
            ret TotallyNotJson.1067;
    
        case 102:
            let TotallyNotJson.1068 : U8 = 12i64;
            ret TotallyNotJson.1068;
    
        case 110:
            let TotallyNotJson.1069 : U8 = 10i64;
            ret TotallyNotJson.1069;
    
        case 114:
            let TotallyNotJson.1070 : U8 = 13i64;
            ret TotallyNotJson.1070;
    
        case 116:
            let TotallyNotJson.1071 : U8 = 9i64;
            ret TotallyNotJson.1071;
    
        default:
            ret TotallyNotJson.553;
    

procedure TotallyNotJson.64 (TotallyNotJson.554):
    let TotallyNotJson.1231 : U8 = 48i64;
    let TotallyNotJson.1228 : Int1 = CallByName Num.25 TotallyNotJson.554 TotallyNotJson.1231;
    let TotallyNotJson.1230 : U8 = 57i64;
    let TotallyNotJson.1229 : Int1 = CallByName Num.23 TotallyNotJson.554 TotallyNotJson.1230;
    let TotallyNotJson.1216 : Int1 = CallByName Bool.3 TotallyNotJson.1228 TotallyNotJson.1229;
    let TotallyNotJson.1227 : U8 = 97i64;
    let TotallyNotJson.1224 : Int1 = CallByName Num.25 TotallyNotJson.554 TotallyNotJson.1227;
    let TotallyNotJson.1226 : U8 = 102i64;
    let TotallyNotJson.1225 : Int1 = CallByName Num.23 TotallyNotJson.554 TotallyNotJson.1226;
    let TotallyNotJson.1218 : Int1 = CallByName Bool.3 TotallyNotJson.1224 TotallyNotJson.1225;
    let TotallyNotJson.1223 : U8 = 65i64;
    let TotallyNotJson.1220 : Int1 = CallByName Num.25 TotallyNotJson.554 TotallyNotJson.1223;
    let TotallyNotJson.1222 : U8 = 70i64;
    let TotallyNotJson.1221 : Int1 = CallByName Num.23 TotallyNotJson.554 TotallyNotJson.1222;
    let TotallyNotJson.1219 : Int1 = CallByName Bool.3 TotallyNotJson.1220 TotallyNotJson.1221;
    let TotallyNotJson.1217 : Int1 = CallByName Bool.4 TotallyNotJson.1218 TotallyNotJson.1219;
    let TotallyNotJson.1215 : Int1 = CallByName Bool.4 TotallyNotJson.1216 TotallyNotJson.1217;
    ret TotallyNotJson.1215;

procedure TotallyNotJson.65 (TotallyNotJson.555):
    let TotallyNotJson.1043 : U8 = 48i64;
    let TotallyNotJson.1040 : Int1 = CallByName Num.25 TotallyNotJson.555 TotallyNotJson.1043;
    let TotallyNotJson.1042 : U8 = 57i64;
    let TotallyNotJson.1041 : Int1 = CallByName Num.23 TotallyNotJson.555 TotallyNotJson.1042;
    let TotallyNotJson.1037 : Int1 = CallByName Bool.3 TotallyNotJson.1040 TotallyNotJson.1041;
    if TotallyNotJson.1037 then
        let TotallyNotJson.1039 : U8 = 48i64;
        let TotallyNotJson.1038 : U8 = CallByName Num.20 TotallyNotJson.555 TotallyNotJson.1039;
        ret TotallyNotJson.1038;
    else
        let TotallyNotJson.1036 : U8 = 97i64;
        let TotallyNotJson.1033 : Int1 = CallByName Num.25 TotallyNotJson.555 TotallyNotJson.1036;
        let TotallyNotJson.1035 : U8 = 102i64;
        let TotallyNotJson.1034 : Int1 = CallByName Num.23 TotallyNotJson.555 TotallyNotJson.1035;
        let TotallyNotJson.1028 : Int1 = CallByName Bool.3 TotallyNotJson.1033 TotallyNotJson.1034;
        if TotallyNotJson.1028 then
            let TotallyNotJson.1032 : U8 = 97i64;
            let TotallyNotJson.1030 : U8 = CallByName Num.20 TotallyNotJson.555 TotallyNotJson.1032;
            let TotallyNotJson.1031 : U8 = 10i64;
            let TotallyNotJson.1029 : U8 = CallByName Num.19 TotallyNotJson.1030 TotallyNotJson.1031;
            ret TotallyNotJson.1029;
        else
            let TotallyNotJson.1027 : U8 = 65i64;
            let TotallyNotJson.1024 : Int1 = CallByName Num.25 TotallyNotJson.555 TotallyNotJson.1027;
            let TotallyNotJson.1026 : U8 = 70i64;
            let TotallyNotJson.1025 : Int1 = CallByName Num.23 TotallyNotJson.555 TotallyNotJson.1026;
            let TotallyNotJson.1019 : Int1 = CallByName Bool.3 TotallyNotJson.1024 TotallyNotJson.1025;
            if TotallyNotJson.1019 then
                let TotallyNotJson.1023 : U8 = 65i64;
                let TotallyNotJson.1021 : U8 = CallByName Num.20 TotallyNotJson.555 TotallyNotJson.1023;
                let TotallyNotJson.1022 : U8 = 10i64;
                let TotallyNotJson.1020 : U8 = CallByName Num.19 TotallyNotJson.1021 TotallyNotJson.1022;
                ret TotallyNotJson.1020;
            else
                let TotallyNotJson.1018 : Str = "got an invalid hex char";
                Crash TotallyNotJson.1018

procedure TotallyNotJson.66 (TotallyNotJson.556, TotallyNotJson.557):
    let TotallyNotJson.1009 : U8 = 4i64;
    let TotallyNotJson.1008 : U8 = CallByName Num.72 TotallyNotJson.556 TotallyNotJson.1009;
    let TotallyNotJson.1007 : U8 = CallByName Num.71 TotallyNotJson.1008 TotallyNotJson.557;
    ret TotallyNotJson.1007;

procedure TotallyNotJson.67 (TotallyNotJson.558, TotallyNotJson.559, TotallyNotJson.560, TotallyNotJson.561):
    let TotallyNotJson.562 : U8 = CallByName TotallyNotJson.65 TotallyNotJson.558;
    let TotallyNotJson.563 : U8 = CallByName TotallyNotJson.65 TotallyNotJson.559;
    let TotallyNotJson.564 : U8 = CallByName TotallyNotJson.65 TotallyNotJson.560;
    let TotallyNotJson.565 : U8 = CallByName TotallyNotJson.65 TotallyNotJson.561;
    let TotallyNotJson.1016 : U8 = 0i64;
    let TotallyNotJson.1013 : Int1 = CallByName Bool.11 TotallyNotJson.562 TotallyNotJson.1016;
    let TotallyNotJson.1015 : U8 = 0i64;
    let TotallyNotJson.1014 : Int1 = CallByName Bool.11 TotallyNotJson.563 TotallyNotJson.1015;
    let TotallyNotJson.1010 : Int1 = CallByName Bool.3 TotallyNotJson.1013 TotallyNotJson.1014;
    if TotallyNotJson.1010 then
        let TotallyNotJson.1012 : U8 = CallByName TotallyNotJson.66 TotallyNotJson.564 TotallyNotJson.565;
        let TotallyNotJson.1011 : List U8 = Array [TotallyNotJson.1012];
        ret TotallyNotJson.1011;
    else
        let TotallyNotJson.1005 : U8 = CallByName TotallyNotJson.66 TotallyNotJson.562 TotallyNotJson.563;
        let TotallyNotJson.1006 : U8 = CallByName TotallyNotJson.66 TotallyNotJson.564 TotallyNotJson.565;
        let TotallyNotJson.1004 : List U8 = Array [TotallyNotJson.1005, TotallyNotJson.1006];
        ret TotallyNotJson.1004;

procedure TotallyNotJson.68 ():
    let TotallyNotJson.1049 : U8 = 102i64;
    let TotallyNotJson.1050 : U8 = 102i64;
    let TotallyNotJson.1051 : U8 = 100i64;
    let TotallyNotJson.1052 : U8 = 100i64;
    let TotallyNotJson.1048 : List U8 = CallByName TotallyNotJson.67 TotallyNotJson.1049 TotallyNotJson.1050 TotallyNotJson.1051 TotallyNotJson.1052;
    ret TotallyNotJson.1048;

procedure TotallyNotJson.69 (#Derived_gen.0):
    joinpoint TotallyNotJson.999 TotallyNotJson.970:
        let TotallyNotJson.566 : List U8 = StructAtIndex 0 TotallyNotJson.970;
        inc 4 TotallyNotJson.566;
        let TotallyNotJson.567 : List U8 = StructAtIndex 1 TotallyNotJson.970;
        let TotallyNotJson.1118 : U64 = 0i64;
        let TotallyNotJson.568 : [C {}, C U8] = CallByName List.2 TotallyNotJson.566 TotallyNotJson.1118;
        let TotallyNotJson.1117 : U64 = 1i64;
        let TotallyNotJson.569 : [C {}, C U8] = CallByName List.2 TotallyNotJson.566 TotallyNotJson.1117;
        let TotallyNotJson.1116 : U64 = 2i64;
        let TotallyNotJson.570 : List U8 = CallByName List.38 TotallyNotJson.566 TotallyNotJson.1116;
        let TotallyNotJson.1115 : U64 = 6i64;
        let TotallyNotJson.571 : List U8 = CallByName List.38 TotallyNotJson.566 TotallyNotJson.1115;
        let TotallyNotJson.1000 : {[C {}, C U8], [C {}, C U8]} = Struct {TotallyNotJson.568, TotallyNotJson.569};
        joinpoint TotallyNotJson.1080:
            let TotallyNotJson.1079 : [C {}, C U8] = StructAtIndex 0 TotallyNotJson.1000;
            let TotallyNotJson.582 : U8 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1079;
            let TotallyNotJson.1077 : U64 = 1i64;
            let TotallyNotJson.1075 : List U8 = CallByName List.38 TotallyNotJson.566 TotallyNotJson.1077;
            let TotallyNotJson.1076 : List U8 = CallByName List.4 TotallyNotJson.567 TotallyNotJson.582;
            let TotallyNotJson.1074 : {List U8, List U8} = Struct {TotallyNotJson.1075, TotallyNotJson.1076};
            jump TotallyNotJson.999 TotallyNotJson.1074;
        in
        let TotallyNotJson.1111 : [C {}, C U8] = StructAtIndex 0 TotallyNotJson.1000;
        let TotallyNotJson.1112 : U8 = 1i64;
        let TotallyNotJson.1113 : U8 = GetTagId TotallyNotJson.1111;
        let TotallyNotJson.1114 : Int1 = lowlevel Eq TotallyNotJson.1112 TotallyNotJson.1113;
        if TotallyNotJson.1114 then
            let TotallyNotJson.1107 : [C {}, C U8] = StructAtIndex 1 TotallyNotJson.1000;
            let TotallyNotJson.1108 : U8 = 1i64;
            let TotallyNotJson.1109 : U8 = GetTagId TotallyNotJson.1107;
            let TotallyNotJson.1110 : Int1 = lowlevel Eq TotallyNotJson.1108 TotallyNotJson.1109;
            if TotallyNotJson.1110 then
                let TotallyNotJson.1106 : [C {}, C U8] = StructAtIndex 0 TotallyNotJson.1000;
                let TotallyNotJson.573 : U8 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1106;
                let TotallyNotJson.1105 : [C {}, C U8] = StructAtIndex 1 TotallyNotJson.1000;
                let TotallyNotJson.574 : U8 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1105;
                joinpoint TotallyNotJson.1099 TotallyNotJson.1081:
                    if TotallyNotJson.1081 then
                        dec TotallyNotJson.566;
                        let TotallyNotJson.1057 : U64 = lowlevel ListLenUsize TotallyNotJson.570;
                        let TotallyNotJson.1058 : U64 = 4i64;
                        let TotallyNotJson.1059 : Int1 = lowlevel NumGte TotallyNotJson.1057 TotallyNotJson.1058;
                        if TotallyNotJson.1059 then
                            let TotallyNotJson.1056 : U64 = 0i64;
                            let TotallyNotJson.575 : U8 = lowlevel ListGetUnsafe TotallyNotJson.570 TotallyNotJson.1056;
                            let TotallyNotJson.1055 : U64 = 1i64;
                            let TotallyNotJson.576 : U8 = lowlevel ListGetUnsafe TotallyNotJson.570 TotallyNotJson.1055;
                            let TotallyNotJson.1054 : U64 = 2i64;
                            let TotallyNotJson.577 : U8 = lowlevel ListGetUnsafe TotallyNotJson.570 TotallyNotJson.1054;
                            let TotallyNotJson.1053 : U64 = 3i64;
                            let TotallyNotJson.578 : U8 = lowlevel ListGetUnsafe TotallyNotJson.570 TotallyNotJson.1053;
                            dec TotallyNotJson.570;
                            let TotallyNotJson.579 : List U8 = CallByName TotallyNotJson.67 TotallyNotJson.575 TotallyNotJson.576 TotallyNotJson.577 TotallyNotJson.578;
                            let TotallyNotJson.1003 : List U8 = CallByName List.8 TotallyNotJson.567 TotallyNotJson.579;
                            let TotallyNotJson.1002 : {List U8, List U8} = Struct {TotallyNotJson.571, TotallyNotJson.1003};
                            jump TotallyNotJson.999 TotallyNotJson.1002;
                        else
                            dec TotallyNotJson.571;
                            let TotallyNotJson.1047 : List U8 = CallByName TotallyNotJson.68;
                            let TotallyNotJson.1046 : List U8 = CallByName List.8 TotallyNotJson.567 TotallyNotJson.1047;
                            let TotallyNotJson.1045 : {List U8, List U8} = Struct {TotallyNotJson.570, TotallyNotJson.1046};
                            jump TotallyNotJson.999 TotallyNotJson.1045;
                    else
                        dec TotallyNotJson.571;
                        let TotallyNotJson.1098 : [C {}, C U8] = StructAtIndex 0 TotallyNotJson.1000;
                        let TotallyNotJson.580 : U8 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1098;
                        let TotallyNotJson.1097 : [C {}, C U8] = StructAtIndex 1 TotallyNotJson.1000;
                        let TotallyNotJson.581 : U8 = UnionAtIndex (Id 1) (Index 0) TotallyNotJson.1097;
                        joinpoint TotallyNotJson.1083 TotallyNotJson.1082:
                            if TotallyNotJson.1082 then
                                dec TotallyNotJson.566;
                                let TotallyNotJson.1063 : U8 = CallByName TotallyNotJson.63 TotallyNotJson.581;
                                let TotallyNotJson.1062 : List U8 = CallByName List.4 TotallyNotJson.567 TotallyNotJson.1063;
                                let TotallyNotJson.1061 : {List U8, List U8} = Struct {TotallyNotJson.570, TotallyNotJson.1062};
                                jump TotallyNotJson.999 TotallyNotJson.1061;
                            else
                                dec TotallyNotJson.570;
                                jump TotallyNotJson.1080;
                        in
                        let TotallyNotJson.1096 : U8 = 92i64;
                        let TotallyNotJson.1085 : Int1 = CallByName Bool.11 TotallyNotJson.580 TotallyNotJson.1096;
                        let TotallyNotJson.1086 : Int1 = CallByName TotallyNotJson.62 TotallyNotJson.581;
                        let TotallyNotJson.1084 : Int1 = CallByName Bool.3 TotallyNotJson.1085 TotallyNotJson.1086;
                        jump TotallyNotJson.1083 TotallyNotJson.1084;
                in
                let TotallyNotJson.1104 : U8 = 92i64;
                let TotallyNotJson.1101 : Int1 = CallByName Bool.11 TotallyNotJson.573 TotallyNotJson.1104;
                let TotallyNotJson.1103 : U8 = 117i64;
                let TotallyNotJson.1102 : Int1 = CallByName Bool.11 TotallyNotJson.574 TotallyNotJson.1103;
                let TotallyNotJson.1100 : Int1 = CallByName Bool.3 TotallyNotJson.1101 TotallyNotJson.1102;
                jump TotallyNotJson.1099 TotallyNotJson.1100;
            else
                dec TotallyNotJson.571;
                dec TotallyNotJson.570;
                jump TotallyNotJson.1080;
        else
            dec TotallyNotJson.571;
            dec TotallyNotJson.570;
            let TotallyNotJson.1078 : {List U8, List U8} = Struct {TotallyNotJson.566, TotallyNotJson.567};
            ret TotallyNotJson.1078;
    in
    jump TotallyNotJson.999 #Derived_gen.0;

procedure TotallyNotJson.8 ():
    let TotallyNotJson.973 : {} = Struct {};
    ret TotallyNotJson.973;
