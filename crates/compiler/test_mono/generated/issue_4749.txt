procedure Bool.1 ():
    let Bool.55 : Int1 = false;
    ret Bool.55;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    dec #Attr.3;
    dec #Attr.2;
    ret Bool.23;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.46 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.46;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.66 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.66;

procedure Bool.2 ():
    let Bool.54 : Int1 = true;
    ret Bool.54;

procedure Bool.3 (#Attr.2, #Attr.3):
    let Bool.37 : Int1 = lowlevel And #Attr.2 #Attr.3;
    ret Bool.37;

procedure Bool.4 (#Attr.2, #Attr.3):
    let Bool.57 : Int1 = lowlevel Or #Attr.2 #Attr.3;
    ret Bool.57;

procedure Decode.24 (Decode.101):
    ret Decode.101;

procedure Decode.25 (Decode.102, Decode.121, Decode.104):
    let Decode.134 : {List U8, [C {}, C Str]} = CallByName Json.448 Decode.102 Decode.104;
    ret Decode.134;

procedure Decode.26 (Decode.105, Decode.106):
    let Decode.133 : {} = CallByName Json.55;
    let Decode.132 : {List U8, [C {}, C Str]} = CallByName Decode.25 Decode.105 Decode.133 Decode.106;
    ret Decode.132;

procedure Decode.27 (Decode.107, Decode.108):
    let Decode.122 : {List U8, [C {}, C Str]} = CallByName Decode.26 Decode.107 Decode.108;
    let Decode.110 : List U8 = StructAtIndex 0 Decode.122;
    inc Decode.110;
    let Decode.109 : [C {}, C Str] = StructAtIndex 1 Decode.122;
    inc Decode.109;
    dec Decode.122;
    let Decode.125 : Int1 = CallByName List.1 Decode.110;
    if Decode.125 then
        dec Decode.110;
        let Decode.129 : U8 = 1i64;
        let Decode.130 : U8 = GetTagId Decode.109;
        let Decode.131 : Int1 = lowlevel Eq Decode.129 Decode.130;
        if Decode.131 then
            let Decode.111 : Str = UnionAtIndex (Id 1) (Index 0) Decode.109;
            inc Decode.111;
            dec Decode.109;
            let Decode.126 : [C [C List U8, C ], C Str] = TagId(1) Decode.111;
            ret Decode.126;
        else
            dec Decode.109;
            let Decode.128 : [C List U8, C ] = TagId(1) ;
            let Decode.127 : [C [C List U8, C ], C Str] = TagId(0) Decode.128;
            ret Decode.127;
    else
        dec Decode.109;
        let Decode.124 : [C List U8, C ] = TagId(0) Decode.110;
        let Decode.123 : [C [C List U8, C ], C Str] = TagId(0) Decode.124;
        ret Decode.123;

procedure Json.2 ():
    let Json.878 : {} = Struct {};
    ret Json.878;

procedure Json.448 (Json.449, Json.881):
    inc Json.449;
    let Json.1018 : {List U8, List U8} = CallByName Json.56 Json.449;
    let Json.452 : List U8 = StructAtIndex 0 Json.1018;
    inc Json.452;
    let Json.451 : List U8 = StructAtIndex 1 Json.1018;
    inc Json.451;
    dec Json.1018;
    let Json.1014 : Int1 = CallByName List.1 Json.451;
    if Json.1014 then
        dec Json.452;
        dec Json.451;
        let Json.1017 : {} = Struct {};
        let Json.1016 : [C {}, C Str] = TagId(0) Json.1017;
        let Json.1015 : {List U8, [C {}, C Str]} = Struct {Json.449, Json.1016};
        ret Json.1015;
    else
        let Json.1013 : List U8 = Array [];
        let Json.893 : {List U8, List U8} = Struct {Json.451, Json.1013};
        let Json.892 : {List U8, List U8} = CallByName Json.65 Json.893;
        let Json.456 : List U8 = StructAtIndex 1 Json.892;
        inc Json.456;
        dec Json.892;
        let Json.891 : List U8 = CallByName List.38 Json.456;
        let Json.890 : List U8 = CallByName List.32 Json.891;
        let Json.457 : [C {U64, U8}, C Str] = CallByName Str.9 Json.890;
        let Json.887 : U8 = 1i64;
        let Json.888 : U8 = GetTagId Json.457;
        let Json.889 : Int1 = lowlevel Eq Json.887 Json.888;
        if Json.889 then
            dec Json.449;
            let Json.458 : Str = UnionAtIndex (Id 1) (Index 0) Json.457;
            inc Json.458;
            dec Json.457;
            let Json.883 : [C {}, C Str] = TagId(1) Json.458;
            let Json.882 : {List U8, [C {}, C Str]} = Struct {Json.452, Json.883};
            ret Json.882;
        else
            dec Json.457;
            dec Json.452;
            let Json.886 : {} = Struct {};
            let Json.885 : [C {}, C Str] = TagId(0) Json.886;
            let Json.884 : {List U8, [C {}, C Str]} = Struct {Json.449, Json.885};
            ret Json.884;

procedure Json.55 ():
    let Json.880 : {} = Struct {};
    let Json.879 : {} = CallByName Decode.24 Json.880;
    ret Json.879;

procedure Json.56 (Json.462):
    let Json.1030 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(4) ;
    let Json.1031 : {} = Struct {};
    let Json.1019 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = CallByName List.26 Json.462 Json.1030 Json.1031;
    let Json.1027 : U8 = 2i64;
    let Json.1028 : U8 = GetTagId Json.1019;
    let Json.1029 : Int1 = lowlevel Eq Json.1027 Json.1028;
    if Json.1029 then
        let Json.464 : U64 = UnionAtIndex (Id 2) (Index 0) Json.1019;
        inc Json.462;
        let Json.1021 : List U8 = CallByName List.29 Json.462 Json.464;
        let Json.1024 : U64 = 0i64;
        let Json.1023 : {U64, U64} = Struct {Json.464, Json.1024};
        let Json.1022 : List U8 = CallByName List.49 Json.462 Json.1023;
        let Json.1020 : {List U8, List U8} = Struct {Json.1021, Json.1022};
        ret Json.1020;
    else
        let Json.1026 : List U8 = Array [];
        let Json.1025 : {List U8, List U8} = Struct {Json.462, Json.1026};
        ret Json.1025;

procedure Json.57 (Json.465, Json.466):
    let Json.1032 : {[C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], U8} = Struct {Json.465, Json.466};
    joinpoint Json.1075:
        let Json.1073 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(3) ;
        let Json.1072 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1073;
        ret Json.1072;
    in
    let Json.1076 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
    let Json.1134 : U8 = GetTagId Json.1076;
    switch Json.1134:
        case 4:
            let Json.467 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1078 Json.1077:
                if Json.1077 then
                    let Json.1035 : U64 = 1i64;
                    let Json.1034 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1035;
                    let Json.1033 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1034;
                    ret Json.1033;
                else
                    jump Json.1075;
            in
            let Json.1080 : U8 = 34i64;
            let Json.1079 : Int1 = CallByName Bool.11 Json.467 Json.1080;
            jump Json.1078 Json.1079;
    
        case 0:
            let Json.1091 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
            let Json.470 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1091;
            let Json.471 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1088 Json.1082:
                if Json.1082 then
                    let Json.1039 : U64 = 1i64;
                    let Json.1038 : U64 = CallByName Num.19 Json.470 Json.1039;
                    let Json.1037 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(2) Json.1038;
                    let Json.1036 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) Json.1037;
                    ret Json.1036;
                else
                    let Json.1087 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
                    let Json.474 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1087;
                    let Json.475 : U8 = StructAtIndex 1 Json.1032;
                    joinpoint Json.1084 Json.1083:
                        if Json.1083 then
                            let Json.1043 : U64 = 1i64;
                            let Json.1042 : U64 = CallByName Num.19 Json.474 Json.1043;
                            let Json.1041 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(1) Json.1042;
                            let Json.1040 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1041;
                            ret Json.1040;
                        else
                            let Json.1074 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
                            let Json.478 : U64 = UnionAtIndex (Id 0) (Index 0) Json.1074;
                            let Json.1047 : U64 = 1i64;
                            let Json.1046 : U64 = CallByName Num.19 Json.478 Json.1047;
                            let Json.1045 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1046;
                            let Json.1044 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1045;
                            ret Json.1044;
                    in
                    let Json.1086 : U8 = 92i64;
                    let Json.1085 : Int1 = CallByName Bool.11 Json.475 Json.1086;
                    jump Json.1084 Json.1085;
            in
            let Json.1090 : U8 = 34i64;
            let Json.1089 : Int1 = CallByName Bool.11 Json.471 Json.1090;
            jump Json.1088 Json.1089;
    
        case 1:
            let Json.1100 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
            let Json.481 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1100;
            let Json.482 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1098 Json.1092:
                if Json.1092 then
                    let Json.1051 : U64 = 1i64;
                    let Json.1050 : U64 = CallByName Num.19 Json.481 Json.1051;
                    let Json.1049 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1050;
                    let Json.1048 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1049;
                    ret Json.1048;
                else
                    let Json.1097 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
                    let Json.485 : U64 = UnionAtIndex (Id 1) (Index 0) Json.1097;
                    let Json.486 : U8 = StructAtIndex 1 Json.1032;
                    joinpoint Json.1094 Json.1093:
                        if Json.1093 then
                            let Json.1055 : U64 = 1i64;
                            let Json.1054 : U64 = CallByName Num.19 Json.485 Json.1055;
                            let Json.1053 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(5) Json.1054;
                            let Json.1052 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1053;
                            ret Json.1052;
                        else
                            jump Json.1075;
                    in
                    let Json.1096 : U8 = 117i64;
                    let Json.1095 : Int1 = CallByName Bool.11 Json.486 Json.1096;
                    jump Json.1094 Json.1095;
            in
            let Json.1099 : Int1 = CallByName Json.58 Json.482;
            jump Json.1098 Json.1099;
    
        case 5:
            let Json.1121 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
            let Json.489 : U64 = UnionAtIndex (Id 5) (Index 0) Json.1121;
            let Json.490 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1102 Json.1101:
                if Json.1101 then
                    let Json.1059 : U64 = 1i64;
                    let Json.1058 : U64 = CallByName Num.19 Json.489 Json.1059;
                    let Json.1057 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(6) Json.1058;
                    let Json.1056 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1057;
                    ret Json.1056;
                else
                    jump Json.1075;
            in
            let Json.1103 : Int1 = CallByName Json.60 Json.490;
            jump Json.1102 Json.1103;
    
        case 6:
            let Json.1125 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
            let Json.493 : U64 = UnionAtIndex (Id 6) (Index 0) Json.1125;
            let Json.494 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1123 Json.1122:
                if Json.1122 then
                    let Json.1063 : U64 = 1i64;
                    let Json.1062 : U64 = CallByName Num.19 Json.493 Json.1063;
                    let Json.1061 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(7) Json.1062;
                    let Json.1060 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1061;
                    ret Json.1060;
                else
                    jump Json.1075;
            in
            let Json.1124 : Int1 = CallByName Json.60 Json.494;
            jump Json.1123 Json.1124;
    
        case 7:
            let Json.1129 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
            let Json.497 : U64 = UnionAtIndex (Id 7) (Index 0) Json.1129;
            let Json.498 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1127 Json.1126:
                if Json.1126 then
                    let Json.1067 : U64 = 1i64;
                    let Json.1066 : U64 = CallByName Num.19 Json.497 Json.1067;
                    let Json.1065 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(8) Json.1066;
                    let Json.1064 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1065;
                    ret Json.1064;
                else
                    jump Json.1075;
            in
            let Json.1128 : Int1 = CallByName Json.60 Json.498;
            jump Json.1127 Json.1128;
    
        case 8:
            let Json.1133 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = StructAtIndex 0 Json.1032;
            let Json.501 : U64 = UnionAtIndex (Id 8) (Index 0) Json.1133;
            let Json.502 : U8 = StructAtIndex 1 Json.1032;
            joinpoint Json.1131 Json.1130:
                if Json.1130 then
                    let Json.1071 : U64 = 1i64;
                    let Json.1070 : U64 = CallByName Num.19 Json.501 Json.1071;
                    let Json.1069 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = TagId(0) Json.1070;
                    let Json.1068 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) Json.1069;
                    ret Json.1068;
                else
                    jump Json.1075;
            in
            let Json.1132 : Int1 = CallByName Json.60 Json.502;
            jump Json.1131 Json.1132;
    
        default:
            jump Json.1075;
    

procedure Json.58 (Json.507):
    switch Json.507:
        case 34:
            let Json.981 : Int1 = CallByName Bool.2;
            ret Json.981;
    
        case 92:
            let Json.982 : Int1 = CallByName Bool.2;
            ret Json.982;
    
        case 47:
            let Json.983 : Int1 = CallByName Bool.2;
            ret Json.983;
    
        case 98:
            let Json.984 : Int1 = CallByName Bool.2;
            ret Json.984;
    
        case 102:
            let Json.985 : Int1 = CallByName Bool.2;
            ret Json.985;
    
        case 110:
            let Json.986 : Int1 = CallByName Bool.2;
            ret Json.986;
    
        case 114:
            let Json.987 : Int1 = CallByName Bool.2;
            ret Json.987;
    
        case 116:
            let Json.988 : Int1 = CallByName Bool.2;
            ret Json.988;
    
        default:
            let Json.989 : Int1 = CallByName Bool.1;
            ret Json.989;
    

procedure Json.59 (Json.508):
    switch Json.508:
        case 34:
            let Json.959 : U8 = 34i64;
            ret Json.959;
    
        case 92:
            let Json.960 : U8 = 92i64;
            ret Json.960;
    
        case 47:
            let Json.961 : U8 = 47i64;
            ret Json.961;
    
        case 98:
            let Json.962 : U8 = 8i64;
            ret Json.962;
    
        case 102:
            let Json.963 : U8 = 12i64;
            ret Json.963;
    
        case 110:
            let Json.964 : U8 = 10i64;
            ret Json.964;
    
        case 114:
            let Json.965 : U8 = 13i64;
            ret Json.965;
    
        case 116:
            let Json.966 : U8 = 9i64;
            ret Json.966;
    
        default:
            ret Json.508;
    

procedure Json.60 (Json.509):
    let Json.1120 : U8 = 48i64;
    let Json.1117 : Int1 = CallByName Num.25 Json.509 Json.1120;
    let Json.1119 : U8 = 57i64;
    let Json.1118 : Int1 = CallByName Num.23 Json.509 Json.1119;
    let Json.1105 : Int1 = CallByName Bool.3 Json.1117 Json.1118;
    let Json.1116 : U8 = 97i64;
    let Json.1113 : Int1 = CallByName Num.25 Json.509 Json.1116;
    let Json.1115 : U8 = 102i64;
    let Json.1114 : Int1 = CallByName Num.23 Json.509 Json.1115;
    let Json.1107 : Int1 = CallByName Bool.3 Json.1113 Json.1114;
    let Json.1112 : U8 = 65i64;
    let Json.1109 : Int1 = CallByName Num.25 Json.509 Json.1112;
    let Json.1111 : U8 = 70i64;
    let Json.1110 : Int1 = CallByName Num.23 Json.509 Json.1111;
    let Json.1108 : Int1 = CallByName Bool.3 Json.1109 Json.1110;
    let Json.1106 : Int1 = CallByName Bool.4 Json.1107 Json.1108;
    let Json.1104 : Int1 = CallByName Bool.4 Json.1105 Json.1106;
    ret Json.1104;

procedure Json.61 (Json.510):
    let Json.938 : U8 = 48i64;
    let Json.935 : Int1 = CallByName Num.25 Json.510 Json.938;
    let Json.937 : U8 = 57i64;
    let Json.936 : Int1 = CallByName Num.23 Json.510 Json.937;
    let Json.932 : Int1 = CallByName Bool.3 Json.935 Json.936;
    if Json.932 then
        let Json.934 : U8 = 48i64;
        let Json.933 : U8 = CallByName Num.20 Json.510 Json.934;
        ret Json.933;
    else
        let Json.931 : U8 = 97i64;
        let Json.928 : Int1 = CallByName Num.25 Json.510 Json.931;
        let Json.930 : U8 = 102i64;
        let Json.929 : Int1 = CallByName Num.23 Json.510 Json.930;
        let Json.923 : Int1 = CallByName Bool.3 Json.928 Json.929;
        if Json.923 then
            let Json.927 : U8 = 97i64;
            let Json.925 : U8 = CallByName Num.20 Json.510 Json.927;
            let Json.926 : U8 = 10i64;
            let Json.924 : U8 = CallByName Num.19 Json.925 Json.926;
            ret Json.924;
        else
            let Json.922 : U8 = 65i64;
            let Json.919 : Int1 = CallByName Num.25 Json.510 Json.922;
            let Json.921 : U8 = 70i64;
            let Json.920 : Int1 = CallByName Num.23 Json.510 Json.921;
            let Json.914 : Int1 = CallByName Bool.3 Json.919 Json.920;
            if Json.914 then
                let Json.918 : U8 = 65i64;
                let Json.916 : U8 = CallByName Num.20 Json.510 Json.918;
                let Json.917 : U8 = 10i64;
                let Json.915 : U8 = CallByName Num.19 Json.916 Json.917;
                ret Json.915;
            else
                let Json.913 : Str = "got an invalid hex char";
                Crash Json.913

procedure Json.62 (Json.511, Json.512):
    let Json.904 : U8 = 4i64;
    let Json.903 : U8 = CallByName Num.72 Json.511 Json.904;
    let Json.902 : U8 = CallByName Num.71 Json.903 Json.512;
    ret Json.902;

procedure Json.63 (Json.513, Json.514, Json.515, Json.516):
    let Json.517 : U8 = CallByName Json.61 Json.513;
    let Json.518 : U8 = CallByName Json.61 Json.514;
    let Json.519 : U8 = CallByName Json.61 Json.515;
    let Json.520 : U8 = CallByName Json.61 Json.516;
    let Json.911 : U8 = 0i64;
    let Json.908 : Int1 = CallByName Bool.11 Json.517 Json.911;
    let Json.910 : U8 = 0i64;
    let Json.909 : Int1 = CallByName Bool.11 Json.518 Json.910;
    let Json.905 : Int1 = CallByName Bool.3 Json.908 Json.909;
    if Json.905 then
        let Json.907 : U8 = CallByName Json.62 Json.519 Json.520;
        let Json.906 : List U8 = Array [Json.907];
        ret Json.906;
    else
        let Json.900 : U8 = CallByName Json.62 Json.517 Json.518;
        let Json.901 : U8 = CallByName Json.62 Json.519 Json.520;
        let Json.899 : List U8 = Array [Json.900, Json.901];
        ret Json.899;

procedure Json.64 ():
    let Json.944 : U8 = 102i64;
    let Json.945 : U8 = 102i64;
    let Json.946 : U8 = 100i64;
    let Json.947 : U8 = 100i64;
    let Json.943 : List U8 = CallByName Json.63 Json.944 Json.945 Json.946 Json.947;
    ret Json.943;

procedure Json.65 (Json.1137):
    joinpoint Json.894 Json.876:
        let Json.521 : List U8 = StructAtIndex 0 Json.876;
        inc Json.521;
        let Json.522 : List U8 = StructAtIndex 1 Json.876;
        inc Json.522;
        dec Json.876;
        let Json.1012 : U64 = 0i64;
        let Json.523 : [C {}, C U8] = CallByName List.2 Json.521 Json.1012;
        let Json.1011 : U64 = 1i64;
        let Json.524 : [C {}, C U8] = CallByName List.2 Json.521 Json.1011;
        let Json.1010 : U64 = 2i64;
        inc Json.521;
        let Json.525 : List U8 = CallByName List.29 Json.521 Json.1010;
        let Json.1009 : U64 = 6i64;
        inc Json.521;
        let Json.526 : List U8 = CallByName List.29 Json.521 Json.1009;
        let Json.895 : {[C {}, C U8], [C {}, C U8]} = Struct {Json.523, Json.524};
        joinpoint Json.974:
            let Json.973 : [C {}, C U8] = StructAtIndex 0 Json.895;
            let Json.537 : U8 = UnionAtIndex (Id 1) (Index 0) Json.973;
            let Json.970 : List U8 = CallByName List.38 Json.521;
            let Json.971 : List U8 = CallByName List.4 Json.522 Json.537;
            let Json.969 : {List U8, List U8} = Struct {Json.970, Json.971};
            jump Json.894 Json.969;
        in
        let Json.1005 : [C {}, C U8] = StructAtIndex 0 Json.895;
        let Json.1006 : U8 = 1i64;
        let Json.1007 : U8 = GetTagId Json.1005;
        let Json.1008 : Int1 = lowlevel Eq Json.1006 Json.1007;
        if Json.1008 then
            let Json.1001 : [C {}, C U8] = StructAtIndex 1 Json.895;
            let Json.1002 : U8 = 1i64;
            let Json.1003 : U8 = GetTagId Json.1001;
            let Json.1004 : Int1 = lowlevel Eq Json.1002 Json.1003;
            if Json.1004 then
                let Json.1000 : [C {}, C U8] = StructAtIndex 0 Json.895;
                let Json.528 : U8 = UnionAtIndex (Id 1) (Index 0) Json.1000;
                let Json.999 : [C {}, C U8] = StructAtIndex 1 Json.895;
                let Json.529 : U8 = UnionAtIndex (Id 1) (Index 0) Json.999;
                joinpoint Json.993 Json.975:
                    if Json.975 then
                        dec Json.521;
                        let Json.952 : U64 = lowlevel ListLen Json.525;
                        let Json.953 : U64 = 4i64;
                        let Json.954 : Int1 = lowlevel NumGte Json.952 Json.953;
                        if Json.954 then
                            let Json.951 : U64 = 0i64;
                            let Json.530 : U8 = lowlevel ListGetUnsafe Json.525 Json.951;
                            let Json.950 : U64 = 1i64;
                            let Json.531 : U8 = lowlevel ListGetUnsafe Json.525 Json.950;
                            let Json.949 : U64 = 2i64;
                            let Json.532 : U8 = lowlevel ListGetUnsafe Json.525 Json.949;
                            let Json.948 : U64 = 3i64;
                            let Json.533 : U8 = lowlevel ListGetUnsafe Json.525 Json.948;
                            dec Json.525;
                            let Json.534 : List U8 = CallByName Json.63 Json.530 Json.531 Json.532 Json.533;
                            let Json.898 : List U8 = CallByName List.8 Json.522 Json.534;
                            let Json.897 : {List U8, List U8} = Struct {Json.526, Json.898};
                            jump Json.894 Json.897;
                        else
                            dec Json.526;
                            let Json.942 : List U8 = CallByName Json.64;
                            let Json.941 : List U8 = CallByName List.8 Json.522 Json.942;
                            let Json.940 : {List U8, List U8} = Struct {Json.525, Json.941};
                            jump Json.894 Json.940;
                    else
                        dec Json.526;
                        let Json.992 : [C {}, C U8] = StructAtIndex 0 Json.895;
                        let Json.535 : U8 = UnionAtIndex (Id 1) (Index 0) Json.992;
                        let Json.991 : [C {}, C U8] = StructAtIndex 1 Json.895;
                        let Json.536 : U8 = UnionAtIndex (Id 1) (Index 0) Json.991;
                        joinpoint Json.977 Json.976:
                            if Json.976 then
                                dec Json.521;
                                let Json.958 : U8 = CallByName Json.59 Json.536;
                                let Json.957 : List U8 = CallByName List.4 Json.522 Json.958;
                                let Json.956 : {List U8, List U8} = Struct {Json.525, Json.957};
                                jump Json.894 Json.956;
                            else
                                dec Json.525;
                                jump Json.974;
                        in
                        let Json.990 : U8 = 92i64;
                        let Json.979 : Int1 = CallByName Bool.11 Json.535 Json.990;
                        let Json.980 : Int1 = CallByName Json.58 Json.536;
                        let Json.978 : Int1 = CallByName Bool.3 Json.979 Json.980;
                        jump Json.977 Json.978;
                in
                let Json.998 : U8 = 92i64;
                let Json.995 : Int1 = CallByName Bool.11 Json.528 Json.998;
                let Json.997 : U8 = 117i64;
                let Json.996 : Int1 = CallByName Bool.11 Json.529 Json.997;
                let Json.994 : Int1 = CallByName Bool.3 Json.995 Json.996;
                jump Json.993 Json.994;
            else
                dec Json.526;
                dec Json.525;
                jump Json.974;
        else
            dec Json.526;
            dec Json.525;
            let Json.972 : {List U8, List U8} = Struct {Json.521, Json.522};
            ret Json.972;
    in
    jump Json.894 Json.1137;

procedure List.1 (List.95):
    let List.552 : U64 = CallByName List.6 List.95;
    let List.553 : U64 = 0i64;
    let List.551 : Int1 = CallByName Bool.11 List.552 List.553;
    ret List.551;

procedure List.2 (List.96, List.97):
    let List.550 : U64 = CallByName List.6 List.96;
    let List.547 : Int1 = CallByName Num.22 List.97 List.550;
    if List.547 then
        let List.549 : U8 = CallByName List.66 List.96 List.97;
        let List.548 : [C {}, C U8] = TagId(1) List.549;
        ret List.548;
    else
        let List.546 : {} = Struct {};
        let List.545 : [C {}, C U8] = TagId(0) List.546;
        ret List.545;

procedure List.26 (List.153, List.154, List.155):
    let List.561 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.92 List.153 List.154 List.155;
    let List.564 : U8 = 1i64;
    let List.565 : U8 = GetTagId List.561;
    let List.566 : Int1 = lowlevel Eq List.564 List.565;
    if List.566 then
        let List.156 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.561;
        ret List.156;
    else
        let List.157 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.561;
        ret List.157;

procedure List.29 (List.298, List.299):
    let List.537 : U64 = CallByName List.6 List.298;
    let List.300 : U64 = CallByName Num.77 List.537 List.299;
    let List.536 : List U8 = CallByName List.43 List.298 List.300;
    ret List.536;

procedure List.31 (#Attr.2, #Attr.3):
    let List.502 : List U8 = lowlevel ListDropAt #Attr.2 #Attr.3;
    ret List.502;

procedure List.32 (List.293):
    let List.503 : U64 = CallByName List.6 List.293;
    let List.504 : U64 = 1i64;
    let List.501 : U64 = CallByName Num.77 List.503 List.504;
    let List.500 : List U8 = CallByName List.31 List.293 List.501;
    ret List.500;

procedure List.38 (List.292):
    let List.509 : U64 = 0i64;
    let List.508 : List U8 = CallByName List.31 List.292 List.509;
    ret List.508;

procedure List.4 (List.107, List.108):
    let List.519 : U64 = 1i64;
    let List.518 : List U8 = CallByName List.70 List.107 List.519;
    let List.517 : List U8 = CallByName List.71 List.518 List.108;
    ret List.517;

procedure List.43 (List.296, List.297):
    let List.532 : U64 = CallByName List.6 List.296;
    let List.531 : U64 = CallByName Num.77 List.532 List.297;
    let List.522 : {U64, U64} = Struct {List.297, List.531};
    let List.521 : List U8 = CallByName List.49 List.296 List.522;
    ret List.521;

procedure List.49 (List.370, List.371):
    let List.559 : U64 = StructAtIndex 0 List.371;
    let List.560 : U64 = 0i64;
    let List.557 : Int1 = CallByName Bool.11 List.559 List.560;
    if List.557 then
        dec List.370;
        let List.558 : List U8 = Array [];
        ret List.558;
    else
        let List.555 : U64 = StructAtIndex 1 List.371;
        let List.556 : U64 = StructAtIndex 0 List.371;
        let List.554 : List U8 = CallByName List.72 List.370 List.555 List.556;
        ret List.554;

procedure List.6 (#Attr.2):
    let List.620 : U64 = lowlevel ListLen #Attr.2;
    ret List.620;

procedure List.66 (#Attr.2, #Attr.3):
    let List.543 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.543;

procedure List.70 (#Attr.2, #Attr.3):
    let List.516 : List U8 = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.516;

procedure List.71 (#Attr.2, #Attr.3):
    let List.514 : List U8 = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.514;

procedure List.72 (#Attr.2, #Attr.3, #Attr.4):
    let List.526 : List U8 = lowlevel ListSublist #Attr.2 #Attr.3 #Attr.4;
    ret List.526;

procedure List.8 (#Attr.2, #Attr.3):
    let List.511 : List U8 = lowlevel ListConcat #Attr.2 #Attr.3;
    ret List.511;

procedure List.80 (List.612, List.613, List.614, List.615, List.616):
    joinpoint List.570 List.433 List.434 List.435 List.436 List.437:
        let List.572 : Int1 = CallByName Num.22 List.436 List.437;
        if List.572 then
            let List.581 : U8 = CallByName List.66 List.433 List.436;
            let List.573 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName Json.57 List.434 List.581;
            let List.578 : U8 = 1i64;
            let List.579 : U8 = GetTagId List.573;
            let List.580 : Int1 = lowlevel Eq List.578 List.579;
            if List.580 then
                let List.438 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 1) (Index 0) List.573;
                let List.576 : U64 = 1i64;
                let List.575 : U64 = CallByName Num.19 List.436 List.576;
                jump List.570 List.433 List.438 List.435 List.575 List.437;
            else
                let List.439 : [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64] = UnionAtIndex (Id 0) (Index 0) List.573;
                let List.577 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(0) List.439;
                ret List.577;
        else
            let List.571 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = TagId(1) List.434;
            ret List.571;
    in
    jump List.570 List.612 List.613 List.614 List.615 List.616;

procedure List.92 (List.430, List.431, List.432):
    let List.568 : U64 = 0i64;
    let List.569 : U64 = CallByName List.6 List.430;
    let List.567 : [C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64], C [C U64, C U64, C U64, C , C , C U64, C U64, C U64, C U64]] = CallByName List.80 List.430 List.431 List.432 List.568 List.569;
    ret List.567;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.278 : U8 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.278;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.325 : U64 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.325;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.290 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.290;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.324 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.324;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.296 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.296;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.302 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.302;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.275 : U8 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.275;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.276 : U8 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.276;

procedure Num.77 (#Attr.2, #Attr.3):
    let Num.321 : U64 = lowlevel NumSubSaturated #Attr.2 #Attr.3;
    ret Num.321;

procedure Str.48 (#Attr.2, #Attr.3, #Attr.4):
    let Str.275 : {U64, Str, Int1, U8} = lowlevel StrFromUtf8Range #Attr.2 #Attr.3 #Attr.4;
    ret Str.275;

procedure Str.9 (Str.77):
    let Str.273 : U64 = 0i64;
    let Str.274 : U64 = CallByName List.6 Str.77;
    let Str.78 : {U64, Str, Int1, U8} = CallByName Str.48 Str.77 Str.273 Str.274;
    let Str.270 : Int1 = StructAtIndex 2 Str.78;
    if Str.270 then
        let Str.272 : Str = StructAtIndex 1 Str.78;
        inc Str.272;
        dec Str.78;
        let Str.271 : [C {U64, U8}, C Str] = TagId(1) Str.272;
        ret Str.271;
    else
        let Str.268 : U8 = StructAtIndex 3 Str.78;
        let Str.269 : U64 = StructAtIndex 0 Str.78;
        dec Str.78;
        let Str.267 : {U64, U8} = Struct {Str.269, Str.268};
        let Str.266 : [C {U64, U8}, C Str] = TagId(0) Str.267;
        ret Str.266;

procedure Test.3 ():
    let Test.0 : List U8 = Array [82i64, 111i64, 99i64];
    let Test.8 : {} = CallByName Json.2;
    inc Test.0;
    let Test.1 : [C [C List U8, C ], C Str] = CallByName Decode.27 Test.0 Test.8;
    let Test.7 : Str = "Roc";
    let Test.6 : [C [C List U8, C ], C Str] = TagId(1) Test.7;
    inc Test.1;
    let Test.5 : Int1 = CallByName Bool.11 Test.1 Test.6;
    expect Test.5;
    let Test.4 : {} = Struct {};
    ret Test.4;
