procedure Bool.1 ():
    let Bool.32 : Int1 = false;
    ret Bool.32;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.28 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.28;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.29 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.29;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.30 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.30;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.24 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.24;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.26 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.26;

procedure Bool.2 ():
    let Bool.31 : Int1 = true;
    ret Bool.31;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.25 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.25;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.27 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.27;

procedure Dict.1 (Dict.692):
    let Dict.863 : List {U32, U32} = Array [];
    let Dict.864 : List {Str, I64} = Array [];
    let Dict.865 : U64 = 0i64;
    let Dict.42 : Float32 = CallByName Dict.42;
    let Dict.43 : U8 = CallByName Dict.43;
    let Dict.862 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.863, Dict.864, Dict.865, Dict.42, Dict.43};
    ret Dict.862;

procedure Dict.10 (Dict.693, Dict.173, Dict.174):
    let Dict.172 : List {Str, I64} = StructAtIndex 1 Dict.693;
    let #Derived_gen.67 : List {U32, U32} = StructAtIndex 0 Dict.693;
    dec #Derived_gen.67;
    let Dict.1080 : {Str, Int1} = CallByName List.18 Dict.172 Dict.173 Dict.174;
    ret Dict.1080;

procedure Dict.113 (Dict.114, Dict.112):
    let Dict.1077 : {} = Struct {};
    let Dict.1078 : {} = Struct {};
    let Dict.1079 : {} = Struct {};
    let Dict.1076 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.39 Dict.112 Dict.1077 Dict.1078 Dict.1079;
    let Dict.1075 : Str = CallByName Inspect.31 Dict.1076 Dict.114;
    ret Dict.1075;

procedure Dict.12 (Dict.145):
    let Dict.861 : {} = Struct {};
    let Dict.700 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.1 Dict.861;
    let Dict.701 : {} = Struct {};
    let Dict.699 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.18 Dict.145 Dict.700 Dict.701;
    ret Dict.699;

procedure Dict.146 (Dict.147, Dict.702):
    let Dict.148 : Str = StructAtIndex 0 Dict.702;
    let Dict.149 : I64 = StructAtIndex 1 Dict.702;
    let Dict.703 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.8 Dict.147 Dict.148 Dict.149;
    ret Dict.703;

procedure Dict.175 (Dict.176, Dict.1082, Dict.174):
    let Dict.177 : Str = StructAtIndex 0 Dict.1082;
    let Dict.178 : I64 = StructAtIndex 1 Dict.1082;
    let Dict.1084 : {Str, Int1} = CallByName Inspect.192 Dict.176 Dict.177 Dict.178 Dict.174;
    ret Dict.1084;

procedure Dict.20 (Dict.689):
    let Dict.142 : U64 = StructAtIndex 2 Dict.689;
    let #Derived_gen.69 : List {U32, U32} = StructAtIndex 0 Dict.689;
    dec #Derived_gen.69;
    let #Derived_gen.68 : List {Str, I64} = StructAtIndex 1 Dict.689;
    dec #Derived_gen.68;
    let Dict.859 : U64 = CallByName Num.137 Dict.142;
    ret Dict.859;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.738 : {U32, U32} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.738;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.754 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.754;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.923 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.923;

procedure Dict.23 (#Attr.2):
    let Dict.792 : U64 = lowlevel DictPseudoSeed #Attr.2;
    ret Dict.792;

procedure Dict.35 (Dict.112):
    let Dict.1072 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Inspect.30 Dict.112;
    ret Dict.1072;

procedure Dict.37 (#Derived_gen.16, #Derived_gen.17, #Derived_gen.18, #Derived_gen.19, #Derived_gen.20, #Derived_gen.21, #Derived_gen.22, #Derived_gen.23, #Derived_gen.24):
    joinpoint Dict.705 Dict.215 Dict.216 Dict.217 Dict.218 Dict.219 Dict.220 Dict.221 Dict.222 Dict.223:
        let Dict.757 : U64 = CallByName Num.137 Dict.217;
        let Dict.224 : {U32, U32} = CallByName Dict.22 Dict.215 Dict.757;
        let Dict.756 : U32 = StructAtIndex 1 Dict.224;
        let Dict.744 : Int1 = CallByName Bool.11 Dict.218 Dict.756;
        if Dict.744 then
            let Dict.755 : U32 = StructAtIndex 0 Dict.224;
            let Dict.753 : U64 = CallByName Num.137 Dict.755;
            let Dict.752 : {Str, I64} = CallByName Dict.22 Dict.216 Dict.753;
            let Dict.225 : Str = StructAtIndex 0 Dict.752;
            let Dict.747 : Int1 = CallByName Bool.11 Dict.225 Dict.219;
            if Dict.747 then
                let Dict.751 : U32 = StructAtIndex 0 Dict.224;
                let Dict.749 : U64 = CallByName Num.137 Dict.751;
                let Dict.750 : {Str, I64} = Struct {Dict.219, Dict.220};
                let Dict.226 : List {Str, I64} = CallByName List.3 Dict.216 Dict.749 Dict.750;
                let Dict.748 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.215, Dict.226, Dict.221, Dict.222, Dict.223};
                ret Dict.748;
            else
                let Dict.746 : U64 = CallByName List.6 Dict.215;
                let Dict.227 : U64 = CallByName Dict.64 Dict.217 Dict.746;
                let Dict.228 : U32 = CallByName Dict.46 Dict.218;
                jump Dict.705 Dict.215 Dict.216 Dict.227 Dict.228 Dict.219 Dict.220 Dict.221 Dict.222 Dict.223;
        else
            let Dict.743 : U32 = StructAtIndex 1 Dict.224;
            let Dict.719 : Int1 = CallByName Num.24 Dict.218 Dict.743;
            if Dict.719 then
                let Dict.742 : {Str, I64} = Struct {Dict.219, Dict.220};
                let Dict.229 : List {Str, I64} = CallByName List.4 Dict.216 Dict.742;
                let Dict.740 : U64 = CallByName List.6 Dict.229;
                let Dict.741 : U64 = 1i64;
                let Dict.230 : U64 = CallByName Num.20 Dict.740 Dict.741;
                let Dict.739 : U32 = CallByName Num.131 Dict.230;
                let Dict.721 : {U32, U32} = Struct {Dict.739, Dict.218};
                let Dict.231 : List {U32, U32} = CallByName Dict.63 Dict.215 Dict.721 Dict.217;
                let Dict.720 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.231, Dict.229, Dict.221, Dict.222, Dict.223};
                ret Dict.720;
            else
                let Dict.712 : U64 = CallByName List.6 Dict.215;
                let Dict.232 : U64 = CallByName Dict.64 Dict.217 Dict.712;
                let Dict.233 : U32 = CallByName Dict.46 Dict.218;
                jump Dict.705 Dict.215 Dict.216 Dict.232 Dict.233 Dict.219 Dict.220 Dict.221 Dict.222 Dict.223;
    in
    jump Dict.705 #Derived_gen.16 #Derived_gen.17 #Derived_gen.18 #Derived_gen.19 #Derived_gen.20 #Derived_gen.21 #Derived_gen.22 #Derived_gen.23 #Derived_gen.24;

procedure Dict.383 (Dict.384, Dict.815, Dict.386, Dict.382):
    let Dict.385 : Str = StructAtIndex 0 Dict.815;
    inc Dict.384;
    let Dict.820 : {U64, U32} = CallByName Dict.61 Dict.384 Dict.385 Dict.382;
    let Dict.387 : U64 = StructAtIndex 0 Dict.820;
    let Dict.388 : U32 = StructAtIndex 1 Dict.820;
    let Dict.819 : U32 = CallByName Num.131 Dict.386;
    let Dict.818 : {U32, U32} = Struct {Dict.819, Dict.388};
    let Dict.817 : List {U32, U32} = CallByName Dict.63 Dict.384 Dict.818 Dict.387;
    ret Dict.817;

procedure Dict.39 ():
    let Dict.837 : U32 = 0i64;
    let Dict.838 : U32 = 0i64;
    let Dict.836 : {U32, U32} = Struct {Dict.837, Dict.838};
    ret Dict.836;

procedure Dict.4 (Dict.698):
    let Dict.150 : List {Str, I64} = StructAtIndex 1 Dict.698;
    let #Derived_gen.66 : List {U32, U32} = StructAtIndex 0 Dict.698;
    dec #Derived_gen.66;
    let Dict.860 : U64 = CallByName List.6 Dict.150;
    dec Dict.150;
    ret Dict.860;

procedure Dict.40 ():
    let Dict.710 : U32 = 1i64;
    let Dict.711 : U8 = 8i64;
    let Dict.709 : U32 = CallByName Num.72 Dict.710 Dict.711;
    ret Dict.709;

procedure Dict.41 ():
    let Dict.766 : U32 = CallByName Dict.40;
    let Dict.767 : U32 = 1i64;
    let Dict.765 : U32 = CallByName Num.75 Dict.766 Dict.767;
    ret Dict.765;

procedure Dict.42 ():
    let Dict.869 : Float32 = 0.8f64;
    ret Dict.869;

procedure Dict.43 ():
    let Dict.867 : U8 = 64i64;
    let Dict.868 : U8 = 3i64;
    let Dict.866 : U8 = CallByName Num.20 Dict.867 Dict.868;
    ret Dict.866;

procedure Dict.44 ():
    let Dict.809 : U64 = 1i64;
    let Dict.810 : U8 = 32i64;
    let Dict.808 : U64 = CallByName Num.72 Dict.809 Dict.810;
    ret Dict.808;

procedure Dict.45 ():
    let Dict.807 : U64 = CallByName Dict.44;
    ret Dict.807;

procedure Dict.46 (Dict.293):
    let Dict.708 : U32 = CallByName Dict.40;
    let Dict.707 : U32 = CallByName Num.19 Dict.293 Dict.708;
    ret Dict.707;

procedure Dict.55 (Dict.688):
    let Dict.361 : List {Str, I64} = StructAtIndex 1 Dict.688;
    let Dict.362 : U64 = StructAtIndex 2 Dict.688;
    let Dict.363 : Float32 = StructAtIndex 3 Dict.688;
    let Dict.364 : U8 = StructAtIndex 4 Dict.688;
    let #Derived_gen.71 : List {U32, U32} = StructAtIndex 0 Dict.688;
    dec #Derived_gen.71;
    let Dict.855 : U64 = CallByName Dict.45;
    let Dict.811 : Int1 = CallByName Bool.7 Dict.362 Dict.855;
    if Dict.811 then
        inc Dict.361;
        let Dict.854 : U8 = 1i64;
        let Dict.365 : U8 = CallByName Num.20 Dict.364 Dict.854;
        let Dict.831 : {List {U32, U32}, U64} = CallByName Dict.56 Dict.365 Dict.363;
        let Dict.366 : List {U32, U32} = StructAtIndex 0 Dict.831;
        let Dict.367 : U64 = StructAtIndex 1 Dict.831;
        let Dict.368 : List {U32, U32} = CallByName Dict.60 Dict.366 Dict.361 Dict.365;
        let Dict.812 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.368, Dict.361, Dict.367, Dict.363, Dict.365};
        ret Dict.812;
    else
        dec Dict.361;
        let Dict.802 : Str = "Dict hit limit of ";
        let Dict.806 : U64 = CallByName Dict.45;
        let Dict.804 : Str = CallByName Num.96 Dict.806;
        let Dict.805 : Str = " elements. Unable to grow more.";
        let Dict.803 : Str = CallByName Str.3 Dict.804 Dict.805;
        dec Dict.805;
        let Dict.801 : Str = CallByName Str.3 Dict.802 Dict.803;
        dec Dict.803;
        Crash Dict.801

procedure Dict.56 (Dict.369, Dict.370):
    let Dict.371 : U64 = CallByName Dict.59 Dict.369;
    let Dict.847 : U64 = CallByName Dict.45;
    let Dict.841 : Int1 = CallByName Bool.11 Dict.371 Dict.847;
    if Dict.841 then
        let Dict.844 : {U32, U32} = CallByName Dict.39;
        let Dict.846 : U64 = CallByName Dict.45;
        let Dict.845 : U64 = CallByName Num.137 Dict.846;
        let Dict.843 : List {U32, U32} = CallByName List.11 Dict.844 Dict.845;
        let Dict.45 : U64 = CallByName Dict.45;
        let Dict.842 : {List {U32, U32}, U64} = Struct {Dict.843, Dict.45};
        ret Dict.842;
    else
        let Dict.840 : Float32 = CallByName Num.139 Dict.371;
        let Dict.839 : Float32 = CallByName Num.21 Dict.840 Dict.370;
        let Dict.372 : U64 = CallByName Num.50 Dict.839;
        let Dict.834 : {U32, U32} = CallByName Dict.39;
        let Dict.835 : U64 = CallByName Num.137 Dict.371;
        let Dict.833 : List {U32, U32} = CallByName List.11 Dict.834 Dict.835;
        let Dict.832 : {List {U32, U32}, U64} = Struct {Dict.833, Dict.372};
        ret Dict.832;

procedure Dict.59 (Dict.379):
    let Dict.851 : U64 = 1i64;
    let Dict.853 : U8 = 64i64;
    let Dict.852 : U8 = CallByName Num.20 Dict.853 Dict.379;
    let Dict.849 : U64 = CallByName Num.72 Dict.851 Dict.852;
    let Dict.850 : U64 = CallByName Dict.45;
    let Dict.848 : U64 = CallByName Num.159 Dict.849 Dict.850;
    ret Dict.848;

procedure Dict.60 (Dict.380, Dict.381, Dict.382):
    let Dict.813 : List {U32, U32} = CallByName List.83 Dict.381 Dict.380 Dict.382;
    ret Dict.813;

procedure Dict.61 (Dict.389, Dict.390, Dict.391):
    let Dict.392 : U64 = CallByName Dict.65 Dict.390;
    let Dict.393 : U32 = CallByName Dict.66 Dict.392;
    let Dict.394 : U64 = CallByName Dict.67 Dict.392 Dict.391;
    let Dict.821 : {U64, U32} = CallByName Dict.62 Dict.389 Dict.394 Dict.393;
    ret Dict.821;

procedure Dict.62 (#Derived_gen.39, #Derived_gen.40, #Derived_gen.41):
    joinpoint Dict.822 Dict.395 Dict.396 Dict.397:
        let Dict.830 : U64 = CallByName Num.137 Dict.396;
        let Dict.398 : {U32, U32} = CallByName Dict.22 Dict.395 Dict.830;
        let Dict.829 : U32 = StructAtIndex 1 Dict.398;
        let Dict.824 : Int1 = CallByName Num.22 Dict.397 Dict.829;
        if Dict.824 then
            let Dict.828 : U64 = CallByName List.6 Dict.395;
            let Dict.826 : U64 = CallByName Dict.64 Dict.396 Dict.828;
            let Dict.827 : U32 = CallByName Dict.46 Dict.397;
            jump Dict.822 Dict.395 Dict.826 Dict.827;
        else
            dec Dict.395;
            let Dict.823 : {U64, U32} = Struct {Dict.396, Dict.397};
            ret Dict.823;
    in
    jump Dict.822 #Derived_gen.39 #Derived_gen.40 #Derived_gen.41;

procedure Dict.63 (#Derived_gen.59, #Derived_gen.60, #Derived_gen.61):
    joinpoint Dict.722 Dict.399 Dict.400 Dict.401:
        let Dict.737 : U64 = CallByName Num.137 Dict.401;
        let Dict.402 : {U32, U32} = CallByName Dict.22 Dict.399 Dict.737;
        let Dict.735 : U32 = StructAtIndex 1 Dict.402;
        let Dict.736 : U32 = 0i64;
        let Dict.725 : Int1 = CallByName Bool.7 Dict.735 Dict.736;
        if Dict.725 then
            let Dict.734 : U64 = CallByName Num.137 Dict.401;
            let Dict.733 : {List {U32, U32}, {U32, U32}} = CallByName List.64 Dict.399 Dict.734 Dict.400;
            let Dict.404 : List {U32, U32} = StructAtIndex 0 Dict.733;
            let Dict.406 : {U32, U32} = StructAtIndex 1 Dict.733;
            let Dict.730 : U32 = StructAtIndex 0 Dict.406;
            let Dict.731 : U32 = StructAtIndex 1 Dict.406;
            let Dict.732 : U32 = CallByName Dict.46 Dict.731;
            let Dict.727 : {U32, U32} = Struct {Dict.730, Dict.732};
            let Dict.729 : U64 = CallByName List.6 Dict.404;
            let Dict.728 : U64 = CallByName Dict.64 Dict.401 Dict.729;
            jump Dict.722 Dict.404 Dict.727 Dict.728;
        else
            let Dict.724 : U64 = CallByName Num.137 Dict.401;
            let Dict.723 : List {U32, U32} = CallByName List.3 Dict.399 Dict.724 Dict.400;
            ret Dict.723;
    in
    jump Dict.722 #Derived_gen.59 #Derived_gen.60 #Derived_gen.61;

procedure Dict.64 (Dict.407, Dict.408):
    let Dict.718 : U64 = 1i64;
    let Dict.717 : U64 = CallByName Num.51 Dict.407 Dict.718;
    let Dict.714 : Int1 = CallByName Bool.7 Dict.717 Dict.408;
    if Dict.714 then
        let Dict.716 : U64 = 1i64;
        let Dict.715 : U64 = CallByName Num.51 Dict.407 Dict.716;
        ret Dict.715;
    else
        let Dict.713 : U64 = 0i64;
        ret Dict.713;

procedure Dict.65 (Dict.409):
    let Dict.772 : [C , C U64] = TagId(0) ;
    let Dict.771 : {U64, U64} = CallByName Dict.68 Dict.772;
    let Dict.769 : {U64, U64} = CallByName Hash.19 Dict.771 Dict.409;
    let Dict.768 : U64 = CallByName Dict.71 Dict.769;
    ret Dict.768;

procedure Dict.66 (Dict.411):
    let Dict.763 : U32 = CallByName Num.131 Dict.411;
    let Dict.764 : U32 = CallByName Dict.41;
    let Dict.761 : U32 = CallByName Num.69 Dict.763 Dict.764;
    let Dict.762 : U32 = CallByName Dict.40;
    let Dict.760 : U32 = CallByName Num.71 Dict.761 Dict.762;
    ret Dict.760;

procedure Dict.67 (Dict.412, Dict.413):
    let Dict.759 : U64 = CallByName Num.74 Dict.412 Dict.413;
    let Dict.758 : U64 = CallByName Num.137 Dict.759;
    ret Dict.758;

procedure Dict.68 (Dict.414):
    joinpoint Dict.789 Dict.415:
        let Dict.774 : U64 = CallByName Dict.70 Dict.415;
        let Dict.773 : {U64, U64} = Struct {Dict.774, Dict.415};
        ret Dict.773;
    in
    let Dict.794 : U8 = 0i64;
    let Dict.795 : U8 = GetTagId Dict.414;
    let Dict.796 : Int1 = lowlevel Eq Dict.794 Dict.795;
    if Dict.796 then
        let Dict.791 : {} = Struct {};
        let Dict.790 : U64 = CallByName Dict.23 Dict.791;
        jump Dict.789 Dict.790;
    else
        let Dict.416 : U64 = UnionAtIndex (Id 1) (Index 0) Dict.414;
        jump Dict.789 Dict.416;

procedure Dict.69 (Dict.678, Dict.679):
    let Dict.419 : U64 = StructAtIndex 0 Dict.679;
    let Dict.420 : U64 = StructAtIndex 1 Dict.679;
    let Dict.422 : U64 = StructAtIndex 2 Dict.679;
    let Dict.421 : U64 = StructAtIndex 3 Dict.679;
    let Dict.417 : U64 = StructAtIndex 0 Dict.678;
    let Dict.418 : U64 = StructAtIndex 1 Dict.678;
    let Dict.891 : U64 = CallByName Dict.81;
    let Dict.889 : U64 = CallByName Num.70 Dict.419 Dict.891;
    let Dict.890 : U64 = CallByName Num.70 Dict.420 Dict.421;
    let Dict.423 : {U64, U64} = CallByName Dict.85 Dict.889 Dict.890;
    let Dict.886 : U64 = StructAtIndex 0 Dict.423;
    let Dict.887 : U64 = CallByName Dict.80;
    let Dict.885 : U64 = CallByName Num.70 Dict.886 Dict.887;
    let Dict.424 : U64 = CallByName Num.70 Dict.885 Dict.422;
    let Dict.882 : U64 = StructAtIndex 1 Dict.423;
    let Dict.883 : U64 = CallByName Dict.81;
    let Dict.425 : U64 = CallByName Num.70 Dict.882 Dict.883;
    let Dict.426 : U64 = CallByName Dict.84 Dict.424 Dict.425;
    let Dict.874 : U64 = CallByName Dict.84 Dict.418 Dict.426;
    let Dict.873 : {U64, U64} = Struct {Dict.417, Dict.874};
    ret Dict.873;

procedure Dict.70 (Dict.427):
    let Dict.787 : U64 = CallByName Dict.80;
    let Dict.777 : U64 = CallByName Num.70 Dict.427 Dict.787;
    let Dict.778 : U64 = CallByName Dict.81;
    let Dict.776 : U64 = CallByName Dict.84 Dict.777 Dict.778;
    let Dict.775 : U64 = CallByName Num.70 Dict.776 Dict.427;
    ret Dict.775;

procedure Dict.71 (Dict.696):
    let Dict.428 : U64 = StructAtIndex 1 Dict.696;
    ret Dict.428;

procedure Dict.77 (Dict.672, Dict.467):
    let Dict.465 : U64 = StructAtIndex 0 Dict.672;
    let Dict.466 : U64 = StructAtIndex 1 Dict.672;
    let Dict.468 : U64 = CallByName List.6 Dict.467;
    joinpoint Dict.897 Dict.469:
        let Dict.871 : {U64, U64} = Struct {Dict.465, Dict.466};
        let Dict.892 : U64 = StructAtIndex 0 Dict.469;
        let Dict.893 : U64 = StructAtIndex 1 Dict.469;
        let Dict.894 : U64 = CallByName Num.133 Dict.468;
        let Dict.895 : U64 = StructAtIndex 2 Dict.469;
        let Dict.872 : {U64, U64, U64, U64} = Struct {Dict.892, Dict.893, Dict.894, Dict.895};
        let Dict.870 : {U64, U64} = CallByName Dict.69 Dict.871 Dict.872;
        ret Dict.870;
    in
    let Dict.1071 : U64 = 16i64;
    let Dict.1011 : Int1 = CallByName Num.23 Dict.468 Dict.1071;
    if Dict.1011 then
        joinpoint Dict.1013 Dict.896:
            jump Dict.897 Dict.896;
        in
        let Dict.1070 : U64 = 4i64;
        let Dict.1035 : Int1 = CallByName Num.25 Dict.468 Dict.1070;
        if Dict.1035 then
            let Dict.1069 : U8 = 3i64;
            let Dict.1067 : U64 = CallByName Num.74 Dict.468 Dict.1069;
            let Dict.1068 : U8 = 2i64;
            let Dict.470 : U64 = CallByName Num.72 Dict.1067 Dict.1068;
            let Dict.1066 : U64 = 0i64;
            inc 3 Dict.467;
            let Dict.1064 : U64 = CallByName Dict.87 Dict.467 Dict.1066;
            let Dict.1065 : U8 = 32i64;
            let Dict.1062 : U64 = CallByName Num.72 Dict.1064 Dict.1065;
            let Dict.1063 : U64 = CallByName Dict.87 Dict.467 Dict.470;
            let Dict.471 : U64 = CallByName Num.71 Dict.1062 Dict.1063;
            let Dict.1061 : U64 = 4i64;
            let Dict.1060 : U64 = CallByName Num.75 Dict.468 Dict.1061;
            let Dict.1058 : U64 = CallByName Dict.87 Dict.467 Dict.1060;
            let Dict.1059 : U8 = 32i64;
            let Dict.1036 : U64 = CallByName Num.72 Dict.1058 Dict.1059;
            let Dict.1057 : U64 = 4i64;
            let Dict.1056 : U64 = CallByName Num.75 Dict.468 Dict.1057;
            let Dict.1038 : U64 = CallByName Num.75 Dict.1056 Dict.470;
            let Dict.1037 : U64 = CallByName Dict.87 Dict.467 Dict.1038;
            let Dict.472 : U64 = CallByName Num.71 Dict.1036 Dict.1037;
            let Dict.1012 : {U64, U64, U64} = Struct {Dict.471, Dict.472, Dict.465};
            jump Dict.1013 Dict.1012;
        else
            let Dict.1034 : U64 = 0i64;
            let Dict.1016 : Int1 = CallByName Num.24 Dict.468 Dict.1034;
            if Dict.1016 then
                let Dict.1019 : U64 = 0i64;
                let Dict.1017 : U64 = CallByName Dict.88 Dict.467 Dict.1019 Dict.468;
                let Dict.1018 : U64 = 0i64;
                let Dict.1012 : {U64, U64, U64} = Struct {Dict.1017, Dict.1018, Dict.465};
                jump Dict.1013 Dict.1012;
            else
                dec Dict.467;
                let Dict.1014 : U64 = 0i64;
                let Dict.1015 : U64 = 0i64;
                let Dict.1012 : {U64, U64, U64} = Struct {Dict.1014, Dict.1015, Dict.465};
                jump Dict.1013 Dict.1012;
    else
        let Dict.1010 : U64 = 48i64;
        let Dict.1008 : Int1 = CallByName Num.23 Dict.468 Dict.1010;
        if Dict.1008 then
            let Dict.1009 : U64 = 0i64;
            let Dict.896 : {U64, U64, U64} = CallByName Dict.79 Dict.465 Dict.467 Dict.1009 Dict.468;
            jump Dict.897 Dict.896;
        else
            let Dict.898 : U64 = 0i64;
            let Dict.896 : {U64, U64, U64} = CallByName Dict.78 Dict.465 Dict.465 Dict.465 Dict.467 Dict.898 Dict.468;
            jump Dict.897 Dict.896;

procedure Dict.78 (#Derived_gen.47, #Derived_gen.48, #Derived_gen.49, #Derived_gen.50, #Derived_gen.51, #Derived_gen.52):
    joinpoint Dict.899 Dict.473 Dict.474 Dict.475 Dict.476 Dict.477 Dict.478:
        inc 6 Dict.476;
        let Dict.1006 : U64 = CallByName Dict.86 Dict.476 Dict.477;
        let Dict.1007 : U64 = CallByName Dict.81;
        let Dict.1001 : U64 = CallByName Num.70 Dict.1006 Dict.1007;
        let Dict.1005 : U64 = 8i64;
        let Dict.1004 : U64 = CallByName Num.51 Dict.477 Dict.1005;
        let Dict.1003 : U64 = CallByName Dict.86 Dict.476 Dict.1004;
        let Dict.1002 : U64 = CallByName Num.70 Dict.1003 Dict.473;
        let Dict.479 : U64 = CallByName Dict.84 Dict.1001 Dict.1002;
        let Dict.1000 : U64 = 16i64;
        let Dict.999 : U64 = CallByName Num.51 Dict.477 Dict.1000;
        let Dict.996 : U64 = CallByName Dict.86 Dict.476 Dict.999;
        let Dict.997 : U64 = CallByName Dict.82;
        let Dict.991 : U64 = CallByName Num.70 Dict.996 Dict.997;
        let Dict.995 : U64 = 24i64;
        let Dict.994 : U64 = CallByName Num.51 Dict.477 Dict.995;
        let Dict.993 : U64 = CallByName Dict.86 Dict.476 Dict.994;
        let Dict.992 : U64 = CallByName Num.70 Dict.993 Dict.474;
        let Dict.480 : U64 = CallByName Dict.84 Dict.991 Dict.992;
        let Dict.990 : U64 = 32i64;
        let Dict.989 : U64 = CallByName Num.51 Dict.477 Dict.990;
        let Dict.986 : U64 = CallByName Dict.86 Dict.476 Dict.989;
        let Dict.987 : U64 = CallByName Dict.83;
        let Dict.981 : U64 = CallByName Num.70 Dict.986 Dict.987;
        let Dict.985 : U64 = 40i64;
        let Dict.984 : U64 = CallByName Num.51 Dict.477 Dict.985;
        let Dict.983 : U64 = CallByName Dict.86 Dict.476 Dict.984;
        let Dict.982 : U64 = CallByName Num.70 Dict.983 Dict.475;
        let Dict.481 : U64 = CallByName Dict.84 Dict.981 Dict.982;
        let Dict.980 : U64 = 48i64;
        let Dict.482 : U64 = CallByName Num.75 Dict.478 Dict.980;
        let Dict.979 : U64 = 48i64;
        let Dict.483 : U64 = CallByName Num.51 Dict.477 Dict.979;
        let Dict.978 : U64 = 48i64;
        let Dict.976 : Int1 = CallByName Num.24 Dict.482 Dict.978;
        if Dict.976 then
            jump Dict.899 Dict.479 Dict.480 Dict.481 Dict.476 Dict.483 Dict.482;
        else
            let Dict.975 : U64 = 16i64;
            let Dict.950 : Int1 = CallByName Num.24 Dict.482 Dict.975;
            if Dict.950 then
                let Dict.974 : U64 = CallByName Num.70 Dict.480 Dict.479;
                let Dict.484 : U64 = CallByName Num.70 Dict.481 Dict.974;
                let Dict.951 : {U64, U64, U64} = CallByName Dict.79 Dict.484 Dict.476 Dict.483 Dict.482;
                ret Dict.951;
            else
                inc Dict.476;
                let Dict.949 : U64 = CallByName Num.70 Dict.480 Dict.479;
                let Dict.485 : U64 = CallByName Num.70 Dict.481 Dict.949;
                let Dict.948 : U64 = 16i64;
                let Dict.947 : U64 = CallByName Num.75 Dict.482 Dict.948;
                let Dict.946 : U64 = CallByName Num.51 Dict.947 Dict.483;
                let Dict.901 : U64 = CallByName Dict.86 Dict.476 Dict.946;
                let Dict.945 : U64 = 8i64;
                let Dict.944 : U64 = CallByName Num.75 Dict.482 Dict.945;
                let Dict.903 : U64 = CallByName Num.51 Dict.944 Dict.483;
                let Dict.902 : U64 = CallByName Dict.86 Dict.476 Dict.903;
                let Dict.900 : {U64, U64, U64} = Struct {Dict.901, Dict.902, Dict.485};
                ret Dict.900;
    in
    jump Dict.899 #Derived_gen.47 #Derived_gen.48 #Derived_gen.49 #Derived_gen.50 #Derived_gen.51 #Derived_gen.52;

procedure Dict.79 (#Derived_gen.55, #Derived_gen.56, #Derived_gen.57, #Derived_gen.58):
    joinpoint Dict.952 Dict.486 Dict.487 Dict.488 Dict.489:
        inc 2 Dict.487;
        let Dict.972 : U64 = CallByName Dict.86 Dict.487 Dict.488;
        let Dict.973 : U64 = CallByName Dict.81;
        let Dict.967 : U64 = CallByName Num.70 Dict.972 Dict.973;
        let Dict.971 : U64 = 8i64;
        let Dict.970 : U64 = CallByName Num.51 Dict.488 Dict.971;
        let Dict.969 : U64 = CallByName Dict.86 Dict.487 Dict.970;
        let Dict.968 : U64 = CallByName Num.70 Dict.969 Dict.486;
        let Dict.490 : U64 = CallByName Dict.84 Dict.967 Dict.968;
        let Dict.966 : U64 = 16i64;
        let Dict.491 : U64 = CallByName Num.75 Dict.489 Dict.966;
        let Dict.965 : U64 = 16i64;
        let Dict.492 : U64 = CallByName Num.51 Dict.488 Dict.965;
        let Dict.964 : U64 = 16i64;
        let Dict.954 : Int1 = CallByName Num.23 Dict.491 Dict.964;
        if Dict.954 then
            inc Dict.487;
            let Dict.963 : U64 = 16i64;
            let Dict.962 : U64 = CallByName Num.75 Dict.491 Dict.963;
            let Dict.961 : U64 = CallByName Num.51 Dict.962 Dict.492;
            let Dict.956 : U64 = CallByName Dict.86 Dict.487 Dict.961;
            let Dict.960 : U64 = 8i64;
            let Dict.959 : U64 = CallByName Num.75 Dict.491 Dict.960;
            let Dict.958 : U64 = CallByName Num.51 Dict.959 Dict.492;
            let Dict.957 : U64 = CallByName Dict.86 Dict.487 Dict.958;
            let Dict.955 : {U64, U64, U64} = Struct {Dict.956, Dict.957, Dict.490};
            ret Dict.955;
        else
            jump Dict.952 Dict.490 Dict.487 Dict.492 Dict.491;
    in
    jump Dict.952 #Derived_gen.55 #Derived_gen.56 #Derived_gen.57 #Derived_gen.58;

procedure Dict.8 (Dict.204, Dict.205, Dict.206):
    joinpoint Dict.799 Dict.797:
        let Dict.207 : List {U32, U32} = StructAtIndex 0 Dict.797;
        let Dict.208 : List {Str, I64} = StructAtIndex 1 Dict.797;
        let Dict.209 : U64 = StructAtIndex 2 Dict.797;
        let Dict.210 : Float32 = StructAtIndex 3 Dict.797;
        let Dict.211 : U8 = StructAtIndex 4 Dict.797;
        inc Dict.205;
        let Dict.212 : U64 = CallByName Dict.65 Dict.205;
        let Dict.213 : U32 = CallByName Dict.66 Dict.212;
        let Dict.214 : U64 = CallByName Dict.67 Dict.212 Dict.211;
        let Dict.704 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.37 Dict.207 Dict.208 Dict.214 Dict.213 Dict.205 Dict.206 Dict.209 Dict.210 Dict.211;
        ret Dict.704;
    in
    inc 2 Dict.204;
    let Dict.857 : U64 = CallByName Dict.4 Dict.204;
    let Dict.858 : U64 = CallByName Dict.20 Dict.204;
    let Dict.856 : Int1 = CallByName Num.22 Dict.857 Dict.858;
    if Dict.856 then
        jump Dict.799 Dict.204;
    else
        let Dict.798 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.55 Dict.204;
        jump Dict.799 Dict.798;

procedure Dict.80 ():
    let Dict.888 : U64 = 11562461410679940143i64;
    ret Dict.888;

procedure Dict.81 ():
    let Dict.884 : U64 = 16646288086500911323i64;
    ret Dict.884;

procedure Dict.82 ():
    let Dict.998 : U64 = 10285213230658275043i64;
    ret Dict.998;

procedure Dict.83 ():
    let Dict.988 : U64 = 6384245875588680899i64;
    ret Dict.988;

procedure Dict.84 (Dict.493, Dict.494):
    let Dict.876 : {U64, U64} = CallByName Dict.85 Dict.493 Dict.494;
    let Dict.495 : U64 = StructAtIndex 0 Dict.876;
    let Dict.496 : U64 = StructAtIndex 1 Dict.876;
    let Dict.875 : U64 = CallByName Num.70 Dict.495 Dict.496;
    ret Dict.875;

procedure Dict.85 (Dict.497, Dict.498):
    let Dict.880 : U128 = CallByName Num.135 Dict.497;
    let Dict.881 : U128 = CallByName Num.135 Dict.498;
    let Dict.499 : U128 = CallByName Num.21 Dict.880 Dict.881;
    let Dict.500 : U64 = CallByName Num.133 Dict.499;
    let Dict.879 : U8 = 64i64;
    let Dict.878 : U128 = CallByName Num.74 Dict.499 Dict.879;
    let Dict.501 : U64 = CallByName Num.133 Dict.878;
    let Dict.877 : {U64, U64} = Struct {Dict.500, Dict.501};
    ret Dict.877;

procedure Dict.86 (Dict.502, Dict.503):
    let Dict.943 : U8 = CallByName Dict.22 Dict.502 Dict.503;
    let Dict.504 : U64 = CallByName Num.133 Dict.943;
    let Dict.942 : U64 = 1i64;
    let Dict.941 : U64 = CallByName Num.51 Dict.503 Dict.942;
    let Dict.940 : U8 = CallByName Dict.22 Dict.502 Dict.941;
    let Dict.505 : U64 = CallByName Num.133 Dict.940;
    let Dict.939 : U64 = 2i64;
    let Dict.938 : U64 = CallByName Num.51 Dict.503 Dict.939;
    let Dict.937 : U8 = CallByName Dict.22 Dict.502 Dict.938;
    let Dict.506 : U64 = CallByName Num.133 Dict.937;
    let Dict.936 : U64 = 3i64;
    let Dict.935 : U64 = CallByName Num.51 Dict.503 Dict.936;
    let Dict.934 : U8 = CallByName Dict.22 Dict.502 Dict.935;
    let Dict.507 : U64 = CallByName Num.133 Dict.934;
    let Dict.933 : U64 = 4i64;
    let Dict.932 : U64 = CallByName Num.51 Dict.503 Dict.933;
    let Dict.931 : U8 = CallByName Dict.22 Dict.502 Dict.932;
    let Dict.508 : U64 = CallByName Num.133 Dict.931;
    let Dict.930 : U64 = 5i64;
    let Dict.929 : U64 = CallByName Num.51 Dict.503 Dict.930;
    let Dict.928 : U8 = CallByName Dict.22 Dict.502 Dict.929;
    let Dict.509 : U64 = CallByName Num.133 Dict.928;
    let Dict.927 : U64 = 6i64;
    let Dict.926 : U64 = CallByName Num.51 Dict.503 Dict.927;
    let Dict.925 : U8 = CallByName Dict.22 Dict.502 Dict.926;
    let Dict.510 : U64 = CallByName Num.133 Dict.925;
    let Dict.924 : U64 = 7i64;
    let Dict.922 : U64 = CallByName Num.51 Dict.503 Dict.924;
    let Dict.921 : U8 = CallByName Dict.22 Dict.502 Dict.922;
    dec Dict.502;
    let Dict.511 : U64 = CallByName Num.133 Dict.921;
    let Dict.920 : U8 = 8i64;
    let Dict.919 : U64 = CallByName Num.72 Dict.505 Dict.920;
    let Dict.512 : U64 = CallByName Num.71 Dict.504 Dict.919;
    let Dict.918 : U8 = 16i64;
    let Dict.915 : U64 = CallByName Num.72 Dict.506 Dict.918;
    let Dict.917 : U8 = 24i64;
    let Dict.916 : U64 = CallByName Num.72 Dict.507 Dict.917;
    let Dict.513 : U64 = CallByName Num.71 Dict.915 Dict.916;
    let Dict.914 : U8 = 32i64;
    let Dict.911 : U64 = CallByName Num.72 Dict.508 Dict.914;
    let Dict.913 : U8 = 40i64;
    let Dict.912 : U64 = CallByName Num.72 Dict.509 Dict.913;
    let Dict.514 : U64 = CallByName Num.71 Dict.911 Dict.912;
    let Dict.910 : U8 = 48i64;
    let Dict.907 : U64 = CallByName Num.72 Dict.510 Dict.910;
    let Dict.909 : U8 = 56i64;
    let Dict.908 : U64 = CallByName Num.72 Dict.511 Dict.909;
    let Dict.515 : U64 = CallByName Num.71 Dict.907 Dict.908;
    let Dict.905 : U64 = CallByName Num.71 Dict.512 Dict.513;
    let Dict.906 : U64 = CallByName Num.71 Dict.514 Dict.515;
    let Dict.904 : U64 = CallByName Num.71 Dict.905 Dict.906;
    ret Dict.904;

procedure Dict.87 (Dict.516, Dict.517):
    let Dict.1055 : U8 = CallByName Dict.22 Dict.516 Dict.517;
    let Dict.518 : U64 = CallByName Num.133 Dict.1055;
    let Dict.1054 : U64 = 1i64;
    let Dict.1053 : U64 = CallByName Num.51 Dict.517 Dict.1054;
    let Dict.1052 : U8 = CallByName Dict.22 Dict.516 Dict.1053;
    let Dict.519 : U64 = CallByName Num.133 Dict.1052;
    let Dict.1051 : U64 = 2i64;
    let Dict.1050 : U64 = CallByName Num.51 Dict.517 Dict.1051;
    let Dict.1049 : U8 = CallByName Dict.22 Dict.516 Dict.1050;
    let Dict.520 : U64 = CallByName Num.133 Dict.1049;
    let Dict.1048 : U64 = 3i64;
    let Dict.1047 : U64 = CallByName Num.51 Dict.517 Dict.1048;
    let Dict.1046 : U8 = CallByName Dict.22 Dict.516 Dict.1047;
    dec Dict.516;
    let Dict.521 : U64 = CallByName Num.133 Dict.1046;
    let Dict.1045 : U8 = 8i64;
    let Dict.1044 : U64 = CallByName Num.72 Dict.519 Dict.1045;
    let Dict.522 : U64 = CallByName Num.71 Dict.518 Dict.1044;
    let Dict.1043 : U8 = 16i64;
    let Dict.1040 : U64 = CallByName Num.72 Dict.520 Dict.1043;
    let Dict.1042 : U8 = 24i64;
    let Dict.1041 : U64 = CallByName Num.72 Dict.521 Dict.1042;
    let Dict.523 : U64 = CallByName Num.71 Dict.1040 Dict.1041;
    let Dict.1039 : U64 = CallByName Num.71 Dict.522 Dict.523;
    ret Dict.1039;

procedure Dict.88 (Dict.524, Dict.525, Dict.526):
    let Dict.1033 : U8 = CallByName Dict.22 Dict.524 Dict.525;
    let Dict.527 : U64 = CallByName Num.133 Dict.1033;
    let Dict.1032 : U8 = 1i64;
    let Dict.1031 : U64 = CallByName Num.74 Dict.526 Dict.1032;
    let Dict.1030 : U64 = CallByName Num.51 Dict.1031 Dict.525;
    let Dict.1029 : U8 = CallByName Dict.22 Dict.524 Dict.1030;
    let Dict.528 : U64 = CallByName Num.133 Dict.1029;
    let Dict.1028 : U64 = 1i64;
    let Dict.1027 : U64 = CallByName Num.75 Dict.526 Dict.1028;
    let Dict.1026 : U64 = CallByName Num.51 Dict.1027 Dict.525;
    let Dict.1025 : U8 = CallByName Dict.22 Dict.524 Dict.1026;
    dec Dict.524;
    let Dict.529 : U64 = CallByName Num.133 Dict.1025;
    let Dict.1024 : U8 = 16i64;
    let Dict.1021 : U64 = CallByName Num.72 Dict.527 Dict.1024;
    let Dict.1023 : U8 = 8i64;
    let Dict.1022 : U64 = CallByName Num.72 Dict.528 Dict.1023;
    let Dict.530 : U64 = CallByName Num.71 Dict.1021 Dict.1022;
    let Dict.1020 : U64 = CallByName Num.71 Dict.530 Dict.529;
    ret Dict.1020;

procedure Hash.19 (Hash.39, Hash.40):
    let Hash.77 : List U8 = CallByName Str.12 Hash.40;
    let Hash.76 : {U64, U64} = CallByName Dict.77 Hash.39 Hash.77;
    ret Hash.76;

procedure Inspect.188 (Inspect.189, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.186 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.184 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.359 : Str = "{";
    let Inspect.332 : Str = CallByName Inspect.61 Inspect.189 Inspect.359;
    let Inspect.333 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.184, Inspect.185, Inspect.186, Inspect.187};
    let Inspect.328 : {Str, Int1} = CallByName Inspect.190 Inspect.332 Inspect.333;
    let Inspect.329 : {} = Struct {};
    let Inspect.324 : Str = CallByName Inspect.202 Inspect.328;
    let Inspect.325 : Str = "}";
    let Inspect.323 : Str = CallByName Inspect.61 Inspect.324 Inspect.325;
    ret Inspect.323;

procedure Inspect.190 (Inspect.191, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.186 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.184 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.358 : Int1 = CallByName Bool.1;
    let Inspect.336 : {Str, Int1} = Struct {Inspect.191, Inspect.358};
    let Inspect.337 : {{}, {}} = Struct {Inspect.186, Inspect.187};
    let Inspect.335 : {Str, Int1} = CallByName Dict.10 Inspect.184 Inspect.336 Inspect.337;
    ret Inspect.335;

procedure Inspect.192 (Inspect.338, Inspect.195, Inspect.196, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.186 : {} = StructAtIndex 0 #Attr.12;
    let Inspect.193 : Str = StructAtIndex 0 Inspect.338;
    let Inspect.194 : Int1 = StructAtIndex 1 Inspect.338;
    joinpoint Inspect.356 Inspect.197:
        let Inspect.353 : Str = CallByName Inspect.44 Inspect.195;
        let Inspect.351 : Str = CallByName Inspect.31 Inspect.353 Inspect.197;
        let Inspect.352 : Str = ": ";
        let Inspect.345 : Str = CallByName Inspect.61 Inspect.351 Inspect.352;
        let Inspect.346 : {I64, {}} = Struct {Inspect.196, Inspect.187};
        let Inspect.341 : Str = CallByName Inspect.198 Inspect.345 Inspect.346;
        let Inspect.342 : {} = Struct {};
        let Inspect.340 : {Str, Int1} = CallByName Inspect.200 Inspect.341;
        ret Inspect.340;
    in
    if Inspect.194 then
        let Inspect.357 : Str = ", ";
        let Inspect.355 : Str = CallByName Inspect.61 Inspect.193 Inspect.357;
        jump Inspect.356 Inspect.355;
    else
        jump Inspect.356 Inspect.193;

procedure Inspect.198 (Inspect.199, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.196 : I64 = StructAtIndex 0 #Attr.12;
    let Inspect.349 : I64 = CallByName Inspect.54 Inspect.196;
    let Inspect.348 : Str = CallByName Inspect.31 Inspect.349 Inspect.199;
    ret Inspect.348;

procedure Inspect.200 (Inspect.201):
    let Inspect.344 : Int1 = CallByName Bool.2;
    let Inspect.343 : {Str, Int1} = Struct {Inspect.201, Inspect.344};
    ret Inspect.343;

procedure Inspect.202 (Inspect.330):
    let Inspect.331 : Str = StructAtIndex 0 Inspect.330;
    ret Inspect.331;

procedure Inspect.251 (Inspect.252, Inspect.250):
    let Inspect.374 : Str = "\"";
    let Inspect.373 : Str = CallByName Inspect.61 Inspect.252 Inspect.374;
    let Inspect.371 : Str = CallByName Inspect.61 Inspect.373 Inspect.250;
    let Inspect.372 : Str = "\"";
    let Inspect.370 : Str = CallByName Inspect.61 Inspect.371 Inspect.372;
    ret Inspect.370;

procedure Inspect.279 (Inspect.280, Inspect.278):
    let Inspect.365 : Str = CallByName Num.96 Inspect.278;
    let Inspect.364 : Str = CallByName Inspect.61 Inspect.280 Inspect.365;
    ret Inspect.364;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.31 (Inspect.307, Inspect.150):
    let Inspect.318 : Str = CallByName Inspect.188 Inspect.150 Inspect.307;
    ret Inspect.318;

procedure Inspect.31 (Inspect.307, Inspect.150):
    let Inspect.350 : Str = CallByName Inspect.279 Inspect.150 Inspect.307;
    ret Inspect.350;

procedure Inspect.31 (Inspect.307, Inspect.150):
    let Inspect.354 : Str = CallByName Inspect.251 Inspect.150 Inspect.307;
    ret Inspect.354;

procedure Inspect.34 (Inspect.153):
    let Inspect.309 : Str = CallByName Inspect.5 Inspect.153;
    let Inspect.308 : Str = CallByName Inspect.62 Inspect.309;
    ret Inspect.308;

procedure Inspect.36 (Inspect.305):
    let Inspect.315 : Str = "";
    ret Inspect.315;

procedure Inspect.39 (Inspect.184, Inspect.185, Inspect.186, Inspect.187):
    let Inspect.320 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.184, Inspect.185, Inspect.186, Inspect.187};
    let Inspect.319 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.30 Inspect.320;
    ret Inspect.319;

procedure Inspect.44 (Inspect.250):
    let Inspect.366 : Str = CallByName Inspect.30 Inspect.250;
    ret Inspect.366;

procedure Inspect.5 (Inspect.151):
    let Inspect.316 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.35 Inspect.151;
    let Inspect.313 : {} = Struct {};
    let Inspect.312 : Str = CallByName Inspect.36 Inspect.313;
    let Inspect.311 : Str = CallByName Dict.113 Inspect.312 Inspect.316;
    ret Inspect.311;

procedure Inspect.54 (Inspect.278):
    let Inspect.360 : I64 = CallByName Inspect.30 Inspect.278;
    ret Inspect.360;

procedure Inspect.61 (Inspect.304, Inspect.300):
    let Inspect.327 : Str = CallByName Str.3 Inspect.304 Inspect.300;
    dec Inspect.300;
    ret Inspect.327;

procedure Inspect.62 (Inspect.306):
    ret Inspect.306;

procedure List.11 (List.135, List.136):
    let List.633 : List {U32, U32} = CallByName List.68 List.136;
    let List.632 : List {U32, U32} = CallByName List.87 List.135 List.136 List.633;
    ret List.632;

procedure List.18 (List.156, List.157, List.158):
    let List.570 : U64 = 0i64;
    let List.571 : U64 = CallByName List.6 List.156;
    let List.569 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.89 List.156 List.157 List.158 List.570 List.571;
    ret List.569;

procedure List.18 (List.156, List.157, List.158):
    let List.636 : U64 = 0i64;
    let List.637 : U64 = CallByName List.6 List.156;
    let List.635 : {Str, Int1} = CallByName List.89 List.156 List.157 List.158 List.636 List.637;
    ret List.635;

procedure List.3 (List.113, List.114, List.115):
    let List.588 : {List {U32, U32}, {U32, U32}} = CallByName List.64 List.113 List.114 List.115;
    let List.587 : List {U32, U32} = StructAtIndex 0 List.588;
    ret List.587;

procedure List.3 (List.113, List.114, List.115):
    let List.595 : {List {Str, I64}, {Str, I64}} = CallByName List.64 List.113 List.114 List.115;
    let List.594 : List {Str, I64} = StructAtIndex 0 List.595;
    let #Derived_gen.70 : {Str, I64} = StructAtIndex 1 List.595;
    dec #Derived_gen.70;
    ret List.594;

procedure List.4 (List.121, List.122):
    let List.608 : U64 = 1i64;
    let List.606 : List {Str, I64} = CallByName List.70 List.121 List.608;
    let List.605 : List {Str, I64} = CallByName List.71 List.606 List.122;
    ret List.605;

procedure List.6 (#Attr.2):
    let List.585 : U64 = lowlevel ListLen #Attr.2;
    ret List.585;

procedure List.6 (#Attr.2):
    let List.634 : U64 = lowlevel ListLen #Attr.2;
    ret List.634;

procedure List.6 (#Attr.2):
    let List.646 : U64 = lowlevel ListLen #Attr.2;
    ret List.646;

procedure List.64 (List.110, List.111, List.112):
    let List.600 : U64 = CallByName List.6 List.110;
    let List.597 : Int1 = CallByName Num.22 List.111 List.600;
    if List.597 then
        let List.598 : {List {Str, I64}, {Str, I64}} = CallByName List.67 List.110 List.111 List.112;
        ret List.598;
    else
        let List.596 : {List {Str, I64}, {Str, I64}} = Struct {List.110, List.112};
        ret List.596;

procedure List.64 (List.110, List.111, List.112):
    let List.604 : U64 = CallByName List.6 List.110;
    let List.602 : Int1 = CallByName Num.22 List.111 List.604;
    if List.602 then
        let List.603 : {List {U32, U32}, {U32, U32}} = CallByName List.67 List.110 List.111 List.112;
        ret List.603;
    else
        let List.601 : {List {U32, U32}, {U32, U32}} = Struct {List.110, List.112};
        ret List.601;

procedure List.66 (#Attr.2, #Attr.3):
    let List.645 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.645;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.592 : {List {U32, U32}, {U32, U32}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.592;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.599 : {List {Str, I64}, {Str, I64}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.599;

procedure List.68 (#Attr.2):
    let List.631 : List {U32, U32} = lowlevel ListWithCapacity #Attr.2;
    ret List.631;

procedure List.70 (#Attr.2, #Attr.3):
    let List.609 : List {Str, I64} = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.609;

procedure List.71 (#Attr.2, #Attr.3):
    let List.607 : List {Str, I64} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.607;

procedure List.71 (#Attr.2, #Attr.3):
    let List.628 : List {U32, U32} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.628;

procedure List.83 (List.165, List.166, List.167):
    let List.611 : U64 = 0i64;
    let List.612 : U64 = CallByName List.6 List.165;
    let List.610 : List {U32, U32} = CallByName List.90 List.165 List.166 List.167 List.611 List.612;
    ret List.610;

procedure List.87 (#Derived_gen.29, #Derived_gen.30, #Derived_gen.31):
    joinpoint List.622 List.137 List.138 List.139:
        let List.630 : U64 = 0i64;
        let List.624 : Int1 = CallByName Num.24 List.138 List.630;
        if List.624 then
            let List.629 : U64 = 1i64;
            let List.626 : U64 = CallByName Num.75 List.138 List.629;
            let List.627 : List {U32, U32} = CallByName List.71 List.139 List.137;
            jump List.622 List.137 List.626 List.627;
        else
            ret List.139;
    in
    jump List.622 #Derived_gen.29 #Derived_gen.30 #Derived_gen.31;

procedure List.89 (#Derived_gen.42, #Derived_gen.43, #Derived_gen.44, #Derived_gen.45, #Derived_gen.46):
    joinpoint List.638 List.159 List.160 List.161 List.162 List.163:
        let List.640 : Int1 = CallByName Num.22 List.162 List.163;
        if List.640 then
            let List.644 : {Str, I64} = CallByName List.66 List.159 List.162;
            inc List.644;
            let List.164 : {Str, Int1} = CallByName Dict.175 List.160 List.644 List.161;
            let List.643 : U64 = 1i64;
            let List.642 : U64 = CallByName Num.51 List.162 List.643;
            jump List.638 List.159 List.164 List.161 List.642 List.163;
        else
            dec List.159;
            ret List.160;
    in
    jump List.638 #Derived_gen.42 #Derived_gen.43 #Derived_gen.44 #Derived_gen.45 #Derived_gen.46;

procedure List.89 (#Derived_gen.9, #Derived_gen.10, #Derived_gen.11, #Derived_gen.12, #Derived_gen.13):
    joinpoint List.572 List.159 List.160 List.161 List.162 List.163:
        let List.574 : Int1 = CallByName Num.22 List.162 List.163;
        if List.574 then
            let List.578 : {Str, I64} = CallByName List.66 List.159 List.162;
            inc List.578;
            let List.164 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.146 List.160 List.578;
            let List.577 : U64 = 1i64;
            let List.576 : U64 = CallByName Num.51 List.162 List.577;
            jump List.572 List.159 List.164 List.161 List.576 List.163;
        else
            dec List.159;
            ret List.160;
    in
    jump List.572 #Derived_gen.9 #Derived_gen.10 #Derived_gen.11 #Derived_gen.12 #Derived_gen.13;

procedure List.90 (#Derived_gen.32, #Derived_gen.33, #Derived_gen.34, #Derived_gen.35, #Derived_gen.36):
    joinpoint List.613 List.168 List.169 List.170 List.171 List.172:
        let List.615 : Int1 = CallByName Num.22 List.171 List.172;
        if List.615 then
            let List.619 : {Str, I64} = CallByName List.66 List.168 List.171;
            inc List.619;
            let List.173 : List {U32, U32} = CallByName Dict.383 List.169 List.619 List.171 List.170;
            let List.618 : U64 = 1i64;
            let List.617 : U64 = CallByName Num.51 List.171 List.618;
            jump List.613 List.168 List.173 List.170 List.617 List.172;
        else
            dec List.168;
            ret List.169;
    in
    jump List.613 #Derived_gen.32 #Derived_gen.33 #Derived_gen.34 #Derived_gen.35 #Derived_gen.36;

procedure Num.131 (#Attr.2):
    let Num.310 : U32 = lowlevel NumIntCast #Attr.2;
    ret Num.310;

procedure Num.133 (#Attr.2):
    let Num.366 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.366;

procedure Num.133 (#Attr.2):
    let Num.367 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.367;

procedure Num.133 (#Attr.2):
    let Num.382 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.382;

procedure Num.135 (#Attr.2):
    let Num.388 : U128 = lowlevel NumIntCast #Attr.2;
    ret Num.388;

procedure Num.137 (#Attr.2):
    let Num.301 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.301;

procedure Num.137 (#Attr.2):
    let Num.307 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.307;

procedure Num.139 (#Attr.2):
    let Num.334 : Float32 = lowlevel NumToFloatCast #Attr.2;
    ret Num.334;

procedure Num.159 (Num.240, Num.241):
    let Num.336 : Int1 = CallByName Num.22 Num.240 Num.241;
    if Num.336 then
        ret Num.240;
    else
        ret Num.241;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.291 : U32 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.291;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.311 : U64 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.311;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.314 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.314;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.327 : Float32 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.327;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.386 : U128 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.386;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.331 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.331;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.461 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.461;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.454 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.454;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.315 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.315;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.457 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.457;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.458 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.458;

procedure Num.50 (#Attr.2):
    let Num.333 : U64 = lowlevel NumFloor #Attr.2;
    ret Num.333;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.460 : U64 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.460;

procedure Num.69 (#Attr.2, #Attr.3):
    let Num.319 : U32 = lowlevel NumBitwiseAnd #Attr.2 #Attr.3;
    ret Num.319;

procedure Num.70 (#Attr.2, #Attr.3):
    let Num.364 : U64 = lowlevel NumBitwiseXor #Attr.2 #Attr.3;
    ret Num.364;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.318 : U32 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.318;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.402 : U64 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.402;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.292 : U32 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.292;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.417 : U64 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.417;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.383 : U128 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.383;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.385 : U64 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.385;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.320 : U32 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.320;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.451 : U64 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.451;

procedure Num.96 (#Attr.2):
    let Num.330 : Str = lowlevel NumToStr #Attr.2;
    ret Num.330;

procedure Num.96 (#Attr.2):
    let Num.459 : Str = lowlevel NumToStr #Attr.2;
    ret Num.459;

procedure Str.12 (#Attr.2):
    let Str.294 : List U8 = lowlevel StrToUtf8 #Attr.2;
    ret Str.294;

procedure Str.3 (#Attr.2, #Attr.3):
    let Str.295 : Str = lowlevel StrConcat #Attr.2 #Attr.3;
    ret Str.295;

procedure Test.0 ():
    let Test.8 : Str = "a";
    let Test.9 : I64 = 1i64;
    let Test.4 : {Str, I64} = Struct {Test.8, Test.9};
    let Test.6 : Str = "b";
    let Test.7 : I64 = 2i64;
    let Test.5 : {Str, I64} = Struct {Test.6, Test.7};
    let Test.3 : List {Str, I64} = Array [Test.4, Test.5];
    let Test.2 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.12 Test.3;
    let Test.1 : Str = CallByName Inspect.34 Test.2;
    ret Test.1;
