procedure Bool.1 ():
    let Bool.32 : Int1 = false;
    ret Bool.32;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.28 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.28;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.29 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.29;

procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.30 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.30;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.24 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.24;

procedure Bool.12 (#Attr.2, #Attr.3):
    let Bool.26 : Int1 = lowlevel NotEq #Attr.2 #Attr.3;
    ret Bool.26;

procedure Bool.2 ():
    let Bool.31 : Int1 = true;
    ret Bool.31;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.25 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.25;

procedure Bool.7 (Bool.19, Bool.20):
    let Bool.27 : Int1 = CallByName Bool.12 Bool.19 Bool.20;
    ret Bool.27;

procedure Dict.1 (Dict.679):
    let Dict.850 : List {U32, U32} = Array [];
    let Dict.851 : List {Str, I64} = Array [];
    let Dict.852 : U64 = 0i64;
    let Dict.41 : Float32 = CallByName Dict.41;
    let Dict.42 : U8 = CallByName Dict.42;
    let Dict.849 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.850, Dict.851, Dict.852, Dict.41, Dict.42};
    ret Dict.849;

procedure Dict.10 (Dict.680, Dict.161, Dict.162):
    let Dict.160 : List {Str, I64} = StructAtIndex 1 Dict.680;
    let #Derived_gen.67 : List {U32, U32} = StructAtIndex 0 Dict.680;
    dec #Derived_gen.67;
    let Dict.1067 : {Str, Int1} = CallByName List.18 Dict.160 Dict.161 Dict.162;
    ret Dict.1067;

procedure Dict.112 (Dict.113, Dict.111):
    let Dict.1064 : {} = Struct {};
    let Dict.1065 : {} = Struct {};
    let Dict.1066 : {} = Struct {};
    let Dict.1063 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.39 Dict.111 Dict.1064 Dict.1065 Dict.1066;
    let Dict.1062 : Str = CallByName Inspect.31 Dict.1063 Dict.113;
    ret Dict.1062;

procedure Dict.12 (Dict.133):
    let Dict.848 : {} = Struct {};
    let Dict.687 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.1 Dict.848;
    let Dict.688 : {} = Struct {};
    let Dict.686 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.18 Dict.133 Dict.687 Dict.688;
    ret Dict.686;

procedure Dict.134 (Dict.135, Dict.689):
    let Dict.136 : Str = StructAtIndex 0 Dict.689;
    let Dict.137 : I64 = StructAtIndex 1 Dict.689;
    let Dict.690 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.8 Dict.135 Dict.136 Dict.137;
    ret Dict.690;

procedure Dict.163 (Dict.164, Dict.1069, Dict.162):
    let Dict.165 : Str = StructAtIndex 0 Dict.1069;
    let Dict.166 : I64 = StructAtIndex 1 Dict.1069;
    let Dict.1071 : {Str, Int1} = CallByName Inspect.192 Dict.164 Dict.165 Dict.166 Dict.162;
    ret Dict.1071;

procedure Dict.20 (Dict.677):
    let Dict.130 : U64 = StructAtIndex 2 Dict.677;
    let #Derived_gen.69 : List {U32, U32} = StructAtIndex 0 Dict.677;
    dec #Derived_gen.69;
    let #Derived_gen.68 : List {Str, I64} = StructAtIndex 1 Dict.677;
    dec #Derived_gen.68;
    let Dict.846 : U64 = CallByName Num.137 Dict.130;
    ret Dict.846;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.725 : {U32, U32} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.725;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.741 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.741;

procedure Dict.22 (#Attr.2, #Attr.3):
    let Dict.910 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret Dict.910;

procedure Dict.23 (#Attr.2):
    let Dict.779 : U64 = lowlevel DictPseudoSeed #Attr.2;
    ret Dict.779;

procedure Dict.34 (Dict.111):
    let Dict.1059 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Inspect.30 Dict.111;
    ret Dict.1059;

procedure Dict.36 (#Derived_gen.18, #Derived_gen.19, #Derived_gen.20, #Derived_gen.21, #Derived_gen.22, #Derived_gen.23, #Derived_gen.24, #Derived_gen.25, #Derived_gen.26):
    joinpoint Dict.692 Dict.203 Dict.204 Dict.205 Dict.206 Dict.207 Dict.208 Dict.209 Dict.210 Dict.211:
        let Dict.744 : U64 = CallByName Num.137 Dict.205;
        let Dict.212 : {U32, U32} = CallByName Dict.22 Dict.203 Dict.744;
        let Dict.743 : U32 = StructAtIndex 1 Dict.212;
        let Dict.731 : Int1 = CallByName Bool.11 Dict.206 Dict.743;
        if Dict.731 then
            let Dict.742 : U32 = StructAtIndex 0 Dict.212;
            let Dict.740 : U64 = CallByName Num.137 Dict.742;
            let Dict.739 : {Str, I64} = CallByName Dict.22 Dict.204 Dict.740;
            let Dict.213 : Str = StructAtIndex 0 Dict.739;
            let Dict.734 : Int1 = CallByName Bool.11 Dict.213 Dict.207;
            if Dict.734 then
                let Dict.738 : U32 = StructAtIndex 0 Dict.212;
                let Dict.736 : U64 = CallByName Num.137 Dict.738;
                let Dict.737 : {Str, I64} = Struct {Dict.207, Dict.208};
                let Dict.214 : List {Str, I64} = CallByName List.3 Dict.204 Dict.736 Dict.737;
                let Dict.735 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.203, Dict.214, Dict.209, Dict.210, Dict.211};
                ret Dict.735;
            else
                let Dict.733 : U64 = CallByName List.6 Dict.203;
                let Dict.215 : U64 = CallByName Dict.63 Dict.205 Dict.733;
                let Dict.216 : U32 = CallByName Dict.45 Dict.206;
                jump Dict.692 Dict.203 Dict.204 Dict.215 Dict.216 Dict.207 Dict.208 Dict.209 Dict.210 Dict.211;
        else
            let Dict.730 : U32 = StructAtIndex 1 Dict.212;
            let Dict.706 : Int1 = CallByName Num.24 Dict.206 Dict.730;
            if Dict.706 then
                let Dict.729 : {Str, I64} = Struct {Dict.207, Dict.208};
                let Dict.217 : List {Str, I64} = CallByName List.4 Dict.204 Dict.729;
                let Dict.727 : U64 = CallByName List.6 Dict.217;
                let Dict.728 : U64 = 1i64;
                let Dict.218 : U64 = CallByName Num.20 Dict.727 Dict.728;
                let Dict.726 : U32 = CallByName Num.131 Dict.218;
                let Dict.708 : {U32, U32} = Struct {Dict.726, Dict.206};
                let Dict.219 : List {U32, U32} = CallByName Dict.62 Dict.203 Dict.708 Dict.205;
                let Dict.707 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.219, Dict.217, Dict.209, Dict.210, Dict.211};
                ret Dict.707;
            else
                let Dict.699 : U64 = CallByName List.6 Dict.203;
                let Dict.220 : U64 = CallByName Dict.63 Dict.205 Dict.699;
                let Dict.221 : U32 = CallByName Dict.45 Dict.206;
                jump Dict.692 Dict.203 Dict.204 Dict.220 Dict.221 Dict.207 Dict.208 Dict.209 Dict.210 Dict.211;
    in
    jump Dict.692 #Derived_gen.18 #Derived_gen.19 #Derived_gen.20 #Derived_gen.21 #Derived_gen.22 #Derived_gen.23 #Derived_gen.24 #Derived_gen.25 #Derived_gen.26;

procedure Dict.371 (Dict.372, Dict.802, Dict.374, Dict.370):
    let Dict.373 : Str = StructAtIndex 0 Dict.802;
    inc Dict.372;
    let Dict.807 : {U64, U32} = CallByName Dict.60 Dict.372 Dict.373 Dict.370;
    let Dict.375 : U64 = StructAtIndex 0 Dict.807;
    let Dict.376 : U32 = StructAtIndex 1 Dict.807;
    let Dict.806 : U32 = CallByName Num.131 Dict.374;
    let Dict.805 : {U32, U32} = Struct {Dict.806, Dict.376};
    let Dict.804 : List {U32, U32} = CallByName Dict.62 Dict.372 Dict.805 Dict.375;
    ret Dict.804;

procedure Dict.38 ():
    let Dict.824 : U32 = 0i64;
    let Dict.825 : U32 = 0i64;
    let Dict.823 : {U32, U32} = Struct {Dict.824, Dict.825};
    ret Dict.823;

procedure Dict.39 ():
    let Dict.697 : U32 = 1i64;
    let Dict.698 : U8 = 8i64;
    let Dict.696 : U32 = CallByName Num.72 Dict.697 Dict.698;
    ret Dict.696;

procedure Dict.4 (Dict.685):
    let Dict.138 : List {Str, I64} = StructAtIndex 1 Dict.685;
    let #Derived_gen.66 : List {U32, U32} = StructAtIndex 0 Dict.685;
    dec #Derived_gen.66;
    let Dict.847 : U64 = CallByName List.6 Dict.138;
    dec Dict.138;
    ret Dict.847;

procedure Dict.40 ():
    let Dict.753 : U32 = CallByName Dict.39;
    let Dict.754 : U32 = 1i64;
    let Dict.752 : U32 = CallByName Num.75 Dict.753 Dict.754;
    ret Dict.752;

procedure Dict.41 ():
    let Dict.856 : Float32 = 0.8f64;
    ret Dict.856;

procedure Dict.42 ():
    let Dict.854 : U8 = 64i64;
    let Dict.855 : U8 = 3i64;
    let Dict.853 : U8 = CallByName Num.20 Dict.854 Dict.855;
    ret Dict.853;

procedure Dict.43 ():
    let Dict.796 : U64 = 1i64;
    let Dict.797 : U8 = 32i64;
    let Dict.795 : U64 = CallByName Num.72 Dict.796 Dict.797;
    ret Dict.795;

procedure Dict.44 ():
    let Dict.794 : U64 = CallByName Dict.43;
    ret Dict.794;

procedure Dict.45 (Dict.281):
    let Dict.695 : U32 = CallByName Dict.39;
    let Dict.694 : U32 = CallByName Num.19 Dict.281 Dict.695;
    ret Dict.694;

procedure Dict.54 (Dict.676):
    let Dict.349 : List {Str, I64} = StructAtIndex 1 Dict.676;
    let Dict.350 : U64 = StructAtIndex 2 Dict.676;
    let Dict.351 : Float32 = StructAtIndex 3 Dict.676;
    let Dict.352 : U8 = StructAtIndex 4 Dict.676;
    let #Derived_gen.71 : List {U32, U32} = StructAtIndex 0 Dict.676;
    dec #Derived_gen.71;
    let Dict.842 : U64 = CallByName Dict.44;
    let Dict.798 : Int1 = CallByName Bool.7 Dict.350 Dict.842;
    if Dict.798 then
        inc Dict.349;
        let Dict.841 : U8 = 1i64;
        let Dict.353 : U8 = CallByName Num.20 Dict.352 Dict.841;
        let Dict.818 : {List {U32, U32}, U64} = CallByName Dict.55 Dict.353 Dict.351;
        let Dict.354 : List {U32, U32} = StructAtIndex 0 Dict.818;
        let Dict.355 : U64 = StructAtIndex 1 Dict.818;
        let Dict.356 : List {U32, U32} = CallByName Dict.59 Dict.354 Dict.349 Dict.353;
        let Dict.799 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = Struct {Dict.356, Dict.349, Dict.355, Dict.351, Dict.353};
        ret Dict.799;
    else
        dec Dict.349;
        let Dict.789 : Str = "Dict hit limit of ";
        let Dict.793 : U64 = CallByName Dict.44;
        let Dict.791 : Str = CallByName Num.96 Dict.793;
        let Dict.792 : Str = " elements. Unable to grow more.";
        let Dict.790 : Str = CallByName Str.3 Dict.791 Dict.792;
        dec Dict.792;
        let Dict.788 : Str = CallByName Str.3 Dict.789 Dict.790;
        dec Dict.790;
        Crash Dict.788

procedure Dict.55 (Dict.357, Dict.358):
    let Dict.359 : U64 = CallByName Dict.58 Dict.357;
    let Dict.834 : U64 = CallByName Dict.44;
    let Dict.828 : Int1 = CallByName Bool.11 Dict.359 Dict.834;
    if Dict.828 then
        let Dict.831 : {U32, U32} = CallByName Dict.38;
        let Dict.833 : U64 = CallByName Dict.44;
        let Dict.832 : U64 = CallByName Num.137 Dict.833;
        let Dict.830 : List {U32, U32} = CallByName List.11 Dict.831 Dict.832;
        let Dict.44 : U64 = CallByName Dict.44;
        let Dict.829 : {List {U32, U32}, U64} = Struct {Dict.830, Dict.44};
        ret Dict.829;
    else
        let Dict.827 : Float32 = CallByName Num.139 Dict.359;
        let Dict.826 : Float32 = CallByName Num.21 Dict.827 Dict.358;
        let Dict.360 : U64 = CallByName Num.50 Dict.826;
        let Dict.821 : {U32, U32} = CallByName Dict.38;
        let Dict.822 : U64 = CallByName Num.137 Dict.359;
        let Dict.820 : List {U32, U32} = CallByName List.11 Dict.821 Dict.822;
        let Dict.819 : {List {U32, U32}, U64} = Struct {Dict.820, Dict.360};
        ret Dict.819;

procedure Dict.58 (Dict.367):
    let Dict.838 : U64 = 1i64;
    let Dict.840 : U8 = 64i64;
    let Dict.839 : U8 = CallByName Num.20 Dict.840 Dict.367;
    let Dict.836 : U64 = CallByName Num.72 Dict.838 Dict.839;
    let Dict.837 : U64 = CallByName Dict.44;
    let Dict.835 : U64 = CallByName Num.159 Dict.836 Dict.837;
    ret Dict.835;

procedure Dict.59 (Dict.368, Dict.369, Dict.370):
    let Dict.800 : List {U32, U32} = CallByName List.83 Dict.369 Dict.368 Dict.370;
    ret Dict.800;

procedure Dict.60 (Dict.377, Dict.378, Dict.379):
    let Dict.380 : U64 = CallByName Dict.64 Dict.378;
    let Dict.381 : U32 = CallByName Dict.65 Dict.380;
    let Dict.382 : U64 = CallByName Dict.66 Dict.380 Dict.379;
    let Dict.808 : {U64, U32} = CallByName Dict.61 Dict.377 Dict.382 Dict.381;
    ret Dict.808;

procedure Dict.61 (#Derived_gen.15, #Derived_gen.16, #Derived_gen.17):
    joinpoint Dict.809 Dict.383 Dict.384 Dict.385:
        let Dict.817 : U64 = CallByName Num.137 Dict.384;
        let Dict.386 : {U32, U32} = CallByName Dict.22 Dict.383 Dict.817;
        let Dict.816 : U32 = StructAtIndex 1 Dict.386;
        let Dict.811 : Int1 = CallByName Num.22 Dict.385 Dict.816;
        if Dict.811 then
            let Dict.815 : U64 = CallByName List.6 Dict.383;
            let Dict.813 : U64 = CallByName Dict.63 Dict.384 Dict.815;
            let Dict.814 : U32 = CallByName Dict.45 Dict.385;
            jump Dict.809 Dict.383 Dict.813 Dict.814;
        else
            dec Dict.383;
            let Dict.810 : {U64, U32} = Struct {Dict.384, Dict.385};
            ret Dict.810;
    in
    jump Dict.809 #Derived_gen.15 #Derived_gen.16 #Derived_gen.17;

procedure Dict.62 (#Derived_gen.12, #Derived_gen.13, #Derived_gen.14):
    joinpoint Dict.709 Dict.387 Dict.388 Dict.389:
        let Dict.724 : U64 = CallByName Num.137 Dict.389;
        let Dict.390 : {U32, U32} = CallByName Dict.22 Dict.387 Dict.724;
        let Dict.722 : U32 = StructAtIndex 1 Dict.390;
        let Dict.723 : U32 = 0i64;
        let Dict.712 : Int1 = CallByName Bool.7 Dict.722 Dict.723;
        if Dict.712 then
            let Dict.721 : U64 = CallByName Num.137 Dict.389;
            let Dict.720 : {List {U32, U32}, {U32, U32}} = CallByName List.64 Dict.387 Dict.721 Dict.388;
            let Dict.392 : List {U32, U32} = StructAtIndex 0 Dict.720;
            let Dict.394 : {U32, U32} = StructAtIndex 1 Dict.720;
            let Dict.717 : U32 = StructAtIndex 0 Dict.394;
            let Dict.718 : U32 = StructAtIndex 1 Dict.394;
            let Dict.719 : U32 = CallByName Dict.45 Dict.718;
            let Dict.714 : {U32, U32} = Struct {Dict.717, Dict.719};
            let Dict.716 : U64 = CallByName List.6 Dict.392;
            let Dict.715 : U64 = CallByName Dict.63 Dict.389 Dict.716;
            jump Dict.709 Dict.392 Dict.714 Dict.715;
        else
            let Dict.711 : U64 = CallByName Num.137 Dict.389;
            let Dict.710 : List {U32, U32} = CallByName List.3 Dict.387 Dict.711 Dict.388;
            ret Dict.710;
    in
    jump Dict.709 #Derived_gen.12 #Derived_gen.13 #Derived_gen.14;

procedure Dict.63 (Dict.395, Dict.396):
    let Dict.705 : U64 = 1i64;
    let Dict.704 : U64 = CallByName Num.51 Dict.395 Dict.705;
    let Dict.701 : Int1 = CallByName Bool.7 Dict.704 Dict.396;
    if Dict.701 then
        let Dict.703 : U64 = 1i64;
        let Dict.702 : U64 = CallByName Num.51 Dict.395 Dict.703;
        ret Dict.702;
    else
        let Dict.700 : U64 = 0i64;
        ret Dict.700;

procedure Dict.64 (Dict.397):
    let Dict.759 : [C , C U64] = TagId(0) ;
    let Dict.758 : {U64, U64} = CallByName Dict.67 Dict.759;
    let Dict.756 : {U64, U64} = CallByName Hash.19 Dict.758 Dict.397;
    let Dict.755 : U64 = CallByName Dict.70 Dict.756;
    ret Dict.755;

procedure Dict.65 (Dict.399):
    let Dict.750 : U32 = CallByName Num.131 Dict.399;
    let Dict.751 : U32 = CallByName Dict.40;
    let Dict.748 : U32 = CallByName Num.69 Dict.750 Dict.751;
    let Dict.749 : U32 = CallByName Dict.39;
    let Dict.747 : U32 = CallByName Num.71 Dict.748 Dict.749;
    ret Dict.747;

procedure Dict.66 (Dict.400, Dict.401):
    let Dict.746 : U64 = CallByName Num.74 Dict.400 Dict.401;
    let Dict.745 : U64 = CallByName Num.137 Dict.746;
    ret Dict.745;

procedure Dict.67 (Dict.402):
    joinpoint Dict.776 Dict.403:
        let Dict.761 : U64 = CallByName Dict.69 Dict.403;
        let Dict.760 : {U64, U64} = Struct {Dict.761, Dict.403};
        ret Dict.760;
    in
    let Dict.781 : U8 = 0i64;
    let Dict.782 : U8 = GetTagId Dict.402;
    let Dict.783 : Int1 = lowlevel Eq Dict.781 Dict.782;
    if Dict.783 then
        let Dict.778 : {} = Struct {};
        let Dict.777 : U64 = CallByName Dict.23 Dict.778;
        jump Dict.776 Dict.777;
    else
        let Dict.404 : U64 = UnionAtIndex (Id 1) (Index 0) Dict.402;
        jump Dict.776 Dict.404;

procedure Dict.68 (Dict.666, Dict.667):
    let Dict.407 : U64 = StructAtIndex 0 Dict.667;
    let Dict.408 : U64 = StructAtIndex 1 Dict.667;
    let Dict.410 : U64 = StructAtIndex 2 Dict.667;
    let Dict.409 : U64 = StructAtIndex 3 Dict.667;
    let Dict.405 : U64 = StructAtIndex 0 Dict.666;
    let Dict.406 : U64 = StructAtIndex 1 Dict.666;
    let Dict.878 : U64 = CallByName Dict.80;
    let Dict.876 : U64 = CallByName Num.70 Dict.407 Dict.878;
    let Dict.877 : U64 = CallByName Num.70 Dict.408 Dict.409;
    let Dict.411 : {U64, U64} = CallByName Dict.84 Dict.876 Dict.877;
    let Dict.873 : U64 = StructAtIndex 0 Dict.411;
    let Dict.874 : U64 = CallByName Dict.79;
    let Dict.872 : U64 = CallByName Num.70 Dict.873 Dict.874;
    let Dict.412 : U64 = CallByName Num.70 Dict.872 Dict.410;
    let Dict.869 : U64 = StructAtIndex 1 Dict.411;
    let Dict.870 : U64 = CallByName Dict.80;
    let Dict.413 : U64 = CallByName Num.70 Dict.869 Dict.870;
    let Dict.414 : U64 = CallByName Dict.83 Dict.412 Dict.413;
    let Dict.861 : U64 = CallByName Dict.83 Dict.406 Dict.414;
    let Dict.860 : {U64, U64} = Struct {Dict.405, Dict.861};
    ret Dict.860;

procedure Dict.69 (Dict.415):
    let Dict.774 : U64 = CallByName Dict.79;
    let Dict.764 : U64 = CallByName Num.70 Dict.415 Dict.774;
    let Dict.765 : U64 = CallByName Dict.80;
    let Dict.763 : U64 = CallByName Dict.83 Dict.764 Dict.765;
    let Dict.762 : U64 = CallByName Num.70 Dict.763 Dict.415;
    ret Dict.762;

procedure Dict.70 (Dict.683):
    let Dict.416 : U64 = StructAtIndex 1 Dict.683;
    ret Dict.416;

procedure Dict.76 (Dict.660, Dict.455):
    let Dict.453 : U64 = StructAtIndex 0 Dict.660;
    let Dict.454 : U64 = StructAtIndex 1 Dict.660;
    let Dict.456 : U64 = CallByName List.6 Dict.455;
    joinpoint Dict.884 Dict.457:
        let Dict.858 : {U64, U64} = Struct {Dict.453, Dict.454};
        let Dict.879 : U64 = StructAtIndex 0 Dict.457;
        let Dict.880 : U64 = StructAtIndex 1 Dict.457;
        let Dict.881 : U64 = CallByName Num.133 Dict.456;
        let Dict.882 : U64 = StructAtIndex 2 Dict.457;
        let Dict.859 : {U64, U64, U64, U64} = Struct {Dict.879, Dict.880, Dict.881, Dict.882};
        let Dict.857 : {U64, U64} = CallByName Dict.68 Dict.858 Dict.859;
        ret Dict.857;
    in
    let Dict.1058 : U64 = 16i64;
    let Dict.998 : Int1 = CallByName Num.23 Dict.456 Dict.1058;
    if Dict.998 then
        joinpoint Dict.1000 Dict.883:
            jump Dict.884 Dict.883;
        in
        let Dict.1057 : U64 = 4i64;
        let Dict.1022 : Int1 = CallByName Num.25 Dict.456 Dict.1057;
        if Dict.1022 then
            let Dict.1056 : U8 = 3i64;
            let Dict.1054 : U64 = CallByName Num.74 Dict.456 Dict.1056;
            let Dict.1055 : U8 = 2i64;
            let Dict.458 : U64 = CallByName Num.72 Dict.1054 Dict.1055;
            let Dict.1053 : U64 = 0i64;
            inc 3 Dict.455;
            let Dict.1051 : U64 = CallByName Dict.86 Dict.455 Dict.1053;
            let Dict.1052 : U8 = 32i64;
            let Dict.1049 : U64 = CallByName Num.72 Dict.1051 Dict.1052;
            let Dict.1050 : U64 = CallByName Dict.86 Dict.455 Dict.458;
            let Dict.459 : U64 = CallByName Num.71 Dict.1049 Dict.1050;
            let Dict.1048 : U64 = 4i64;
            let Dict.1047 : U64 = CallByName Num.75 Dict.456 Dict.1048;
            let Dict.1045 : U64 = CallByName Dict.86 Dict.455 Dict.1047;
            let Dict.1046 : U8 = 32i64;
            let Dict.1023 : U64 = CallByName Num.72 Dict.1045 Dict.1046;
            let Dict.1044 : U64 = 4i64;
            let Dict.1043 : U64 = CallByName Num.75 Dict.456 Dict.1044;
            let Dict.1025 : U64 = CallByName Num.75 Dict.1043 Dict.458;
            let Dict.1024 : U64 = CallByName Dict.86 Dict.455 Dict.1025;
            let Dict.460 : U64 = CallByName Num.71 Dict.1023 Dict.1024;
            let Dict.999 : {U64, U64, U64} = Struct {Dict.459, Dict.460, Dict.453};
            jump Dict.1000 Dict.999;
        else
            let Dict.1021 : U64 = 0i64;
            let Dict.1003 : Int1 = CallByName Num.24 Dict.456 Dict.1021;
            if Dict.1003 then
                let Dict.1006 : U64 = 0i64;
                let Dict.1004 : U64 = CallByName Dict.87 Dict.455 Dict.1006 Dict.456;
                let Dict.1005 : U64 = 0i64;
                let Dict.999 : {U64, U64, U64} = Struct {Dict.1004, Dict.1005, Dict.453};
                jump Dict.1000 Dict.999;
            else
                dec Dict.455;
                let Dict.1001 : U64 = 0i64;
                let Dict.1002 : U64 = 0i64;
                let Dict.999 : {U64, U64, U64} = Struct {Dict.1001, Dict.1002, Dict.453};
                jump Dict.1000 Dict.999;
    else
        let Dict.997 : U64 = 48i64;
        let Dict.995 : Int1 = CallByName Num.23 Dict.456 Dict.997;
        if Dict.995 then
            let Dict.996 : U64 = 0i64;
            let Dict.883 : {U64, U64, U64} = CallByName Dict.78 Dict.453 Dict.455 Dict.996 Dict.456;
            jump Dict.884 Dict.883;
        else
            let Dict.885 : U64 = 0i64;
            let Dict.883 : {U64, U64, U64} = CallByName Dict.77 Dict.453 Dict.453 Dict.453 Dict.455 Dict.885 Dict.456;
            jump Dict.884 Dict.883;

procedure Dict.77 (#Derived_gen.4, #Derived_gen.5, #Derived_gen.6, #Derived_gen.7, #Derived_gen.8, #Derived_gen.9):
    joinpoint Dict.886 Dict.461 Dict.462 Dict.463 Dict.464 Dict.465 Dict.466:
        inc 6 Dict.464;
        let Dict.993 : U64 = CallByName Dict.85 Dict.464 Dict.465;
        let Dict.994 : U64 = CallByName Dict.80;
        let Dict.988 : U64 = CallByName Num.70 Dict.993 Dict.994;
        let Dict.992 : U64 = 8i64;
        let Dict.991 : U64 = CallByName Num.51 Dict.465 Dict.992;
        let Dict.990 : U64 = CallByName Dict.85 Dict.464 Dict.991;
        let Dict.989 : U64 = CallByName Num.70 Dict.990 Dict.461;
        let Dict.467 : U64 = CallByName Dict.83 Dict.988 Dict.989;
        let Dict.987 : U64 = 16i64;
        let Dict.986 : U64 = CallByName Num.51 Dict.465 Dict.987;
        let Dict.983 : U64 = CallByName Dict.85 Dict.464 Dict.986;
        let Dict.984 : U64 = CallByName Dict.81;
        let Dict.978 : U64 = CallByName Num.70 Dict.983 Dict.984;
        let Dict.982 : U64 = 24i64;
        let Dict.981 : U64 = CallByName Num.51 Dict.465 Dict.982;
        let Dict.980 : U64 = CallByName Dict.85 Dict.464 Dict.981;
        let Dict.979 : U64 = CallByName Num.70 Dict.980 Dict.462;
        let Dict.468 : U64 = CallByName Dict.83 Dict.978 Dict.979;
        let Dict.977 : U64 = 32i64;
        let Dict.976 : U64 = CallByName Num.51 Dict.465 Dict.977;
        let Dict.973 : U64 = CallByName Dict.85 Dict.464 Dict.976;
        let Dict.974 : U64 = CallByName Dict.82;
        let Dict.968 : U64 = CallByName Num.70 Dict.973 Dict.974;
        let Dict.972 : U64 = 40i64;
        let Dict.971 : U64 = CallByName Num.51 Dict.465 Dict.972;
        let Dict.970 : U64 = CallByName Dict.85 Dict.464 Dict.971;
        let Dict.969 : U64 = CallByName Num.70 Dict.970 Dict.463;
        let Dict.469 : U64 = CallByName Dict.83 Dict.968 Dict.969;
        let Dict.967 : U64 = 48i64;
        let Dict.470 : U64 = CallByName Num.75 Dict.466 Dict.967;
        let Dict.966 : U64 = 48i64;
        let Dict.471 : U64 = CallByName Num.51 Dict.465 Dict.966;
        let Dict.965 : U64 = 48i64;
        let Dict.963 : Int1 = CallByName Num.24 Dict.470 Dict.965;
        if Dict.963 then
            jump Dict.886 Dict.467 Dict.468 Dict.469 Dict.464 Dict.471 Dict.470;
        else
            let Dict.962 : U64 = 16i64;
            let Dict.937 : Int1 = CallByName Num.24 Dict.470 Dict.962;
            if Dict.937 then
                let Dict.961 : U64 = CallByName Num.70 Dict.468 Dict.467;
                let Dict.472 : U64 = CallByName Num.70 Dict.469 Dict.961;
                let Dict.938 : {U64, U64, U64} = CallByName Dict.78 Dict.472 Dict.464 Dict.471 Dict.470;
                ret Dict.938;
            else
                inc Dict.464;
                let Dict.936 : U64 = CallByName Num.70 Dict.468 Dict.467;
                let Dict.473 : U64 = CallByName Num.70 Dict.469 Dict.936;
                let Dict.935 : U64 = 16i64;
                let Dict.934 : U64 = CallByName Num.75 Dict.470 Dict.935;
                let Dict.933 : U64 = CallByName Num.51 Dict.934 Dict.471;
                let Dict.888 : U64 = CallByName Dict.85 Dict.464 Dict.933;
                let Dict.932 : U64 = 8i64;
                let Dict.931 : U64 = CallByName Num.75 Dict.470 Dict.932;
                let Dict.890 : U64 = CallByName Num.51 Dict.931 Dict.471;
                let Dict.889 : U64 = CallByName Dict.85 Dict.464 Dict.890;
                let Dict.887 : {U64, U64, U64} = Struct {Dict.888, Dict.889, Dict.473};
                ret Dict.887;
    in
    jump Dict.886 #Derived_gen.4 #Derived_gen.5 #Derived_gen.6 #Derived_gen.7 #Derived_gen.8 #Derived_gen.9;

procedure Dict.78 (#Derived_gen.43, #Derived_gen.44, #Derived_gen.45, #Derived_gen.46):
    joinpoint Dict.939 Dict.474 Dict.475 Dict.476 Dict.477:
        inc 2 Dict.475;
        let Dict.959 : U64 = CallByName Dict.85 Dict.475 Dict.476;
        let Dict.960 : U64 = CallByName Dict.80;
        let Dict.954 : U64 = CallByName Num.70 Dict.959 Dict.960;
        let Dict.958 : U64 = 8i64;
        let Dict.957 : U64 = CallByName Num.51 Dict.476 Dict.958;
        let Dict.956 : U64 = CallByName Dict.85 Dict.475 Dict.957;
        let Dict.955 : U64 = CallByName Num.70 Dict.956 Dict.474;
        let Dict.478 : U64 = CallByName Dict.83 Dict.954 Dict.955;
        let Dict.953 : U64 = 16i64;
        let Dict.479 : U64 = CallByName Num.75 Dict.477 Dict.953;
        let Dict.952 : U64 = 16i64;
        let Dict.480 : U64 = CallByName Num.51 Dict.476 Dict.952;
        let Dict.951 : U64 = 16i64;
        let Dict.941 : Int1 = CallByName Num.23 Dict.479 Dict.951;
        if Dict.941 then
            inc Dict.475;
            let Dict.950 : U64 = 16i64;
            let Dict.949 : U64 = CallByName Num.75 Dict.479 Dict.950;
            let Dict.948 : U64 = CallByName Num.51 Dict.949 Dict.480;
            let Dict.943 : U64 = CallByName Dict.85 Dict.475 Dict.948;
            let Dict.947 : U64 = 8i64;
            let Dict.946 : U64 = CallByName Num.75 Dict.479 Dict.947;
            let Dict.945 : U64 = CallByName Num.51 Dict.946 Dict.480;
            let Dict.944 : U64 = CallByName Dict.85 Dict.475 Dict.945;
            let Dict.942 : {U64, U64, U64} = Struct {Dict.943, Dict.944, Dict.478};
            ret Dict.942;
        else
            jump Dict.939 Dict.478 Dict.475 Dict.480 Dict.479;
    in
    jump Dict.939 #Derived_gen.43 #Derived_gen.44 #Derived_gen.45 #Derived_gen.46;

procedure Dict.79 ():
    let Dict.875 : U64 = 11562461410679940143i64;
    ret Dict.875;

procedure Dict.8 (Dict.192, Dict.193, Dict.194):
    joinpoint Dict.786 Dict.784:
        let Dict.195 : List {U32, U32} = StructAtIndex 0 Dict.784;
        let Dict.196 : List {Str, I64} = StructAtIndex 1 Dict.784;
        let Dict.197 : U64 = StructAtIndex 2 Dict.784;
        let Dict.198 : Float32 = StructAtIndex 3 Dict.784;
        let Dict.199 : U8 = StructAtIndex 4 Dict.784;
        inc Dict.193;
        let Dict.200 : U64 = CallByName Dict.64 Dict.193;
        let Dict.201 : U32 = CallByName Dict.65 Dict.200;
        let Dict.202 : U64 = CallByName Dict.66 Dict.200 Dict.199;
        let Dict.691 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.36 Dict.195 Dict.196 Dict.202 Dict.201 Dict.193 Dict.194 Dict.197 Dict.198 Dict.199;
        ret Dict.691;
    in
    inc 2 Dict.192;
    let Dict.844 : U64 = CallByName Dict.4 Dict.192;
    let Dict.845 : U64 = CallByName Dict.20 Dict.192;
    let Dict.843 : Int1 = CallByName Num.22 Dict.844 Dict.845;
    if Dict.843 then
        jump Dict.786 Dict.192;
    else
        let Dict.785 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.54 Dict.192;
        jump Dict.786 Dict.785;

procedure Dict.80 ():
    let Dict.871 : U64 = 16646288086500911323i64;
    ret Dict.871;

procedure Dict.81 ():
    let Dict.985 : U64 = 10285213230658275043i64;
    ret Dict.985;

procedure Dict.82 ():
    let Dict.975 : U64 = 6384245875588680899i64;
    ret Dict.975;

procedure Dict.83 (Dict.481, Dict.482):
    let Dict.863 : {U64, U64} = CallByName Dict.84 Dict.481 Dict.482;
    let Dict.483 : U64 = StructAtIndex 0 Dict.863;
    let Dict.484 : U64 = StructAtIndex 1 Dict.863;
    let Dict.862 : U64 = CallByName Num.70 Dict.483 Dict.484;
    ret Dict.862;

procedure Dict.84 (Dict.485, Dict.486):
    let Dict.867 : U128 = CallByName Num.135 Dict.485;
    let Dict.868 : U128 = CallByName Num.135 Dict.486;
    let Dict.487 : U128 = CallByName Num.21 Dict.867 Dict.868;
    let Dict.488 : U64 = CallByName Num.133 Dict.487;
    let Dict.866 : U8 = 64i64;
    let Dict.865 : U128 = CallByName Num.74 Dict.487 Dict.866;
    let Dict.489 : U64 = CallByName Num.133 Dict.865;
    let Dict.864 : {U64, U64} = Struct {Dict.488, Dict.489};
    ret Dict.864;

procedure Dict.85 (Dict.490, Dict.491):
    let Dict.930 : U8 = CallByName Dict.22 Dict.490 Dict.491;
    let Dict.492 : U64 = CallByName Num.133 Dict.930;
    let Dict.929 : U64 = 1i64;
    let Dict.928 : U64 = CallByName Num.51 Dict.491 Dict.929;
    let Dict.927 : U8 = CallByName Dict.22 Dict.490 Dict.928;
    let Dict.493 : U64 = CallByName Num.133 Dict.927;
    let Dict.926 : U64 = 2i64;
    let Dict.925 : U64 = CallByName Num.51 Dict.491 Dict.926;
    let Dict.924 : U8 = CallByName Dict.22 Dict.490 Dict.925;
    let Dict.494 : U64 = CallByName Num.133 Dict.924;
    let Dict.923 : U64 = 3i64;
    let Dict.922 : U64 = CallByName Num.51 Dict.491 Dict.923;
    let Dict.921 : U8 = CallByName Dict.22 Dict.490 Dict.922;
    let Dict.495 : U64 = CallByName Num.133 Dict.921;
    let Dict.920 : U64 = 4i64;
    let Dict.919 : U64 = CallByName Num.51 Dict.491 Dict.920;
    let Dict.918 : U8 = CallByName Dict.22 Dict.490 Dict.919;
    let Dict.496 : U64 = CallByName Num.133 Dict.918;
    let Dict.917 : U64 = 5i64;
    let Dict.916 : U64 = CallByName Num.51 Dict.491 Dict.917;
    let Dict.915 : U8 = CallByName Dict.22 Dict.490 Dict.916;
    let Dict.497 : U64 = CallByName Num.133 Dict.915;
    let Dict.914 : U64 = 6i64;
    let Dict.913 : U64 = CallByName Num.51 Dict.491 Dict.914;
    let Dict.912 : U8 = CallByName Dict.22 Dict.490 Dict.913;
    let Dict.498 : U64 = CallByName Num.133 Dict.912;
    let Dict.911 : U64 = 7i64;
    let Dict.909 : U64 = CallByName Num.51 Dict.491 Dict.911;
    let Dict.908 : U8 = CallByName Dict.22 Dict.490 Dict.909;
    dec Dict.490;
    let Dict.499 : U64 = CallByName Num.133 Dict.908;
    let Dict.907 : U8 = 8i64;
    let Dict.906 : U64 = CallByName Num.72 Dict.493 Dict.907;
    let Dict.500 : U64 = CallByName Num.71 Dict.492 Dict.906;
    let Dict.905 : U8 = 16i64;
    let Dict.902 : U64 = CallByName Num.72 Dict.494 Dict.905;
    let Dict.904 : U8 = 24i64;
    let Dict.903 : U64 = CallByName Num.72 Dict.495 Dict.904;
    let Dict.501 : U64 = CallByName Num.71 Dict.902 Dict.903;
    let Dict.901 : U8 = 32i64;
    let Dict.898 : U64 = CallByName Num.72 Dict.496 Dict.901;
    let Dict.900 : U8 = 40i64;
    let Dict.899 : U64 = CallByName Num.72 Dict.497 Dict.900;
    let Dict.502 : U64 = CallByName Num.71 Dict.898 Dict.899;
    let Dict.897 : U8 = 48i64;
    let Dict.894 : U64 = CallByName Num.72 Dict.498 Dict.897;
    let Dict.896 : U8 = 56i64;
    let Dict.895 : U64 = CallByName Num.72 Dict.499 Dict.896;
    let Dict.503 : U64 = CallByName Num.71 Dict.894 Dict.895;
    let Dict.892 : U64 = CallByName Num.71 Dict.500 Dict.501;
    let Dict.893 : U64 = CallByName Num.71 Dict.502 Dict.503;
    let Dict.891 : U64 = CallByName Num.71 Dict.892 Dict.893;
    ret Dict.891;

procedure Dict.86 (Dict.504, Dict.505):
    let Dict.1042 : U8 = CallByName Dict.22 Dict.504 Dict.505;
    let Dict.506 : U64 = CallByName Num.133 Dict.1042;
    let Dict.1041 : U64 = 1i64;
    let Dict.1040 : U64 = CallByName Num.51 Dict.505 Dict.1041;
    let Dict.1039 : U8 = CallByName Dict.22 Dict.504 Dict.1040;
    let Dict.507 : U64 = CallByName Num.133 Dict.1039;
    let Dict.1038 : U64 = 2i64;
    let Dict.1037 : U64 = CallByName Num.51 Dict.505 Dict.1038;
    let Dict.1036 : U8 = CallByName Dict.22 Dict.504 Dict.1037;
    let Dict.508 : U64 = CallByName Num.133 Dict.1036;
    let Dict.1035 : U64 = 3i64;
    let Dict.1034 : U64 = CallByName Num.51 Dict.505 Dict.1035;
    let Dict.1033 : U8 = CallByName Dict.22 Dict.504 Dict.1034;
    dec Dict.504;
    let Dict.509 : U64 = CallByName Num.133 Dict.1033;
    let Dict.1032 : U8 = 8i64;
    let Dict.1031 : U64 = CallByName Num.72 Dict.507 Dict.1032;
    let Dict.510 : U64 = CallByName Num.71 Dict.506 Dict.1031;
    let Dict.1030 : U8 = 16i64;
    let Dict.1027 : U64 = CallByName Num.72 Dict.508 Dict.1030;
    let Dict.1029 : U8 = 24i64;
    let Dict.1028 : U64 = CallByName Num.72 Dict.509 Dict.1029;
    let Dict.511 : U64 = CallByName Num.71 Dict.1027 Dict.1028;
    let Dict.1026 : U64 = CallByName Num.71 Dict.510 Dict.511;
    ret Dict.1026;

procedure Dict.87 (Dict.512, Dict.513, Dict.514):
    let Dict.1020 : U8 = CallByName Dict.22 Dict.512 Dict.513;
    let Dict.515 : U64 = CallByName Num.133 Dict.1020;
    let Dict.1019 : U8 = 1i64;
    let Dict.1018 : U64 = CallByName Num.74 Dict.514 Dict.1019;
    let Dict.1017 : U64 = CallByName Num.51 Dict.1018 Dict.513;
    let Dict.1016 : U8 = CallByName Dict.22 Dict.512 Dict.1017;
    let Dict.516 : U64 = CallByName Num.133 Dict.1016;
    let Dict.1015 : U64 = 1i64;
    let Dict.1014 : U64 = CallByName Num.75 Dict.514 Dict.1015;
    let Dict.1013 : U64 = CallByName Num.51 Dict.1014 Dict.513;
    let Dict.1012 : U8 = CallByName Dict.22 Dict.512 Dict.1013;
    dec Dict.512;
    let Dict.517 : U64 = CallByName Num.133 Dict.1012;
    let Dict.1011 : U8 = 16i64;
    let Dict.1008 : U64 = CallByName Num.72 Dict.515 Dict.1011;
    let Dict.1010 : U8 = 8i64;
    let Dict.1009 : U64 = CallByName Num.72 Dict.516 Dict.1010;
    let Dict.518 : U64 = CallByName Num.71 Dict.1008 Dict.1009;
    let Dict.1007 : U64 = CallByName Num.71 Dict.518 Dict.517;
    ret Dict.1007;

procedure Hash.19 (Hash.39, Hash.40):
    let Hash.77 : List U8 = CallByName Str.12 Hash.40;
    let Hash.76 : {U64, U64} = CallByName Dict.76 Hash.39 Hash.77;
    ret Hash.76;

procedure Inspect.188 (Inspect.189, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.186 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.184 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.359 : Str = "{";
    let Inspect.332 : Str = CallByName Inspect.61 Inspect.189 Inspect.359;
    let Inspect.333 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.184, Inspect.185, Inspect.186, Inspect.187};
    let Inspect.328 : {Str, Int1} = CallByName Inspect.190 Inspect.332 Inspect.333;
    let Inspect.329 : {} = Struct {};
    let Inspect.324 : Str = CallByName Inspect.202 Inspect.328;
    let Inspect.325 : Str = "}";
    let Inspect.323 : Str = CallByName Inspect.61 Inspect.324 Inspect.325;
    ret Inspect.323;

procedure Inspect.190 (Inspect.191, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 3 #Attr.12;
    let Inspect.186 : {} = StructAtIndex 2 #Attr.12;
    let Inspect.185 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.184 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = StructAtIndex 0 #Attr.12;
    let Inspect.358 : Int1 = CallByName Bool.1;
    let Inspect.336 : {Str, Int1} = Struct {Inspect.191, Inspect.358};
    let Inspect.337 : {{}, {}} = Struct {Inspect.186, Inspect.187};
    let Inspect.335 : {Str, Int1} = CallByName Dict.10 Inspect.184 Inspect.336 Inspect.337;
    ret Inspect.335;

procedure Inspect.192 (Inspect.338, Inspect.195, Inspect.196, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.186 : {} = StructAtIndex 0 #Attr.12;
    let Inspect.193 : Str = StructAtIndex 0 Inspect.338;
    let Inspect.194 : Int1 = StructAtIndex 1 Inspect.338;
    joinpoint Inspect.356 Inspect.197:
        let Inspect.353 : Str = CallByName Inspect.44 Inspect.195;
        let Inspect.351 : Str = CallByName Inspect.31 Inspect.353 Inspect.197;
        let Inspect.352 : Str = ": ";
        let Inspect.345 : Str = CallByName Inspect.61 Inspect.351 Inspect.352;
        let Inspect.346 : {I64, {}} = Struct {Inspect.196, Inspect.187};
        let Inspect.341 : Str = CallByName Inspect.198 Inspect.345 Inspect.346;
        let Inspect.342 : {} = Struct {};
        let Inspect.340 : {Str, Int1} = CallByName Inspect.200 Inspect.341;
        ret Inspect.340;
    in
    if Inspect.194 then
        let Inspect.357 : Str = ", ";
        let Inspect.355 : Str = CallByName Inspect.61 Inspect.193 Inspect.357;
        jump Inspect.356 Inspect.355;
    else
        jump Inspect.356 Inspect.193;

procedure Inspect.198 (Inspect.199, #Attr.12):
    let Inspect.187 : {} = StructAtIndex 1 #Attr.12;
    let Inspect.196 : I64 = StructAtIndex 0 #Attr.12;
    let Inspect.349 : I64 = CallByName Inspect.54 Inspect.196;
    let Inspect.348 : Str = CallByName Inspect.31 Inspect.349 Inspect.199;
    ret Inspect.348;

procedure Inspect.200 (Inspect.201):
    let Inspect.344 : Int1 = CallByName Bool.2;
    let Inspect.343 : {Str, Int1} = Struct {Inspect.201, Inspect.344};
    ret Inspect.343;

procedure Inspect.202 (Inspect.330):
    let Inspect.331 : Str = StructAtIndex 0 Inspect.330;
    ret Inspect.331;

procedure Inspect.251 (Inspect.252, Inspect.250):
    let Inspect.374 : Str = "\"";
    let Inspect.373 : Str = CallByName Inspect.61 Inspect.252 Inspect.374;
    let Inspect.371 : Str = CallByName Inspect.61 Inspect.373 Inspect.250;
    let Inspect.372 : Str = "\"";
    let Inspect.370 : Str = CallByName Inspect.61 Inspect.371 Inspect.372;
    ret Inspect.370;

procedure Inspect.279 (Inspect.280, Inspect.278):
    let Inspect.365 : Str = CallByName Num.96 Inspect.278;
    let Inspect.364 : Str = CallByName Inspect.61 Inspect.280 Inspect.365;
    ret Inspect.364;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.30 (Inspect.148):
    ret Inspect.148;

procedure Inspect.31 (Inspect.307, Inspect.150):
    let Inspect.318 : Str = CallByName Inspect.188 Inspect.150 Inspect.307;
    ret Inspect.318;

procedure Inspect.31 (Inspect.307, Inspect.150):
    let Inspect.350 : Str = CallByName Inspect.279 Inspect.150 Inspect.307;
    ret Inspect.350;

procedure Inspect.31 (Inspect.307, Inspect.150):
    let Inspect.354 : Str = CallByName Inspect.251 Inspect.150 Inspect.307;
    ret Inspect.354;

procedure Inspect.34 (Inspect.153):
    let Inspect.309 : Str = CallByName Inspect.5 Inspect.153;
    let Inspect.308 : Str = CallByName Inspect.62 Inspect.309;
    ret Inspect.308;

procedure Inspect.36 (Inspect.305):
    let Inspect.315 : Str = "";
    ret Inspect.315;

procedure Inspect.39 (Inspect.184, Inspect.185, Inspect.186, Inspect.187):
    let Inspect.320 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = Struct {Inspect.184, Inspect.185, Inspect.186, Inspect.187};
    let Inspect.319 : {{List {U32, U32}, List {Str, I64}, U64, Float32, U8}, {}, {}, {}} = CallByName Inspect.30 Inspect.320;
    ret Inspect.319;

procedure Inspect.44 (Inspect.250):
    let Inspect.366 : Str = CallByName Inspect.30 Inspect.250;
    ret Inspect.366;

procedure Inspect.5 (Inspect.151):
    let Inspect.316 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.34 Inspect.151;
    let Inspect.313 : {} = Struct {};
    let Inspect.312 : Str = CallByName Inspect.36 Inspect.313;
    let Inspect.311 : Str = CallByName Dict.112 Inspect.312 Inspect.316;
    ret Inspect.311;

procedure Inspect.54 (Inspect.278):
    let Inspect.360 : I64 = CallByName Inspect.30 Inspect.278;
    ret Inspect.360;

procedure Inspect.61 (Inspect.304, Inspect.300):
    let Inspect.327 : Str = CallByName Str.3 Inspect.304 Inspect.300;
    dec Inspect.300;
    ret Inspect.327;

procedure Inspect.62 (Inspect.306):
    ret Inspect.306;

procedure List.11 (List.133, List.134):
    let List.617 : List {U32, U32} = CallByName List.68 List.134;
    let List.616 : List {U32, U32} = CallByName List.86 List.133 List.134 List.617;
    ret List.616;

procedure List.18 (List.154, List.155, List.156):
    let List.554 : U64 = 0i64;
    let List.555 : U64 = CallByName List.6 List.154;
    let List.553 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName List.88 List.154 List.155 List.156 List.554 List.555;
    ret List.553;

procedure List.18 (List.154, List.155, List.156):
    let List.620 : U64 = 0i64;
    let List.621 : U64 = CallByName List.6 List.154;
    let List.619 : {Str, Int1} = CallByName List.88 List.154 List.155 List.156 List.620 List.621;
    ret List.619;

procedure List.3 (List.111, List.112, List.113):
    let List.572 : {List {U32, U32}, {U32, U32}} = CallByName List.64 List.111 List.112 List.113;
    let List.571 : List {U32, U32} = StructAtIndex 0 List.572;
    ret List.571;

procedure List.3 (List.111, List.112, List.113):
    let List.579 : {List {Str, I64}, {Str, I64}} = CallByName List.64 List.111 List.112 List.113;
    let List.578 : List {Str, I64} = StructAtIndex 0 List.579;
    let #Derived_gen.70 : {Str, I64} = StructAtIndex 1 List.579;
    dec #Derived_gen.70;
    ret List.578;

procedure List.4 (List.119, List.120):
    let List.592 : U64 = 1i64;
    let List.590 : List {Str, I64} = CallByName List.70 List.119 List.592;
    let List.589 : List {Str, I64} = CallByName List.71 List.590 List.120;
    ret List.589;

procedure List.6 (#Attr.2):
    let List.569 : U64 = lowlevel ListLen #Attr.2;
    ret List.569;

procedure List.6 (#Attr.2):
    let List.618 : U64 = lowlevel ListLen #Attr.2;
    ret List.618;

procedure List.6 (#Attr.2):
    let List.630 : U64 = lowlevel ListLen #Attr.2;
    ret List.630;

procedure List.64 (List.108, List.109, List.110):
    let List.584 : U64 = CallByName List.6 List.108;
    let List.581 : Int1 = CallByName Num.22 List.109 List.584;
    if List.581 then
        let List.582 : {List {Str, I64}, {Str, I64}} = CallByName List.67 List.108 List.109 List.110;
        ret List.582;
    else
        let List.580 : {List {Str, I64}, {Str, I64}} = Struct {List.108, List.110};
        ret List.580;

procedure List.64 (List.108, List.109, List.110):
    let List.588 : U64 = CallByName List.6 List.108;
    let List.586 : Int1 = CallByName Num.22 List.109 List.588;
    if List.586 then
        let List.587 : {List {U32, U32}, {U32, U32}} = CallByName List.67 List.108 List.109 List.110;
        ret List.587;
    else
        let List.585 : {List {U32, U32}, {U32, U32}} = Struct {List.108, List.110};
        ret List.585;

procedure List.66 (#Attr.2, #Attr.3):
    let List.629 : {Str, I64} = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.629;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.576 : {List {U32, U32}, {U32, U32}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.576;

procedure List.67 (#Attr.2, #Attr.3, #Attr.4):
    let List.583 : {List {Str, I64}, {Str, I64}} = lowlevel ListReplaceUnsafe #Attr.2 #Attr.3 #Attr.4;
    ret List.583;

procedure List.68 (#Attr.2):
    let List.615 : List {U32, U32} = lowlevel ListWithCapacity #Attr.2;
    ret List.615;

procedure List.70 (#Attr.2, #Attr.3):
    let List.593 : List {Str, I64} = lowlevel ListReserve #Attr.2 #Attr.3;
    ret List.593;

procedure List.71 (#Attr.2, #Attr.3):
    let List.591 : List {Str, I64} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.591;

procedure List.71 (#Attr.2, #Attr.3):
    let List.612 : List {U32, U32} = lowlevel ListAppendUnsafe #Attr.2 #Attr.3;
    ret List.612;

procedure List.83 (List.163, List.164, List.165):
    let List.595 : U64 = 0i64;
    let List.596 : U64 = CallByName List.6 List.163;
    let List.594 : List {U32, U32} = CallByName List.89 List.163 List.164 List.165 List.595 List.596;
    ret List.594;

procedure List.86 (#Derived_gen.33, #Derived_gen.34, #Derived_gen.35):
    joinpoint List.606 List.135 List.136 List.137:
        let List.614 : U64 = 0i64;
        let List.608 : Int1 = CallByName Num.24 List.136 List.614;
        if List.608 then
            let List.613 : U64 = 1i64;
            let List.610 : U64 = CallByName Num.75 List.136 List.613;
            let List.611 : List {U32, U32} = CallByName List.71 List.137 List.135;
            jump List.606 List.135 List.610 List.611;
        else
            ret List.137;
    in
    jump List.606 #Derived_gen.33 #Derived_gen.34 #Derived_gen.35;

procedure List.88 (#Derived_gen.47, #Derived_gen.48, #Derived_gen.49, #Derived_gen.50, #Derived_gen.51):
    joinpoint List.622 List.157 List.158 List.159 List.160 List.161:
        let List.624 : Int1 = CallByName Num.22 List.160 List.161;
        if List.624 then
            let List.628 : {Str, I64} = CallByName List.66 List.157 List.160;
            inc List.628;
            let List.162 : {Str, Int1} = CallByName Dict.163 List.158 List.628 List.159;
            let List.627 : U64 = 1i64;
            let List.626 : U64 = CallByName Num.51 List.160 List.627;
            jump List.622 List.157 List.162 List.159 List.626 List.161;
        else
            dec List.157;
            ret List.158;
    in
    jump List.622 #Derived_gen.47 #Derived_gen.48 #Derived_gen.49 #Derived_gen.50 #Derived_gen.51;

procedure List.88 (#Derived_gen.52, #Derived_gen.53, #Derived_gen.54, #Derived_gen.55, #Derived_gen.56):
    joinpoint List.556 List.157 List.158 List.159 List.160 List.161:
        let List.558 : Int1 = CallByName Num.22 List.160 List.161;
        if List.558 then
            let List.562 : {Str, I64} = CallByName List.66 List.157 List.160;
            inc List.562;
            let List.162 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.134 List.158 List.562;
            let List.561 : U64 = 1i64;
            let List.560 : U64 = CallByName Num.51 List.160 List.561;
            jump List.556 List.157 List.162 List.159 List.560 List.161;
        else
            dec List.157;
            ret List.158;
    in
    jump List.556 #Derived_gen.52 #Derived_gen.53 #Derived_gen.54 #Derived_gen.55 #Derived_gen.56;

procedure List.89 (#Derived_gen.59, #Derived_gen.60, #Derived_gen.61, #Derived_gen.62, #Derived_gen.63):
    joinpoint List.597 List.166 List.167 List.168 List.169 List.170:
        let List.599 : Int1 = CallByName Num.22 List.169 List.170;
        if List.599 then
            let List.603 : {Str, I64} = CallByName List.66 List.166 List.169;
            inc List.603;
            let List.171 : List {U32, U32} = CallByName Dict.371 List.167 List.603 List.169 List.168;
            let List.602 : U64 = 1i64;
            let List.601 : U64 = CallByName Num.51 List.169 List.602;
            jump List.597 List.166 List.171 List.168 List.601 List.170;
        else
            dec List.166;
            ret List.167;
    in
    jump List.597 #Derived_gen.59 #Derived_gen.60 #Derived_gen.61 #Derived_gen.62 #Derived_gen.63;

procedure Num.131 (#Attr.2):
    let Num.310 : U32 = lowlevel NumIntCast #Attr.2;
    ret Num.310;

procedure Num.133 (#Attr.2):
    let Num.366 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.366;

procedure Num.133 (#Attr.2):
    let Num.367 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.367;

procedure Num.133 (#Attr.2):
    let Num.382 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.382;

procedure Num.135 (#Attr.2):
    let Num.388 : U128 = lowlevel NumIntCast #Attr.2;
    ret Num.388;

procedure Num.137 (#Attr.2):
    let Num.301 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.301;

procedure Num.137 (#Attr.2):
    let Num.307 : U64 = lowlevel NumIntCast #Attr.2;
    ret Num.307;

procedure Num.139 (#Attr.2):
    let Num.334 : Float32 = lowlevel NumToFloatCast #Attr.2;
    ret Num.334;

procedure Num.159 (Num.240, Num.241):
    let Num.336 : Int1 = CallByName Num.22 Num.240 Num.241;
    if Num.336 then
        ret Num.240;
    else
        ret Num.241;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.291 : U32 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.291;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.311 : U64 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.311;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.314 : U8 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.314;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.327 : Float32 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.327;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.386 : U128 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.386;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.331 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.331;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.461 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.461;

procedure Num.23 (#Attr.2, #Attr.3):
    let Num.454 : Int1 = lowlevel NumLte #Attr.2 #Attr.3;
    ret Num.454;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.315 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.315;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.457 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.457;

procedure Num.25 (#Attr.2, #Attr.3):
    let Num.458 : Int1 = lowlevel NumGte #Attr.2 #Attr.3;
    ret Num.458;

procedure Num.50 (#Attr.2):
    let Num.333 : U64 = lowlevel NumFloor #Attr.2;
    ret Num.333;

procedure Num.51 (#Attr.2, #Attr.3):
    let Num.460 : U64 = lowlevel NumAddWrap #Attr.2 #Attr.3;
    ret Num.460;

procedure Num.69 (#Attr.2, #Attr.3):
    let Num.319 : U32 = lowlevel NumBitwiseAnd #Attr.2 #Attr.3;
    ret Num.319;

procedure Num.70 (#Attr.2, #Attr.3):
    let Num.364 : U64 = lowlevel NumBitwiseXor #Attr.2 #Attr.3;
    ret Num.364;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.318 : U32 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.318;

procedure Num.71 (#Attr.2, #Attr.3):
    let Num.402 : U64 = lowlevel NumBitwiseOr #Attr.2 #Attr.3;
    ret Num.402;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.292 : U32 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.292;

procedure Num.72 (#Attr.2, #Attr.3):
    let Num.417 : U64 = lowlevel NumShiftLeftBy #Attr.2 #Attr.3;
    ret Num.417;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.383 : U128 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.383;

procedure Num.74 (#Attr.2, #Attr.3):
    let Num.385 : U64 = lowlevel NumShiftRightZfBy #Attr.2 #Attr.3;
    ret Num.385;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.320 : U32 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.320;

procedure Num.75 (#Attr.2, #Attr.3):
    let Num.451 : U64 = lowlevel NumSubWrap #Attr.2 #Attr.3;
    ret Num.451;

procedure Num.96 (#Attr.2):
    let Num.330 : Str = lowlevel NumToStr #Attr.2;
    ret Num.330;

procedure Num.96 (#Attr.2):
    let Num.459 : Str = lowlevel NumToStr #Attr.2;
    ret Num.459;

procedure Str.12 (#Attr.2):
    let Str.294 : List U8 = lowlevel StrToUtf8 #Attr.2;
    ret Str.294;

procedure Str.3 (#Attr.2, #Attr.3):
    let Str.295 : Str = lowlevel StrConcat #Attr.2 #Attr.3;
    ret Str.295;

procedure Test.0 ():
    let Test.8 : Str = "a";
    let Test.9 : I64 = 1i64;
    let Test.4 : {Str, I64} = Struct {Test.8, Test.9};
    let Test.6 : Str = "b";
    let Test.7 : I64 = 2i64;
    let Test.5 : {Str, I64} = Struct {Test.6, Test.7};
    let Test.3 : List {Str, I64} = Array [Test.4, Test.5];
    let Test.2 : {List {U32, U32}, List {Str, I64}, U64, Float32, U8} = CallByName Dict.12 Test.3;
    let Test.1 : Str = CallByName Inspect.34 Test.2;
    ret Test.1;
