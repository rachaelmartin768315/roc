procedure #Multimorphic.0 (Test.23, #Attr.12):
    let Test.4 : Str = UnionAtIndex (Id 0) (Index 0) #Attr.12;
    inc Test.4;
    dec #Attr.12;
    let Test.25 : Str = "";
    ret Test.25;

procedure #Multimorphic.1 (Test.17, #Attr.12):
    let Test.4 : {} = UnionAtIndex (Id 1) (Index 0) #Attr.12;
    dec #Attr.12;
    let Test.19 : Str = "";
    ret Test.19;

procedure Test.1 (Test.4):
    let Test.16 : [C Str, C {}] = ClosureTag(#Multimorphic.1) Test.4;
    ret Test.16;

procedure Test.1 (Test.4):
    let Test.22 : [C Str, C {}] = ClosureTag(#Multimorphic.0) Test.4;
    ret Test.22;

procedure Test.0 ():
    let Test.2 : Int1 = true;
    joinpoint Test.13 Test.3:
        let Test.8 : {} = Struct {};
        let Test.9 : U8 = GetTagId Test.3;
        joinpoint Test.10 Test.7:
            ret Test.7;
        in
        switch Test.9:
            case 0:
                let Test.11 : Str = CallByName #Multimorphic.0 Test.8 Test.3;
                jump Test.10 Test.11;
        
            default:
                let Test.12 : Str = CallByName #Multimorphic.1 Test.8 Test.3;
                jump Test.10 Test.12;
        
    in
    let Test.26 : Int1 = true;
    let Test.27 : Int1 = lowlevel Eq Test.26 Test.2;
    if Test.27 then
        let Test.15 : {} = Struct {};
        let Test.14 : [C Str, C {}] = CallByName Test.1 Test.15;
        jump Test.13 Test.14;
    else
        let Test.21 : Str = "";
        let Test.20 : [C Str, C {}] = CallByName Test.1 Test.21;
        jump Test.13 Test.20;
