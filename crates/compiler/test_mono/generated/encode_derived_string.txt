procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.23;

procedure Encode.23 (Encode.98):
    ret Encode.98;

procedure Encode.24 (Encode.99, Encode.107, Encode.101):
    let Encode.111 : List U8 = CallByName Json.181 Encode.99 Encode.101 Encode.107;
    ret Encode.111;

procedure Encode.26 (Encode.105, Encode.106):
    let Encode.109 : List U8 = Array [];
    let Encode.110 : Str = CallByName Json.24 Encode.105;
    let Encode.108 : List U8 = CallByName Encode.24 Encode.109 Encode.110 Encode.106;
    ret Encode.108;

procedure Json.1 ():
    let Json.1171 : [C , C [], C , C , C , C ] = TagId(2) ;
    ret Json.1171;

procedure Json.181 (Json.182, Json.1174, Json.180):
    let Json.1177 : List U8 = CallByName Json.25 Json.180;
    let Json.1176 : List U8 = CallByName List.8 Json.182 Json.1177;
    ret Json.1176;

procedure Json.188 (Json.1225, Json.191):
    let Json.189 : U64 = StructAtIndex 0 Json.1225;
    let Json.190 : Int1 = StructAtIndex 1 Json.1225;
    switch Json.191:
        case 34:
            let Json.1228 : Int1 = false;
            let Json.1227 : {U64, Int1} = Struct {Json.189, Json.1228};
            let Json.1226 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1227;
            ret Json.1226;
    
        case 92:
            let Json.1231 : Int1 = false;
            let Json.1230 : {U64, Int1} = Struct {Json.189, Json.1231};
            let Json.1229 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1230;
            ret Json.1229;
    
        case 47:
            let Json.1234 : Int1 = false;
            let Json.1233 : {U64, Int1} = Struct {Json.189, Json.1234};
            let Json.1232 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1233;
            ret Json.1232;
    
        case 8:
            let Json.1237 : Int1 = false;
            let Json.1236 : {U64, Int1} = Struct {Json.189, Json.1237};
            let Json.1235 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1236;
            ret Json.1235;
    
        case 12:
            let Json.1240 : Int1 = false;
            let Json.1239 : {U64, Int1} = Struct {Json.189, Json.1240};
            let Json.1238 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1239;
            ret Json.1238;
    
        case 10:
            let Json.1243 : Int1 = false;
            let Json.1242 : {U64, Int1} = Struct {Json.189, Json.1243};
            let Json.1241 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1242;
            ret Json.1241;
    
        case 13:
            let Json.1246 : Int1 = false;
            let Json.1245 : {U64, Int1} = Struct {Json.189, Json.1246};
            let Json.1244 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1245;
            ret Json.1244;
    
        case 9:
            let Json.1249 : Int1 = false;
            let Json.1248 : {U64, Int1} = Struct {Json.189, Json.1249};
            let Json.1247 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) Json.1248;
            ret Json.1247;
    
        default:
            let Json.1253 : U64 = 1i64;
            let Json.1252 : U64 = CallByName Num.19 Json.189 Json.1253;
            let Json.1251 : {U64, Int1} = Struct {Json.1252, Json.190};
            let Json.1250 : [C {U64, Int1}, C {U64, Int1}] = TagId(1) Json.1251;
            ret Json.1250;
    

procedure Json.214 (Json.215, Json.216):
    let Json.1196 : List U8 = CallByName Json.26 Json.216;
    let Json.1195 : List U8 = CallByName List.8 Json.215 Json.1196;
    ret Json.1195;

procedure Json.24 (Json.180):
    let Json.1172 : Str = CallByName Encode.23 Json.180;
    ret Json.1172;

procedure Json.25 (Json.183):
    let Json.184 : List U8 = CallByName Str.12 Json.183;
    let Json.1254 : U64 = 0i64;
    let Json.1255 : Int1 = true;
    let Json.185 : {U64, Int1} = Struct {Json.1254, Json.1255};
    let Json.1224 : {} = Struct {};
    inc Json.184;
    let Json.186 : {U64, Int1} = CallByName List.26 Json.184 Json.185 Json.1224;
    let Json.1178 : Int1 = StructAtIndex 1 Json.186;
    let Json.1222 : Int1 = true;
    let Json.1223 : Int1 = lowlevel Eq Json.1222 Json.1178;
    if Json.1223 then
        let Json.1188 : U64 = CallByName List.6 Json.184;
        let Json.1189 : U64 = 2i64;
        let Json.1187 : U64 = CallByName Num.19 Json.1188 Json.1189;
        let Json.1184 : List U8 = CallByName List.68 Json.1187;
        let Json.1186 : U8 = 34i64;
        let Json.1185 : List U8 = Array [Json.1186];
        let Json.1183 : List U8 = CallByName List.8 Json.1184 Json.1185;
        let Json.1180 : List U8 = CallByName List.8 Json.1183 Json.184;
        let Json.1182 : U8 = 34i64;
        let Json.1181 : List U8 = Array [Json.1182];
        let Json.1179 : List U8 = CallByName List.8 Json.1180 Json.1181;
        ret Json.1179;
    else
        inc Json.184;
        let Json.1221 : U64 = StructAtIndex 0 Json.186;
        let Json.1220 : {List U8, List U8} = CallByName List.52 Json.184 Json.1221;
        let Json.210 : List U8 = StructAtIndex 0 Json.1220;
        let Json.212 : List U8 = StructAtIndex 1 Json.1220;
        let Json.1218 : U64 = CallByName List.6 Json.184;
        dec Json.184;
        let Json.1219 : U64 = 120i64;
        let Json.1216 : U64 = CallByName Num.21 Json.1218 Json.1219;
        let Json.1217 : U64 = 100i64;
        let Json.1215 : U64 = CallByName Num.94 Json.1216 Json.1217;
        let Json.1212 : List U8 = CallByName List.68 Json.1215;
        let Json.1214 : U8 = 34i64;
        let Json.1213 : List U8 = Array [Json.1214];
        let Json.1211 : List U8 = CallByName List.8 Json.1212 Json.1213;
        let Json.213 : List U8 = CallByName List.8 Json.1211 Json.210;
        let Json.1194 : {} = Struct {};
        let Json.1191 : List U8 = CallByName List.18 Json.212 Json.213 Json.1194;
        let Json.1193 : U8 = 34i64;
        let Json.1192 : List U8 = Array [Json.1193];
        let Json.1190 : List U8 = CallByName List.8 Json.1191 Json.1192;
        ret Json.1190;

procedure Json.26 (Json.217):
    switch Json.217:
        case 34:
            let Json.1197 : List U8 = Array [92i64, 34i64];
            ret Json.1197;
    
        case 92:
            let Json.1198 : List U8 = Array [92i64, 92i64];
            ret Json.1198;
    
        case 47:
            let Json.1199 : List U8 = Array [92i64, 47i64];
            ret Json.1199;
    
        case 8:
            let Json.1201 : U8 = 98i64;
            let Json.1200 : List U8 = Array [92i64, Json.1201];
            ret Json.1200;
    
        case 12:
            let Json.1203 : U8 = 102i64;
            let Json.1202 : List U8 = Array [92i64, Json.1203];
            ret Json.1202;
    
        case 10:
            let Json.1205 : U8 = 110i64;
            let Json.1204 : List U8 = Array [92i64, Json.1205];
            ret Json.1204;
    
        case 13:
            let Json.1207 : U8 = 114i64;
            let Json.1206 : List U8 = Array [92i64, Json.1207];
            ret Json.1206;
    
        case 9:
            let Json.1209 : U8 = 114i64;
            let Json.1208 : List U8 = Array [92i64, Json.1209];
            ret Json.1208;
    
        default:
            let Json.1210 : List U8 = Array [Json.217];
            ret Json.1210;
    

procedure List.145 (List.146, List.147, List.144):
    let List.553 : List U8 = CallByName Json.214 List.146 List.147;
    ret List.553;

procedure List.18 (List.142, List.143, List.144):
    let List.535 : List U8 = CallByName List.93 List.142 List.143 List.144;
    ret List.535;

procedure List.26 (List.159, List.160, List.161):
    let List.570 : [C {U64, Int1}, C {U64, Int1}] = CallByName List.93 List.159 List.160 List.161;
    let List.573 : U8 = 1i64;
    let List.574 : U8 = GetTagId List.570;
    let List.575 : Int1 = lowlevel Eq List.573 List.574;
    if List.575 then
        let List.162 : {U64, Int1} = UnionAtIndex (Id 1) (Index 0) List.570;
        ret List.162;
    else
        let List.163 : {U64, Int1} = UnionAtIndex (Id 0) (Index 0) List.570;
        ret List.163;

procedure List.49 (List.376, List.377):
    let List.562 : U64 = StructAtIndex 0 List.377;
    let List.563 : U64 = 0i64;
    let List.560 : Int1 = CallByName Bool.11 List.562 List.563;
    if List.560 then
        dec List.376;
        let List.561 : List U8 = Array [];
        ret List.561;
    else
        let List.557 : U64 = StructAtIndex 1 List.377;
        let List.558 : U64 = StructAtIndex 0 List.377;
        let List.556 : List U8 = CallByName List.72 List.376 List.557 List.558;
        ret List.556;

procedure List.52 (List.391, List.392):
    let List.393 : U64 = CallByName List.6 List.391;
    joinpoint List.568 List.394:
        let List.566 : U64 = 0i64;
        let List.565 : {U64, U64} = Struct {List.394, List.566};
        inc List.391;
        let List.395 : List U8 = CallByName List.49 List.391 List.565;
        let List.564 : U64 = CallByName Num.20 List.393 List.394;
        let List.555 : {U64, U64} = Struct {List.564, List.394};
        let List.396 : List U8 = CallByName List.49 List.391 List.555;
        let List.554 : {List U8, List U8} = Struct {List.395, List.396};
        ret List.554;
    in
    let List.569 : Int1 = CallByName Num.24 List.393 List.392;
    if List.569 then
        jump List.568 List.392;
    else
        jump List.568 List.393;

procedure List.6 (#Attr.2):
    let List.534 : U64 = lowlevel ListLen #Attr.2;
    ret List.534;

procedure List.66 (#Attr.2, #Attr.3):
    let List.551 : U8 = lowlevel ListGetUnsafe #Attr.2 #Attr.3;
    ret List.551;

procedure List.68 (#Attr.2):
    let List.532 : List U8 = lowlevel ListWithCapacity #Attr.2;
    ret List.532;

procedure List.72 (#Attr.2, #Attr.3, #Attr.4):
    let List.559 : List U8 = lowlevel ListSublist #Attr.2 #Attr.3 #Attr.4;
    ret List.559;

procedure List.8 (#Attr.2, #Attr.3):
    let List.530 : List U8 = lowlevel ListConcat #Attr.2 #Attr.3;
    ret List.530;

procedure List.80 (List.598, List.599, List.600, List.601, List.602):
    joinpoint List.541 List.439 List.440 List.441 List.442 List.443:
        let List.543 : Int1 = CallByName Num.22 List.442 List.443;
        if List.543 then
            let List.550 : U8 = CallByName List.66 List.439 List.442;
            let List.544 : List U8 = CallByName List.145 List.440 List.550 List.441;
            let List.547 : U64 = 1i64;
            let List.546 : U64 = CallByName Num.19 List.442 List.547;
            jump List.541 List.439 List.544 List.441 List.546 List.443;
        else
            dec List.439;
            ret List.440;
    in
    jump List.541 List.598 List.599 List.600 List.601 List.602;

procedure List.80 (List.621, List.622, List.623, List.624, List.625):
    joinpoint List.579 List.439 List.440 List.441 List.442 List.443:
        let List.581 : Int1 = CallByName Num.22 List.442 List.443;
        if List.581 then
            let List.590 : U8 = CallByName List.66 List.439 List.442;
            let List.582 : [C {U64, Int1}, C {U64, Int1}] = CallByName Json.188 List.440 List.590;
            let List.587 : U8 = 1i64;
            let List.588 : U8 = GetTagId List.582;
            let List.589 : Int1 = lowlevel Eq List.587 List.588;
            if List.589 then
                let List.444 : {U64, Int1} = UnionAtIndex (Id 1) (Index 0) List.582;
                let List.585 : U64 = 1i64;
                let List.584 : U64 = CallByName Num.19 List.442 List.585;
                jump List.579 List.439 List.444 List.441 List.584 List.443;
            else
                dec List.439;
                let List.445 : {U64, Int1} = UnionAtIndex (Id 0) (Index 0) List.582;
                let List.586 : [C {U64, Int1}, C {U64, Int1}] = TagId(0) List.445;
                ret List.586;
        else
            dec List.439;
            let List.580 : [C {U64, Int1}, C {U64, Int1}] = TagId(1) List.440;
            ret List.580;
    in
    jump List.579 List.621 List.622 List.623 List.624 List.625;

procedure List.93 (List.436, List.437, List.438):
    let List.539 : U64 = 0i64;
    let List.540 : U64 = CallByName List.6 List.436;
    let List.538 : List U8 = CallByName List.80 List.436 List.437 List.438 List.539 List.540;
    ret List.538;

procedure List.93 (List.436, List.437, List.438):
    let List.577 : U64 = 0i64;
    let List.578 : U64 = CallByName List.6 List.436;
    let List.576 : [C {U64, Int1}, C {U64, Int1}] = CallByName List.80 List.436 List.437 List.438 List.577 List.578;
    ret List.576;

procedure Num.19 (#Attr.2, #Attr.3):
    let Num.286 : U64 = lowlevel NumAdd #Attr.2 #Attr.3;
    ret Num.286;

procedure Num.20 (#Attr.2, #Attr.3):
    let Num.289 : U64 = lowlevel NumSub #Attr.2 #Attr.3;
    ret Num.289;

procedure Num.21 (#Attr.2, #Attr.3):
    let Num.284 : U64 = lowlevel NumMul #Attr.2 #Attr.3;
    ret Num.284;

procedure Num.22 (#Attr.2, #Attr.3):
    let Num.288 : Int1 = lowlevel NumLt #Attr.2 #Attr.3;
    ret Num.288;

procedure Num.24 (#Attr.2, #Attr.3):
    let Num.290 : Int1 = lowlevel NumGt #Attr.2 #Attr.3;
    ret Num.290;

procedure Num.94 (#Attr.2, #Attr.3):
    let Num.283 : U64 = lowlevel NumDivCeilUnchecked #Attr.2 #Attr.3;
    ret Num.283;

procedure Str.12 (#Attr.2):
    let Str.312 : List U8 = lowlevel StrToUtf8 #Attr.2;
    ret Str.312;

procedure Str.48 (#Attr.2, #Attr.3, #Attr.4):
    let Str.307 : {U64, Str, Int1, U8} = lowlevel StrFromUtf8Range #Attr.2 #Attr.3 #Attr.4;
    ret Str.307;

procedure Str.9 (Str.79):
    let Str.305 : U64 = 0i64;
    let Str.306 : U64 = CallByName List.6 Str.79;
    let Str.80 : {U64, Str, Int1, U8} = CallByName Str.48 Str.79 Str.305 Str.306;
    let Str.302 : Int1 = StructAtIndex 2 Str.80;
    if Str.302 then
        let Str.304 : Str = StructAtIndex 1 Str.80;
        let Str.303 : [C {U64, U8}, C Str] = TagId(1) Str.304;
        ret Str.303;
    else
        let Str.300 : U8 = StructAtIndex 3 Str.80;
        let Str.301 : U64 = StructAtIndex 0 Str.80;
        let #Derived_gen.0 : Str = StructAtIndex 1 Str.80;
        dec #Derived_gen.0;
        let Str.299 : {U64, U8} = Struct {Str.301, Str.300};
        let Str.298 : [C {U64, U8}, C Str] = TagId(0) Str.299;
        ret Str.298;

procedure Test.0 ():
    let Test.9 : Str = "abc";
    let Test.10 : [C , C [], C , C , C , C ] = CallByName Json.1;
    let Test.8 : List U8 = CallByName Encode.26 Test.9 Test.10;
    let Test.1 : [C {U64, U8}, C Str] = CallByName Str.9 Test.8;
    let Test.5 : U8 = 1i64;
    let Test.6 : U8 = GetTagId Test.1;
    let Test.7 : Int1 = lowlevel Eq Test.5 Test.6;
    if Test.7 then
        let Test.2 : Str = UnionAtIndex (Id 1) (Index 0) Test.1;
        ret Test.2;
    else
        dec Test.1;
        let Test.4 : Str = "<bad>";
        ret Test.4;
