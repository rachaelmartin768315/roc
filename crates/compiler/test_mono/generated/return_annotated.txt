procedure Bool.11 (#Attr.2, #Attr.3):
    let Bool.23 : Int1 = lowlevel Eq #Attr.2 #Attr.3;
    ret Bool.23;

procedure Str.26 (Str.181):
    let Str.378 : [C {}, C U64] = CallByName Str.71 Str.181;
    ret Str.378;

procedure Str.42 (#Attr.2):
    let Str.386 : {U64, U8} = lowlevel StrToNum #Attr.2;
    ret Str.386;

procedure Str.71 (Str.289):
    let Str.290 : {U64, U8} = CallByName Str.42 Str.289;
    let Str.384 : U8 = StructAtIndex 1 Str.290;
    let Str.385 : U8 = 0i64;
    let Str.381 : Int1 = CallByName Bool.11 Str.384 Str.385;
    if Str.381 then
        let Str.383 : U64 = StructAtIndex 0 Str.290;
        let Str.382 : [C {}, C U64] = TagId(1) Str.383;
        ret Str.382;
    else
        let Str.380 : {} = Struct {};
        let Str.379 : [C {}, C U64] = TagId(0) Str.380;
        ret Str.379;

procedure Test.1 (Test.2):
    joinpoint Test.11 Test.3:
        let Test.7 : [C {}, C U64] = TagId(1) Test.3;
        ret Test.7;
    in
    let Test.10 : [C {}, C U64] = CallByName Str.26 Test.2;
    let Test.15 : U8 = 1i64;
    let Test.16 : U8 = GetTagId Test.10;
    let Test.17 : Int1 = lowlevel Eq Test.15 Test.16;
    if Test.17 then
        let Test.8 : U64 = UnionAtIndex (Id 1) (Index 0) Test.10;
        jump Test.11 Test.8;
    else
        let Test.9 : {} = UnionAtIndex (Id 0) (Index 0) Test.10;
        let Test.14 : [C {}, C U64] = TagId(0) Test.9;
        ret Test.14;

procedure Test.0 ():
    let Test.6 : Str = "123";
    let Test.5 : [C {}, C U64] = CallByName Test.1 Test.6;
    dec Test.6;
    ret Test.5;
