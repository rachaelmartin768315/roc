# +set function_kind=erased
# +emit:mono
app "test" provides [main] to "./platform"

f = \s ->
  if Bool.true
  then \{} -> ""
  #    ^^^^^^^^^ {}* -?-> Str
  else \{} -> s
  #    ^^^^^^^^ {}* -?-> Str

main = (f "") {}
#       ^^^^ {} -?-> Str

# -emit:mono
procedure Bool.2 ():
    let Bool.23 : Int1 = true;
    ret Bool.23;

procedure Test.1 (Test.2):
    let Test.38 : Int1 = CallByName Bool.2;
    if Test.38 then
        dec Test.2;
        let Test.44 : {} = Struct {};
        let Test.45 : Boxed({}) = Box Test.44;
        let Test.42 : Boxed([]) = lowlevel PtrCast Test.45;
        let Test.43 : Boxed([]) = FunctionPointer Test.3;
        dec Test.43;
        let Test.39 : ?Erased = ErasedMake { value: Test.42, callee: Test.43 };
        ret Test.39;
    else
        let Test.36 : {Str} = Struct {Test.2};
        let Test.37 : Boxed({Str}) = Box Test.36;
        let Test.34 : Boxed([]) = lowlevel PtrCast Test.37;
        let Test.35 : Boxed([]) = FunctionPointer Test.4;
        dec Test.35;
        let Test.28 : ?Erased = ErasedMake { value: Test.34, callee: Test.35 };
        ret Test.28;

procedure Test.3 (Test.40):
    let Test.41 : Str = "";
    ret Test.41;

procedure Test.4 (Test.29, #Attr.12):
    inc #Attr.12;
    let Test.31 : Boxed([]) = ErasedLoad #Attr.12 .Value;
    dec Test.31;
    let Test.32 : Boxed({Str}) = lowlevel PtrCast #Attr.12;
    let Test.33 : {Str} = Unbox Test.32;
    joinpoint #Derived_gen.0:
        let Test.2 : Str = StructAtIndex 0 Test.33;
        ret Test.2;
    in
    let #Derived_gen.1 : Int1 = lowlevel RefCountIsUnique Test.32;
    if #Derived_gen.1 then
        free Test.32;
        jump #Derived_gen.0;
    else
        inc Test.33;
        decref Test.32;
        jump #Derived_gen.0;

procedure Test.0 ():
    let Test.6 : {} = Struct {};
    let Test.17 : Str = "";
    let Test.46 : Boxed([]) = FunctionPointer Test.1;
    dec Test.46;
    let Test.18 : ?Erased = ErasedMake { value: <null>, callee: Test.46 };
    joinpoint Test.19 Test.7:
        joinpoint Test.8 Test.5:
            ret Test.5;
        in
        let Test.9 : Boxed([]) = ErasedLoad Test.7 .Value;
        let Test.10 : Boxed([]) = ErasedLoad Test.7 .Callee;
        let Test.12 : Boxed([]) = NullPointer;
        let Test.11 : Int1 = lowlevel Eq Test.9 Test.12;
        dec Test.12;
        dec Test.9;
        switch Test.11:
            case 0:
                let Test.13 : FunPtr({} -> Str) = lowlevel PtrCast Test.10;
                let Test.14 : Str = CallByPtr Test.13 Test.6;
                jump Test.8 Test.14;
        
            default:
                inc Test.7;
                let Test.15 : FunPtr({}, ?Erased -> Str) = lowlevel PtrCast Test.10;
                let Test.16 : Str = CallByPtr Test.15 Test.6 Test.7;
                jump Test.8 Test.16;
        
    in
    let Test.20 : Boxed([]) = ErasedLoad Test.18 .Value;
    let Test.21 : Boxed([]) = ErasedLoad Test.18 .Callee;
    let Test.23 : Boxed([]) = NullPointer;
    let Test.22 : Int1 = lowlevel Eq Test.20 Test.23;
    dec Test.20;
    dec Test.23;
    switch Test.22:
        case 0:
            let Test.24 : FunPtr(Str -> ?Erased) = lowlevel PtrCast Test.21;
            let Test.25 : ?Erased = CallByPtr Test.24 Test.17;
            jump Test.19 Test.25;
    
        default:
            inc Test.18;
            let Test.26 : FunPtr(Str, ?Erased -> ?Erased) = lowlevel PtrCast Test.21;
            let Test.27 : ?Erased = CallByPtr Test.26 Test.17 Test.18;
            jump Test.19 Test.27;
    
