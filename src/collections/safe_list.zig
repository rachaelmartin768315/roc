//! Lists that make it easier to avoid incorrect indexing.

const std = @import("std");
const utils = @import("utils.zig");

const testing = std.testing;
const Allocator = std.mem.Allocator;
const exitOnOom = utils.exitOnOom;

/// Represents a type safe range in a list; [start, end)
///
/// This is the conceptual equivalent of slice, but since this is based
/// on indexes in the list rather than pointers, it is reliable across
/// (de)serilaization and reallocation of the list.
///
/// This range is inclusive on the lower bound, exclusive on the upper bound.
pub fn SafeRange(comptime Idx: type) type {
    return struct {
        const Self = @This();

        start: Idx,
        end: Idx,

        /// An empty range
        pub const empty: Self = .{ .start = @enumFromInt(0), .end = @enumFromInt(0) };

        /// Get the length of a range slice
        pub fn len(self: @This()) u32 {
            return @intFromEnum(self.end) - @intFromEnum(self.start);
        }

        /// Get the length of a range slice
        pub fn iterIndices(self: @This()) IndexIterator {
            return IndexIterator{
                .len = @intFromEnum(self.end),
                .current = @intFromEnum(self.start),
            };
        }

        /// An iterator over the indices of all elements in a list.
        pub const IndexIterator = struct {
            len: u32,
            current: u32,

            /// Get the next index from this iterator, or `null` if the iterator is finished.
            pub fn next(iter: *IndexIterator) ?Idx {
                if (iter.len == iter.current) {
                    return null;
                }

                const curr = iter.current;
                iter.current += 1;

                const idx: u32 = @truncate(curr);
                return @enumFromInt(idx);
            }
        };
    };
}

/// Wraps a `std.ArrayList` to provide a list that's safer to access
/// with arbitrary indices.
///
/// Use this for values that aren't structs with more than one field.
/// Those values would likely be better stored in a SafeMultiList.
///
/// By default, lists and arrays in Zig are accessed with a `usize`
/// index, which allows for any index to be used with any list. This
/// requires devs to be careful about using indices on the right list
/// and to not look for out-of-bounds values.
///
/// Using a SafeList fixes this as it can only be accessed with a
/// SafeList(T).Idx, which is only created on appending to a SafeList
/// (barring manual usage of macros). An Idx can only be used for lists
/// that hold T's, giving type safety. Also, out-of-bounds errors are
/// less likely since indices are only created for valid list entries.
pub fn SafeList(comptime T: type) type {
    return struct {
        items: std.ArrayListUnmanaged(T) = .{},

        /// An index for an item in the list.
        pub const Idx = enum(u32) { _ };

        /// A non-type-safe slice of the list.
        pub const Slice = std.ArrayListUnmanaged(T).Slice;

        /// A type-safe range of the list.
        pub const Range = SafeRange(Idx);

        /// A type-safe range which must have at least one element.
        pub const NonEmptyRange = struct {
            range: Range,
        };

        /// Initialize the `SafeList` with the specified capacity.
        pub fn initCapacity(gpa: Allocator, capacity: usize) SafeList(T) {
            return .{
                .items = std.ArrayListUnmanaged(T).initCapacity(gpa, capacity) catch |err| exitOnOom(err),
            };
        }

        /// Deinitialize the memory of this `SafeList`.
        pub fn deinit(self: *SafeList(T), gpa: Allocator) void {
            self.items.deinit(gpa);
        }

        /// Get the length of this list.
        pub fn len(self: *const SafeList(T)) usize {
            return self.items.items.len;
        }

        /// Add an item to the end of this list.
        pub fn append(self: *SafeList(T), gpa: Allocator, item: T) Idx {
            const length = self.len();
            self.items.append(gpa, item) catch |err| exitOnOom(err);

            return @enumFromInt(@as(u32, @intCast(length)));
        }

        /// Add all the items in a slice to the end of this list.
        pub fn appendSlice(self: *SafeList(T), gpa: Allocator, items: []const T) Range {
            const start_length = self.len();
            self.items.appendSlice(gpa, items) catch |err| exitOnOom(err);
            const end_length = self.len();
            return Range{ .start = @enumFromInt(start_length), .end = @enumFromInt(end_length) };
        }

        /// Extend this list with all items generated by an iterator.
        pub fn extendFromIter(self: *SafeList(T), gpa: Allocator, iter: anytype) Range {
            const start_length = self.len();
            while (iter.next()) |item| {
                self.items.append(gpa, item) catch |err| exitOnOom(err);
            }
            const end_length = self.len();
            return Range{ .start = @enumFromInt(start_length), .end = @enumFromInt(end_length) };
        }

        /// Convert a range to a slice
        pub fn rangeToSlice(self: *const SafeList(T), range: Range) Slice {
            const start: usize = @intFromEnum(range.start);
            const end: usize = @intFromEnum(range.end);

            std.debug.assert(start <= end);
            std.debug.assert(end <= self.items.items.len);

            return self.items.items[start..end];
        }

        /// Get an item from this list without worrying about out-of-bounds errors.
        pub fn get(self: *const SafeList(T), id: Idx) *T {
            return &self.items.items[@as(usize, @intFromEnum(id))];
        }

        /// Set the value of an item in this list without worrying about out-of-bounds errors.
        pub fn set(self: *const SafeList(T), id: Idx, value: T) void {
            self.items.items[@as(usize, @intFromEnum(id))] = value;
        }

        /// Returns the size needed to serialize this list
        pub fn serializedSize(self: *const SafeList(T)) usize {
            // Header: 4 bytes for count
            // Data: items.len * @sizeOf(T)
            return @sizeOf(u32) + (self.items.items.len * @sizeOf(T));
        }

        /// Serialize this list into the provided buffer
        /// Returns the slice of buffer that was written to
        pub fn serializeInto(self: *const SafeList(T), buffer: []align(@alignOf(T)) u8) ![]align(@alignOf(T)) const u8 {
            const size = self.serializedSize();
            if (buffer.len < size) return error.BufferTooSmall;

            // Write count
            const count_ptr = @as(*u32, @ptrCast(@alignCast(buffer.ptr)));
            count_ptr.* = @intCast(self.items.items.len);

            // If T is a POD type, just memcpy the data
            if (@typeInfo(T) == .@"struct" or @typeInfo(T) == .int or @typeInfo(T) == .float) {
                const data_ptr = @as([*]T, @ptrCast(@alignCast(buffer.ptr + @sizeOf(u32))));
                @memcpy(data_ptr[0..self.items.items.len], self.items.items);
            } else {
                @compileError("Cannot serialize non-POD type " ++ @typeName(T));
            }

            return buffer[0..size];
        }

        /// Deserialize from buffer, using provided allocator
        pub fn deserializeFrom(buffer: []align(@alignOf(T)) const u8, allocator: Allocator) !SafeList(T) {
            if (buffer.len < @sizeOf(u32)) return error.BufferTooSmall;

            // Read count
            const count = @as(*const u32, @ptrCast(@alignCast(buffer.ptr))).*;

            const expected_size = @sizeOf(u32) + (count * @sizeOf(T));
            if (buffer.len < expected_size) return error.BufferTooSmall;

            // Create list with exact capacity
            var list = SafeList(T).initCapacity(allocator, count);

            // Copy data
            if (count > 0) {
                const data_ptr = @as([*]const T, @ptrCast(@alignCast(buffer.ptr + @sizeOf(u32))));
                list.items.appendSliceAssumeCapacity(data_ptr[0..count]);
            }

            return list;
        }

        /// An iterator over all the indices in this list.
        pub const IndexIterator = struct {
            len: usize,
            current: usize,

            pub fn next(iter: *IndexIterator) ?Idx {
                if (iter.len == iter.current) {
                    return null;
                }

                const curr = iter.current;
                iter.current += 1;

                const idx: u32 = @truncate(curr);
                return @enumFromInt(idx);
            }
        };

        /// Iterate over all the indices of the items in this list.
        pub fn iterIndices(self: *const SafeList(T)) IndexIterator {
            return IndexIterator{
                .len = self.len(),
                .current = 0,
            };
        }
    };
}

/// Wraps a `std.ArrayMultiList` to provide a list that's safer to access
/// with arbitrary indices.
///
/// Use this for lists comprising structs with differently-sized fields
/// to make the storage of those fields more compact, otherwise a
/// SafeList may be a simpler container.
///
/// By default, lists and arrays in Zig are accessed with a `usize`
/// index, which allows for any index to be used with any list. This
/// requires devs to be careful about using indices on the right list
/// and to not look for out-of-bounds values.
///
/// Using a SafeMultiList fixes this as it can only be accessed with a
/// SafeMultiList(T).Idx, which is only created on appending to a SafeMultiList
/// (barring manual usage of macros). An Idx can only be used for lists
/// that hold T's, giving type safety. Also, out-of-bounds errors are
/// less likely since indices are only created for valid list entries.
pub fn SafeMultiList(comptime T: type) type {
    return struct {
        items: std.MultiArrayList(T) = .{},

        /// Index of an item in the list.
        pub const Idx = enum(u32) { zero = 0, _ };

        /// A non-type-safe slice of the list.
        pub const Slice = std.MultiArrayList(T).Slice;

        /// A type-safe slice of the list.
        pub const Range = SafeRange(Idx);

        /// One of the comptime fields in the list's wrapped type.
        pub const Field = std.MultiArrayList(T).Field;

        /// A slice of all values for a specific field of the wrapped type.
        pub fn field(self: *const SafeMultiList(T), comptime field_name: Field) []type {
            return self.items.items(field_name);
        }

        /// The value for a specific field at a specific index in the list.
        pub fn fieldItem(self: *const SafeMultiList(T), comptime field_name: Field, idx: Idx) type {
            return self.items.items(field_name)[@as(usize, @intFromEnum(idx))];
        }

        /// Initialize the `SafeMultiList` with the specified capacity.
        pub fn initCapacity(gpa: Allocator, capacity: usize) SafeMultiList(T) {
            var items = std.MultiArrayList(T){};
            items.ensureTotalCapacity(gpa, capacity) catch |err| exitOnOom(err);
            return .{
                .items = items,
            };
        }

        /// Deinitialize the memory of a `SafeMultiList`.
        pub fn deinit(self: *SafeMultiList(T), gpa: Allocator) void {
            self.items.deinit(gpa);
        }

        /// Get the length of this list.
        pub fn len(self: *const SafeMultiList(T)) usize {
            return self.items.len;
        }

        /// Add a new item to the end of this list.
        pub fn append(self: *SafeMultiList(T), gpa: Allocator, item: T) Idx {
            const length = self.len();
            self.items.append(gpa, item) catch |err| exitOnOom(err);

            return @enumFromInt(@as(u32, @intCast(length)));
        }

        pub fn appendSlice(self: *SafeMultiList(T), gpa: Allocator, elems: []const T) Range {
            if (elems.len == 0) {
                return .{ .start = .zero, .end = .zero };
            }
            const start_length = self.len();
            self.items.ensureUnusedCapacity(gpa, elems.len) catch |err| exitOnOom(err);
            for (elems) |elem| {
                self.items.appendAssumeCapacity(elem);
            }
            const end_length = self.len();
            return Range{ .start = @enumFromInt(start_length), .end = @enumFromInt(end_length) };
        }

        /// Convert a range to a slice
        pub fn rangeToSlice(self: *const SafeMultiList(T), range: Range) Slice {
            const start: usize = @intFromEnum(range.start);
            const end: usize = @intFromEnum(range.end);

            std.debug.assert(start <= end);
            std.debug.assert(end <= self.items.len);

            const base = self.items.slice();

            var new_ptrs: [base.ptrs.len][*]u8 = undefined;

            // This has to be inline, so `cur_field` can be known at comptime
            inline for (0..base.ptrs.len) |i| {
                const cur_field = @as(Field, @enumFromInt(i));
                const cur_items = base.items(cur_field);
                new_ptrs[i] = if (cur_items.len == 0)
                    undefined
                else
                    @ptrCast(&cur_items[start]);
            }

            return .{
                .ptrs = new_ptrs,
                .len = end - start,
                .capacity = base.capacity - start,
            };
        }

        /// Set the value of an element in this list.
        pub fn set(self: *SafeMultiList(T), idx: Idx, value: T) void {
            self.items.set(@intFromEnum(idx), value);
        }

        // TODO: consider removing this, or at least renaming to imply this is not a zero-cost operation
        pub fn get(self: *const SafeMultiList(T), idx: Idx) T {
            return self.items.get(@intFromEnum(idx));
        }

        /// Make sure that the backing array has at least capacity for the specified number of elements.
        pub fn ensureTotalCapacity(self: *SafeMultiList(T), gpa: Allocator, capacity: usize) void {
            self.items.ensureTotalCapacity(gpa, capacity) catch |err| exitOnOom(err);
        }

        /// An iterator over the indices of all elements in a list.
        pub const IndexIterator = struct {
            len: usize,
            current: usize,

            /// Get the next index from this iterator, or `null` if the iterator is finished.
            pub fn next(iter: *IndexIterator) ?Idx {
                if (iter.len == iter.current) {
                    return null;
                }

                const curr = iter.current;
                iter.current += 1;

                const idx: u32 = @truncate(curr);
                return @enumFromInt(idx);
            }
        };

        /// Iterator over all indices in this list.
        pub fn iterIndices(self: *const SafeMultiList(T)) IndexIterator {
            return IndexIterator{
                .len = self.len(),
                .current = 0,
            };
        }
    };
}

test "SafeList(32) inserting and getting" {
    const gpa = testing.allocator;

    var list_u32 = SafeList(u32){};
    defer list_u32.deinit(gpa);

    try testing.expectEqual(list_u32.len(), 0);

    const id = list_u32.append(gpa, 1);

    try testing.expectEqual(list_u32.len(), 1);

    const item = list_u32.get(id);

    try testing.expectEqual(item.*, 1);
}

test "SafeList(u8) appendSlice" {
    const gpa = testing.allocator;

    var list = SafeList(u8){};
    defer list.deinit(gpa);

    const rangeA = list.appendSlice(gpa, &[_]u8{ 'a', 'b', 'c', 'd' });
    try testing.expectEqual(0, @intFromEnum(rangeA.start));
    try testing.expectEqual(4, @intFromEnum(rangeA.end));

    const rangeB = list.appendSlice(gpa, &[_]u8{ 'd', 'e', 'f', 'g' });
    try testing.expectEqual(4, @intFromEnum(rangeB.start));
    try testing.expectEqual(8, @intFromEnum(rangeB.end));
}

test "SafeList(u8) rangeToSlice" {
    const gpa = testing.allocator;

    var list = SafeList(u8){};
    defer list.deinit(gpa);

    const rangeA = list.appendSlice(gpa, &[_]u8{ 'a', 'b', 'c', 'd' });
    const sliceA = list.rangeToSlice(rangeA);
    try testing.expectEqual('a', sliceA[0]);
    try testing.expectEqual('d', sliceA[3]);

    const rangeB = SafeList(u8).Range{ .start = @enumFromInt(2), .end = @enumFromInt(4) };
    const sliceB = list.rangeToSlice(rangeB);
    try testing.expectEqual('c', sliceB[0]);
    try testing.expectEqual('d', sliceB[1]);
}

test "SafeMultiList(u8) appendSlice" {
    const gpa = testing.allocator;

    const Struct = struct { num: u32, char: u8 };
    const StructMultiList = SafeMultiList(Struct);

    var multilist = StructMultiList.initCapacity(gpa, 3);
    defer multilist.deinit(gpa);

    const rangeA = multilist.appendSlice(gpa, &[_]Struct{ .{ .num = 100, .char = 'a' }, .{ .num = 200, .char = 'b' }, .{ .num = 300, .char = 'd' } });
    try testing.expectEqual(0, @intFromEnum(rangeA.start));
    try testing.expectEqual(3, @intFromEnum(rangeA.end));

    const rangeB = multilist.appendSlice(gpa, &[_]Struct{ .{ .num = 400, .char = 'd' }, .{ .num = 500, .char = 'e' }, .{ .num = 600, .char = 'f' } });
    try testing.expectEqual(3, @intFromEnum(rangeB.start));
    try testing.expectEqual(6, @intFromEnum(rangeB.end));
}

test "SafeMultiList(u8) rangeToSlice" {
    const gpa = testing.allocator;

    const Struct = struct { num: u32, char: u8 };
    const StructMultiList = SafeMultiList(Struct);

    var multilist = StructMultiList.initCapacity(gpa, 3);
    defer multilist.deinit(gpa);

    const range_a = multilist.appendSlice(gpa, &[_]Struct{ .{ .num = 100, .char = 'a' }, .{ .num = 200, .char = 'b' }, .{ .num = 300, .char = 'c' } });
    const slice_a = multilist.rangeToSlice(range_a);

    const num_slice_a = slice_a.items(.num);
    try testing.expectEqual(3, num_slice_a.len);
    try testing.expectEqual(100, num_slice_a[0]);
    try testing.expectEqual(200, num_slice_a[1]);
    try testing.expectEqual(300, num_slice_a[2]);

    const char_slice_a = slice_a.items(.char);
    try testing.expectEqual(3, char_slice_a.len);
    try testing.expectEqual('a', char_slice_a[0]);
    try testing.expectEqual('b', char_slice_a[1]);
    try testing.expectEqual('c', char_slice_a[2]);

    const range_b = StructMultiList.Range{ .start = @enumFromInt(1), .end = @enumFromInt(2) };
    const slice_b = multilist.rangeToSlice(range_b);

    const num_slice_b = slice_b.items(.num);
    try testing.expectEqual(1, num_slice_b.len);
    try testing.expectEqual(200, num_slice_b[0]);

    const char_slice_b = slice_b.items(.char);
    try testing.expectEqual(1, char_slice_b.len);
    try testing.expectEqual('b', char_slice_b[0]);
}

test "SafeList(u32) serialization empty list" {
    const gpa = testing.allocator;

    var list = SafeList(u32){};
    defer list.deinit(gpa);

    // Empty list should serialize to just a count of 0
    const expected_size = @sizeOf(u32);
    try testing.expectEqual(expected_size, list.serializedSize());

    var buffer: [@sizeOf(u32)]u8 align(@alignOf(u32)) = undefined;
    const serialized = try list.serializeInto(&buffer);
    try testing.expectEqual(expected_size, serialized.len);

    // Check that count is 0
    const count = @as(*const u32, @ptrCast(@alignCast(buffer[0..@sizeOf(u32)]))).*;
    try testing.expectEqual(@as(u32, 0), count);
}

test "SafeList(u32) serialization with data" {
    const gpa = testing.allocator;

    var list = SafeList(u32){};
    defer list.deinit(gpa);

    _ = list.append(gpa, 42);
    _ = list.append(gpa, 100);
    _ = list.append(gpa, 255);

    const expected_size = @sizeOf(u32) + (3 * @sizeOf(u32));
    try testing.expectEqual(expected_size, list.serializedSize());

    var buffer: [256]u8 align(@alignOf(u32)) = undefined;
    const serialized = try list.serializeInto(&buffer);
    try testing.expectEqual(expected_size, serialized.len);

    // Check that count is 3
    const count = @as(*const u32, @ptrCast(@alignCast(buffer[0..@sizeOf(u32)]))).*;
    try testing.expectEqual(@as(u32, 3), count);

    // Check the data
    const data_start = @sizeOf(u32);
    const data_ptr = @as([*]const u32, @ptrCast(@alignCast(buffer[data_start..])));
    try testing.expectEqual(@as(u32, 42), data_ptr[0]);
    try testing.expectEqual(@as(u32, 100), data_ptr[1]);
    try testing.expectEqual(@as(u32, 255), data_ptr[2]);
}

test "SafeList(u8) serialization with data" {
    const gpa = testing.allocator;

    var list = SafeList(u8){};
    defer list.deinit(gpa);

    _ = list.appendSlice(gpa, "hello");

    const expected_size = @sizeOf(u32) + 5;
    try testing.expectEqual(expected_size, list.serializedSize());

    var buffer: [256]u8 align(@alignOf(u8)) = undefined;
    const serialized = try list.serializeInto(&buffer);
    try testing.expectEqual(expected_size, serialized.len);

    // Check that count is 5
    const count = @as(*const u32, @ptrCast(@alignCast(buffer[0..@sizeOf(u32)]))).*;
    try testing.expectEqual(@as(u32, 5), count);

    // Check the data
    try testing.expectEqualSlices(u8, "hello", buffer[@sizeOf(u32)..expected_size]);
}

test "SafeList(u32) deserialization empty list" {
    const gpa = testing.allocator;

    // Create buffer with count = 0
    var buffer: [@sizeOf(u32)]u8 align(@alignOf(u32)) = undefined;
    @as(*u32, @ptrCast(@alignCast(&buffer))).* = 0;

    var list = try SafeList(u32).deserializeFrom(&buffer, gpa);
    defer list.deinit(gpa);

    try testing.expectEqual(@as(usize, 0), list.len());
}

test "SafeList(u32) deserialization with data" {
    const gpa = testing.allocator;

    // Prepare buffer with count = 3 and data [42, 100, 255]
    const expected_data = [_]u32{ 42, 100, 255 };
    const buffer_size = @sizeOf(u32) + expected_data.len * @sizeOf(u32);
    var buffer: [256]u8 align(@alignOf(u32)) = undefined;

    @as(*u32, @ptrCast(@alignCast(&buffer))).* = expected_data.len;
    const data_ptr = @as([*]u32, @ptrCast(@alignCast(buffer[@sizeOf(u32)..])));
    @memcpy(data_ptr[0..expected_data.len], &expected_data);

    var list = try SafeList(u32).deserializeFrom(buffer[0..buffer_size], gpa);
    defer list.deinit(gpa);

    try testing.expectEqual(expected_data.len, list.len());
    for (expected_data, 0..) |expected, i| {
        const idx: SafeList(u32).Idx = @enumFromInt(i);
        try testing.expectEqual(expected, list.get(idx).*);
    }
}

test "SafeList(u8) deserialization with data" {
    const gpa = testing.allocator;

    // Prepare buffer with "world"
    const expected_data = "world";
    const buffer_size = @sizeOf(u32) + expected_data.len;
    var buffer: [256]u8 align(@alignOf(u8)) = undefined;

    @as(*u32, @ptrCast(@alignCast(&buffer))).* = @intCast(expected_data.len);
    @memcpy(buffer[@sizeOf(u32)..buffer_size], expected_data);

    var list = try SafeList(u8).deserializeFrom(buffer[0..buffer_size], gpa);
    defer list.deinit(gpa);

    try testing.expectEqual(expected_data.len, list.len());
    const slice = list.rangeToSlice(SafeList(u8).Range{ .start = @enumFromInt(0), .end = @enumFromInt(expected_data.len) });
    try testing.expectEqualSlices(u8, expected_data, slice);
}

test "SafeList(u32) round-trip serialization" {
    const gpa = testing.allocator;

    // Create original list
    var original = SafeList(u32){};
    defer original.deinit(gpa);

    const test_data = [_]u32{ 1, 2, 3, 42, 100, 255 };
    _ = original.appendSlice(gpa, &test_data);

    // Serialize
    var buffer: [1024]u8 align(@alignOf(u32)) = undefined;
    const serialized = try original.serializeInto(&buffer);

    // Deserialize
    var deserialized = try SafeList(u32).deserializeFrom(serialized, gpa);
    defer deserialized.deinit(gpa);

    // Compare
    try testing.expectEqual(original.len(), deserialized.len());
    for (test_data, 0..) |expected, i| {
        const idx: SafeList(u32).Idx = @enumFromInt(i);
        try testing.expectEqual(expected, deserialized.get(idx).*);
    }
}

test "SafeList serialization buffer too small error" {
    const gpa = testing.allocator;

    var list = SafeList(u32){};
    defer list.deinit(gpa);

    _ = list.append(gpa, 42);
    _ = list.append(gpa, 100);

    // Buffer too small for the data
    var small_buffer: [4]u8 align(@alignOf(u32)) = undefined; // Only room for count, not data
    try testing.expectError(error.BufferTooSmall, list.serializeInto(&small_buffer));
}

test "SafeList deserialization buffer too small error" {
    const gpa = testing.allocator;

    // Buffer too small to even contain count
    var tiny_buffer: [2]u8 align(@alignOf(u32)) = undefined;
    try testing.expectError(error.BufferTooSmall, SafeList(u32).deserializeFrom(&tiny_buffer, gpa));

    // Buffer with count but insufficient data
    var partial_buffer: [6]u8 align(@alignOf(u32)) = undefined;
    @as(*u32, @ptrCast(@alignCast(&partial_buffer))).* = 2; // Claims 2 items but only has 2 extra bytes
    try testing.expectError(error.BufferTooSmall, SafeList(u32).deserializeFrom(&partial_buffer, gpa));
}

test "SafeList(struct) serialization" {
    const gpa = testing.allocator;

    const Point = struct { x: i32, y: i32 };
    var list = SafeList(Point){};
    defer list.deinit(gpa);

    _ = list.append(gpa, Point{ .x = 10, .y = 20 });
    _ = list.append(gpa, Point{ .x = 30, .y = 40 });

    var buffer: [1024]u8 align(@alignOf(Point)) = undefined;
    const serialized = try list.serializeInto(&buffer);

    var deserialized = try SafeList(Point).deserializeFrom(serialized, gpa);
    defer deserialized.deinit(gpa);

    try testing.expectEqual(@as(usize, 2), deserialized.len());

    const p0 = deserialized.get(@enumFromInt(0));
    try testing.expectEqual(@as(i32, 10), p0.x);
    try testing.expectEqual(@as(i32, 20), p0.y);

    const p1 = deserialized.get(@enumFromInt(1));
    try testing.expectEqual(@as(i32, 30), p1.x);
    try testing.expectEqual(@as(i32, 40), p1.y);
}
