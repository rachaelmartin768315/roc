// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc-bindgen` CLI

#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Error {
    BadBody = 0,
    BadStatus = 1,
    BadUrl = 2,
    NetworkError = 3,
    Timeout = 4,
}

impl core::fmt::Debug for discriminant_Error {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BadBody => f.write_str("discriminant_Error::BadBody"),
            Self::BadStatus => f.write_str("discriminant_Error::BadStatus"),
            Self::BadUrl => f.write_str("discriminant_Error::BadUrl"),
            Self::NetworkError => f.write_str("discriminant_Error::NetworkError"),
            Self::Timeout => f.write_str("discriminant_Error::Timeout"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union Error {
    BadBody: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadStatus: u16,
    BadUrl: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Part {
    Part = 0,
}

impl core::fmt::Debug for discriminant_Part {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Part => f.write_str("discriminant_Part::Part"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Part {
    Part: core::mem::ManuallyDrop<Part_Part>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Header {
    Header = 0,
}

impl core::fmt::Debug for discriminant_Header {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Header => f.write_str("discriminant_Header::Header"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Header {
    Header: core::mem::ManuallyDrop<Header_Header>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U5 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U5 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U5::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U5 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Body {
    Body = 0,
    EmptyBody = 1,
}

impl core::fmt::Debug for discriminant_Body {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Body => f.write_str("discriminant_Body::Body"),
            Self::EmptyBody => f.write_str("discriminant_Body::EmptyBody"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union Body {
    Body: core::mem::ManuallyDrop<Body_Body>,
    _sizer: [u8; 28],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U3 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U3::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U3 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Response {
    BadStatus = 0,
    BadUrl = 1,
    GoodStatus = 2,
    NetworkError = 3,
    Timeout = 4,
}

impl core::fmt::Debug for discriminant_Response {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::BadStatus => f.write_str("discriminant_Response::BadStatus"),
            Self::BadUrl => f.write_str("discriminant_Response::BadUrl"),
            Self::GoodStatus => f.write_str("discriminant_Response::GoodStatus"),
            Self::NetworkError => f.write_str("discriminant_Response::NetworkError"),
            Self::Timeout => f.write_str("discriminant_Response::Timeout"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union Response {
    BadStatus: core::mem::ManuallyDrop<Response_BadStatus>,
    BadUrl: core::mem::ManuallyDrop<roc_std::RocStr>,
    GoodStatus: core::mem::ManuallyDrop<Response_GoodStatus>,
    _sizer: [u8; 56],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Request {
    pub body: Body,
    pub headers: roc_std::RocList<Header>,
    pub progressTracking: ProgressTracking,
    pub timeout: Timeout,
    pub url: roc_std::RocStr,
    pub allowCookiesFromOtherDomains: bool,
    pub method: Method,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U8 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U8 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U8::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U8 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U7 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U7 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U7::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U7 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U6 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U6 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U6::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U6 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U4 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U4::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U4 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U2 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U2::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U2 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Part_Part {
    pub f0: roc_std::RocStr,
    pub f1: roc_std::RocList<u8>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Response_GoodStatus {
    pub f0: Metadata,
    pub f1: roc_std::RocList<u8>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Response_BadStatus {
    pub f0: Metadata,
    pub f1: roc_std::RocList<u8>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Metadata {
    pub headers: roc_std::RocList<Header>,
    pub statusText: roc_std::RocStr,
    pub url: roc_std::RocStr,
    pub statusCode: u16,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum Method {
    Connect = 0,
    Delete = 1,
    Get = 2,
    Head = 3,
    Options = 4,
    Patch = 5,
    Post = 6,
    Put = 7,
    Trace = 8,
}

impl core::fmt::Debug for Method {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Connect => f.write_str("Method::Connect"),
            Self::Delete => f.write_str("Method::Delete"),
            Self::Get => f.write_str("Method::Get"),
            Self::Head => f.write_str("Method::Head"),
            Self::Options => f.write_str("Method::Options"),
            Self::Patch => f.write_str("Method::Patch"),
            Self::Post => f.write_str("Method::Post"),
            Self::Put => f.write_str("Method::Put"),
            Self::Trace => f.write_str("Method::Trace"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_Timeout {
    NoTimeout = 0,
    Timeout = 1,
}

impl core::fmt::Debug for discriminant_Timeout {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::NoTimeout => f.write_str("discriminant_Timeout::NoTimeout"),
            Self::Timeout => f.write_str("discriminant_Timeout::Timeout"),
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "x86"))]
#[repr(C)]
pub union Timeout {
    Timeout: f64,
    _sizer: [u8; 12],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_ProgressTracking {
    NoProgressTracking = 0,
    ProgressTrackingId = 1,
}

impl core::fmt::Debug for discriminant_ProgressTracking {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::NoProgressTracking => {
                f.write_str("discriminant_ProgressTracking::NoProgressTracking")
            }
            Self::ProgressTrackingId => {
                f.write_str("discriminant_ProgressTracking::ProgressTrackingId")
            }
        }
    }
}

#[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
#[repr(C)]
pub union ProgressTracking {
    ProgressTrackingId: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 16],
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Default, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Header_Header {
    pub f0: roc_std::RocStr,
    pub f1: roc_std::RocStr,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Debug, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(C)]
struct Body_Body {
    pub f0: U1,
    pub f1: roc_std::RocList<u8>,
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[derive(Clone, Copy, Eq, Ord, Hash, PartialEq, PartialOrd)]
#[repr(u8)]
pub enum discriminant_U1 {
    MimeType = 0,
}

impl core::fmt::Debug for discriminant_U1 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::MimeType => f.write_str("discriminant_U1::MimeType"),
        }
    }
}

#[cfg(any(
    target_arch = "arm",
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union U1 {
    MimeType: core::mem::ManuallyDrop<roc_std::RocStr>,
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union Error {
    BadBody: core::mem::ManuallyDrop<roc_std::RocStr>,
    BadStatus: u16,
    BadUrl: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 32],
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union Body {
    Body: core::mem::ManuallyDrop<Body_Body>,
    _sizer: [u8; 56],
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union Response {
    BadStatus: core::mem::ManuallyDrop<Response_BadStatus>,
    BadUrl: core::mem::ManuallyDrop<roc_std::RocStr>,
    GoodStatus: core::mem::ManuallyDrop<Response_GoodStatus>,
    _sizer: [u8; 112],
}

#[cfg(any(
    target_arch = "aarch64",
    target_arch = "wasm32",
    target_arch = "x86_64"
))]
#[repr(C)]
pub union Timeout {
    Timeout: f64,
    _sizer: [u8; 16],
}

#[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
#[repr(C)]
pub union ProgressTracking {
    ProgressTrackingId: core::mem::ManuallyDrop<roc_std::RocStr>,
    _sizer: [u8; 32],
}

#[cfg(target_arch = "wasm32")]
#[derive(Clone, Debug, PartialEq, PartialOrd)]
#[repr(C)]
pub struct Request {
    pub timeout: Timeout,
    pub body: Body,
    pub headers: roc_std::RocList<Header>,
    pub progressTracking: ProgressTracking,
    pub url: roc_std::RocStr,
    pub allowCookiesFromOtherDomains: bool,
    pub method: Method,
}

impl Error {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Error {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Error>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Error) {
        let discriminant_ptr: *mut discriminant_Error = (self as *mut Error).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BadBody`, with the appropriate payload
    pub fn BadBody(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            BadBody: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_Error::BadBody);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Error` has a `.discriminant()` of `BadBody` and convert it to `BadBody`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadBody`.
    pub unsafe fn into_BadBody(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Error::BadBody);

        let payload = core::mem::ManuallyDrop::take(&mut self.BadBody);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Error` has a `.discriminant()` of `BadBody` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadBody`.
    pub unsafe fn as_BadBody(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Error::BadBody);

        let payload = &self.BadBody;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BadStatus`, with the appropriate payload
    pub fn BadStatus(arg: u16) -> Self {
        let mut answer = Self { BadStatus: arg };

        answer.set_discriminant(discriminant_Error::BadStatus);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Error` has a `.discriminant()` of `BadStatus` and convert it to `BadStatus`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadStatus`.
    pub unsafe fn into_BadStatus(self) -> u16 {
        debug_assert_eq!(self.discriminant(), discriminant_Error::BadStatus);

        let payload = self.BadStatus;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Error` has a `.discriminant()` of `BadStatus` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadStatus`.
    pub unsafe fn as_BadStatus(&self) -> &u16 {
        debug_assert_eq!(self.discriminant(), discriminant_Error::BadStatus);

        let payload = &self.BadStatus;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BadUrl`, with the appropriate payload
    pub fn BadUrl(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            BadUrl: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_Error::BadUrl);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Error` has a `.discriminant()` of `BadUrl` and convert it to `BadUrl`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadUrl`.
    pub unsafe fn into_BadUrl(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Error::BadUrl);

        let payload = core::mem::ManuallyDrop::take(&mut self.BadUrl);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Error` has a `.discriminant()` of `BadUrl` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadUrl`.
    pub unsafe fn as_BadUrl(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Error::BadUrl);

        let payload = &self.BadUrl;

        &payload
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named NetworkError, which has no payload.
    pub const NetworkError: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Error>()];

        bytes[12] = discriminant_Error::NetworkError as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Error>()], Error>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NetworkError tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NetworkError(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NetworkError tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_NetworkError(&self) {
        ()
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named Timeout, which has no payload.
    pub const Timeout: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Error>()];

        bytes[12] = discriminant_Error::Timeout as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Error>()], Error>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Timeout tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Timeout(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Timeout tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_Timeout(&self) {
        ()
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Error {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Error>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Error) {
        let discriminant_ptr: *mut discriminant_Error = (self as *mut Error).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named NetworkError, which has no payload.
    pub const NetworkError: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Error>()];

        bytes[24] = discriminant_Error::NetworkError as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Error>()], Error>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named Timeout, which has no payload.
    pub const Timeout: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Error>()];

        bytes[24] = discriminant_Error::Timeout as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Error>()], Error>(bytes)
    };
}

impl Drop for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Error::BadBody => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.BadBody)
            },
            discriminant_Error::BadStatus => {}
            discriminant_Error::BadUrl => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.BadUrl)
            },
            discriminant_Error::NetworkError => {}
            discriminant_Error::Timeout => {}
        }
    }
}

impl Eq for Error {}

impl PartialEq for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_Error::BadBody => self.BadBody == other.BadBody,
                discriminant_Error::BadStatus => self.BadStatus == other.BadStatus,
                discriminant_Error::BadUrl => self.BadUrl == other.BadUrl,
                discriminant_Error::NetworkError => true,
                discriminant_Error::Timeout => true,
            }
        }
    }
}

impl PartialOrd for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Error::BadBody => self.BadBody.partial_cmp(&other.BadBody),
                discriminant_Error::BadStatus => self.BadStatus.partial_cmp(&other.BadStatus),
                discriminant_Error::BadUrl => self.BadUrl.partial_cmp(&other.BadUrl),
                discriminant_Error::NetworkError => Some(core::cmp::Ordering::Equal),
                discriminant_Error::Timeout => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Error::BadBody => self.BadBody.cmp(&other.BadBody),
                discriminant_Error::BadStatus => self.BadStatus.cmp(&other.BadStatus),
                discriminant_Error::BadUrl => self.BadUrl.cmp(&other.BadUrl),
                discriminant_Error::NetworkError => core::cmp::Ordering::Equal,
                discriminant_Error::Timeout => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Error::BadBody => Self {
                    BadBody: self.BadBody.clone(),
                },
                discriminant_Error::BadStatus => Self {
                    BadStatus: self.BadStatus.clone(),
                },
                discriminant_Error::BadUrl => Self {
                    BadUrl: self.BadUrl.clone(),
                },
                discriminant_Error::NetworkError => {
                    core::mem::transmute::<core::mem::MaybeUninit<Error>, Error>(
                        core::mem::MaybeUninit::uninit(),
                    )
                }
                discriminant_Error::Timeout => core::mem::transmute::<
                    core::mem::MaybeUninit<Error>,
                    Error,
                >(core::mem::MaybeUninit::uninit()),
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_Error::BadBody => unsafe {
                discriminant_Error::BadBody.hash(state);
                self.BadBody.hash(state);
            },
            discriminant_Error::BadStatus => unsafe {
                discriminant_Error::BadStatus.hash(state);
                self.BadStatus.hash(state);
            },
            discriminant_Error::BadUrl => unsafe {
                discriminant_Error::BadUrl.hash(state);
                self.BadUrl.hash(state);
            },
            discriminant_Error::NetworkError => discriminant_Error::NetworkError.hash(state),
            discriminant_Error::Timeout => discriminant_Error::Timeout.hash(state),
        }
    }
}

impl core::fmt::Debug for Error {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Error::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Error::BadBody => {
                    f.debug_tuple("BadBody").field(&*self.BadBody).finish()
                }
                discriminant_Error::BadStatus => {
                    f.debug_tuple("BadStatus").field(&self.BadStatus).finish()
                }
                discriminant_Error::BadUrl => f.debug_tuple("BadUrl").field(&*self.BadUrl).finish(),
                discriminant_Error::NetworkError => f.write_str("NetworkError"),
                discriminant_Error::Timeout => f.write_str("Timeout"),
            }
        }
    }
}

impl Part {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Part {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Part>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Part) {
        let discriminant_ptr: *mut discriminant_Part = (self as *mut Part).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Part`, with the appropriate payload
    pub fn Part(arg0: roc_std::RocStr, arg1: roc_std::RocList<u8>) -> Self {
        let mut answer = Self {
            Part: core::mem::ManuallyDrop::new(Part_Part { f0: arg0, f1: arg1 }),
        };

        answer.set_discriminant(discriminant_Part::Part);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Part` has a `.discriminant()` of `Part` and convert it to `Part`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Part`.
    pub unsafe fn into_Part(mut self) -> (roc_std::RocStr, roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Part::Part);

        let payload = core::mem::ManuallyDrop::take(&mut self.Part);

        (payload.f0, payload.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Part` has a `.discriminant()` of `Part` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Part`.
    pub unsafe fn as_Part(&self) -> (&roc_std::RocStr, &roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Part::Part);

        let payload = &self.Part;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Part {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Part>(*bytes.as_ptr().add(47))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Part) {
        let discriminant_ptr: *mut discriminant_Part = (self as *mut Part).cast();

        unsafe {
            *(discriminant_ptr.add(47)) = discriminant;
        }
    }
}

impl Drop for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Part::Part => unsafe { core::mem::ManuallyDrop::drop(&mut self.Part) },
        }
    }
}

impl Eq for Part {}

impl PartialEq for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_Part::Part => self.Part == other.Part,
            }
        }
    }
}

impl PartialOrd for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Part::Part => self.Part.partial_cmp(&other.Part),
            }
        }
    }
}

impl Ord for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Part::Part => self.Part.cmp(&other.Part),
            }
        }
    }
}

impl Clone for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Part::Part => Self {
                    Part: self.Part.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_Part::Part => unsafe {
                discriminant_Part::Part.hash(state);
                self.Part.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for Part {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Part::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Part::Part => f
                    .debug_tuple("Part")
                    .field(&(&*self.Part).f0)
                    .field(&(&*self.Part).f1)
                    .finish(),
            }
        }
    }
}

impl Header {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Header {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Header>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Header) {
        let discriminant_ptr: *mut discriminant_Header = (self as *mut Header).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Header`, with the appropriate payload
    pub fn Header(arg0: roc_std::RocStr, arg1: roc_std::RocStr) -> Self {
        let mut answer = Self {
            Header: core::mem::ManuallyDrop::new(Header_Header { f0: arg0, f1: arg1 }),
        };

        answer.set_discriminant(discriminant_Header::Header);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Header` has a `.discriminant()` of `Header` and convert it to `Header`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Header`.
    pub unsafe fn into_Header(mut self) -> (roc_std::RocStr, roc_std::RocStr) {
        debug_assert_eq!(self.discriminant(), discriminant_Header::Header);

        let payload = core::mem::ManuallyDrop::take(&mut self.Header);

        (payload.f0, payload.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Header` has a `.discriminant()` of `Header` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Header`.
    pub unsafe fn as_Header(&self) -> (&roc_std::RocStr, &roc_std::RocStr) {
        debug_assert_eq!(self.discriminant(), discriminant_Header::Header);

        let payload = &self.Header;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Header {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Header>(*bytes.as_ptr().add(47))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Header) {
        let discriminant_ptr: *mut discriminant_Header = (self as *mut Header).cast();

        unsafe {
            *(discriminant_ptr.add(47)) = discriminant;
        }
    }
}

impl Drop for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Header::Header => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.Header)
            },
        }
    }
}

impl Eq for Header {}

impl PartialEq for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_Header::Header => self.Header == other.Header,
            }
        }
    }
}

impl PartialOrd for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Header::Header => self.Header.partial_cmp(&other.Header),
            }
        }
    }
}

impl Ord for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Header::Header => self.Header.cmp(&other.Header),
            }
        }
    }
}

impl Clone for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Header::Header => Self {
                    Header: self.Header.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_Header::Header => unsafe {
                discriminant_Header::Header.hash(state);
                self.Header.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for Header {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Header::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Header::Header => f
                    .debug_tuple("Header")
                    .field(&(&*self.Header).f0)
                    .field(&(&*self.Header).f1)
                    .finish(),
            }
        }
    }
}

impl U5 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U5 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U5>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U5) {
        let discriminant_ptr: *mut discriminant_U5 = (self as *mut U5).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U5::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U5` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U5::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U5` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U5::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U5 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U5>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U5) {
        let discriminant_ptr: *mut discriminant_U5 = (self as *mut U5).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U5::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U5 {}

impl PartialEq for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U5::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U5::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U5::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U5::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U5::MimeType => unsafe {
                discriminant_U5::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U5 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U5::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U5::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl Body {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Body {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Body>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Body) {
        let discriminant_ptr: *mut discriminant_Body = (self as *mut Body).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Body`, with the appropriate payload
    pub fn Body(arg0: U1, arg1: roc_std::RocList<u8>) -> Self {
        let mut answer = Self {
            Body: core::mem::ManuallyDrop::new(Body_Body { f0: arg0, f1: arg1 }),
        };

        answer.set_discriminant(discriminant_Body::Body);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Body` has a `.discriminant()` of `Body` and convert it to `Body`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Body`.
    pub unsafe fn into_Body(mut self) -> (U1, roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Body::Body);

        let payload = core::mem::ManuallyDrop::take(&mut self.Body);

        (payload.f0, payload.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Body` has a `.discriminant()` of `Body` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Body`.
    pub unsafe fn as_Body(&self) -> (&U1, &roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Body::Body);

        let payload = &self.Body;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named EmptyBody, which has no payload.
    pub const EmptyBody: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Body>()];

        bytes[24] = discriminant_Body::EmptyBody as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Body>()], Body>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the EmptyBody tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_EmptyBody(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the EmptyBody tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_EmptyBody(&self) {
        ()
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Body {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Body>(*bytes.as_ptr().add(48))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Body) {
        let discriminant_ptr: *mut discriminant_Body = (self as *mut Body).cast();

        unsafe {
            *(discriminant_ptr.add(48)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named EmptyBody, which has no payload.
    pub const EmptyBody: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Body>()];

        bytes[48] = discriminant_Body::EmptyBody as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Body>()], Body>(bytes)
    };
}

impl Drop for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Body::Body => unsafe { core::mem::ManuallyDrop::drop(&mut self.Body) },
            discriminant_Body::EmptyBody => {}
        }
    }
}

impl Eq for Body {}

impl PartialEq for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_Body::Body => self.Body == other.Body,
                discriminant_Body::EmptyBody => true,
            }
        }
    }
}

impl PartialOrd for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Body::Body => self.Body.partial_cmp(&other.Body),
                discriminant_Body::EmptyBody => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Body::Body => self.Body.cmp(&other.Body),
                discriminant_Body::EmptyBody => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Body::Body => Self {
                    Body: self.Body.clone(),
                },
                discriminant_Body::EmptyBody => core::mem::transmute::<
                    core::mem::MaybeUninit<Body>,
                    Body,
                >(core::mem::MaybeUninit::uninit()),
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_Body::Body => unsafe {
                discriminant_Body::Body.hash(state);
                self.Body.hash(state);
            },
            discriminant_Body::EmptyBody => discriminant_Body::EmptyBody.hash(state),
        }
    }
}

impl core::fmt::Debug for Body {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Body::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Body::Body => f
                    .debug_tuple("Body")
                    .field(&(&*self.Body).f0)
                    .field(&(&*self.Body).f1)
                    .finish(),
                discriminant_Body::EmptyBody => f.write_str("EmptyBody"),
            }
        }
    }
}

impl U3 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U3 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U3>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U3) {
        let discriminant_ptr: *mut discriminant_U3 = (self as *mut U3).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U3::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U3` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U3::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U3` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U3::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U3 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U3>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U3) {
        let discriminant_ptr: *mut discriminant_U3 = (self as *mut U3).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U3::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U3 {}

impl PartialEq for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U3::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U3::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U3::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U3::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U3::MimeType => unsafe {
                discriminant_U3::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U3 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U3::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U3::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl Response {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Response {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Response>(*bytes.as_ptr().add(52))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Response) {
        let discriminant_ptr: *mut discriminant_Response = (self as *mut Response).cast();

        unsafe {
            *(discriminant_ptr.add(52)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BadStatus`, with the appropriate payload
    pub fn BadStatus(arg0: Metadata, arg1: roc_std::RocList<u8>) -> Self {
        let mut answer = Self {
            BadStatus: core::mem::ManuallyDrop::new(Response_BadStatus { f0: arg0, f1: arg1 }),
        };

        answer.set_discriminant(discriminant_Response::BadStatus);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Response` has a `.discriminant()` of `BadStatus` and convert it to `BadStatus`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadStatus`.
    pub unsafe fn into_BadStatus(mut self) -> (Metadata, roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Response::BadStatus);

        let payload = core::mem::ManuallyDrop::take(&mut self.BadStatus);

        (payload.f0, payload.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Response` has a `.discriminant()` of `BadStatus` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadStatus`.
    pub unsafe fn as_BadStatus(&self) -> (&Metadata, &roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Response::BadStatus);

        let payload = &self.BadStatus;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `BadUrl`, with the appropriate payload
    pub fn BadUrl(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            BadUrl: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_Response::BadUrl);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Response` has a `.discriminant()` of `BadUrl` and convert it to `BadUrl`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadUrl`.
    pub unsafe fn into_BadUrl(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Response::BadUrl);

        let payload = core::mem::ManuallyDrop::take(&mut self.BadUrl);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Response` has a `.discriminant()` of `BadUrl` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `BadUrl`.
    pub unsafe fn as_BadUrl(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_Response::BadUrl);

        let payload = &self.BadUrl;

        &payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `GoodStatus`, with the appropriate payload
    pub fn GoodStatus(arg0: Metadata, arg1: roc_std::RocList<u8>) -> Self {
        let mut answer = Self {
            GoodStatus: core::mem::ManuallyDrop::new(Response_GoodStatus { f0: arg0, f1: arg1 }),
        };

        answer.set_discriminant(discriminant_Response::GoodStatus);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Response` has a `.discriminant()` of `GoodStatus` and convert it to `GoodStatus`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `GoodStatus`.
    pub unsafe fn into_GoodStatus(mut self) -> (Metadata, roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Response::GoodStatus);

        let payload = core::mem::ManuallyDrop::take(&mut self.GoodStatus);

        (payload.f0, payload.f1)
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Response` has a `.discriminant()` of `GoodStatus` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `GoodStatus`.
    pub unsafe fn as_GoodStatus(&self) -> (&Metadata, &roc_std::RocList<u8>) {
        debug_assert_eq!(self.discriminant(), discriminant_Response::GoodStatus);

        let payload = &self.GoodStatus;

        (&payload.f0, &payload.f1)
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named NetworkError, which has no payload.
    pub const NetworkError: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Response>()];

        bytes[52] = discriminant_Response::NetworkError as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Response>()], Response>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NetworkError tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NetworkError(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NetworkError tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_NetworkError(&self) {
        ()
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named Timeout, which has no payload.
    pub const Timeout: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Response>()];

        bytes[52] = discriminant_Response::Timeout as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Response>()], Response>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the Timeout tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_Timeout(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the Timeout tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_Timeout(&self) {
        ()
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Response {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Response>(*bytes.as_ptr().add(104))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Response) {
        let discriminant_ptr: *mut discriminant_Response = (self as *mut Response).cast();

        unsafe {
            *(discriminant_ptr.add(104)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named NetworkError, which has no payload.
    pub const NetworkError: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Response>()];

        bytes[104] = discriminant_Response::NetworkError as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Response>()], Response>(bytes)
    };

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named Timeout, which has no payload.
    pub const Timeout: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Response>()];

        bytes[104] = discriminant_Response::Timeout as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Response>()], Response>(bytes)
    };
}

impl Drop for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Response::BadStatus => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.BadStatus)
            },
            discriminant_Response::BadUrl => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.BadUrl)
            },
            discriminant_Response::GoodStatus => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.GoodStatus)
            },
            discriminant_Response::NetworkError => {}
            discriminant_Response::Timeout => {}
        }
    }
}

impl Eq for Response {}

impl PartialEq for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_Response::BadStatus => self.BadStatus == other.BadStatus,
                discriminant_Response::BadUrl => self.BadUrl == other.BadUrl,
                discriminant_Response::GoodStatus => self.GoodStatus == other.GoodStatus,
                discriminant_Response::NetworkError => true,
                discriminant_Response::Timeout => true,
            }
        }
    }
}

impl PartialOrd for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Response::BadStatus => self.BadStatus.partial_cmp(&other.BadStatus),
                discriminant_Response::BadUrl => self.BadUrl.partial_cmp(&other.BadUrl),
                discriminant_Response::GoodStatus => self.GoodStatus.partial_cmp(&other.GoodStatus),
                discriminant_Response::NetworkError => Some(core::cmp::Ordering::Equal),
                discriminant_Response::Timeout => Some(core::cmp::Ordering::Equal),
            }
        }
    }
}

impl Ord for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Response::BadStatus => self.BadStatus.cmp(&other.BadStatus),
                discriminant_Response::BadUrl => self.BadUrl.cmp(&other.BadUrl),
                discriminant_Response::GoodStatus => self.GoodStatus.cmp(&other.GoodStatus),
                discriminant_Response::NetworkError => core::cmp::Ordering::Equal,
                discriminant_Response::Timeout => core::cmp::Ordering::Equal,
            }
        }
    }
}

impl Clone for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Response::BadStatus => Self {
                    BadStatus: self.BadStatus.clone(),
                },
                discriminant_Response::BadUrl => Self {
                    BadUrl: self.BadUrl.clone(),
                },
                discriminant_Response::GoodStatus => Self {
                    GoodStatus: self.GoodStatus.clone(),
                },
                discriminant_Response::NetworkError => {
                    core::mem::transmute::<core::mem::MaybeUninit<Response>, Response>(
                        core::mem::MaybeUninit::uninit(),
                    )
                }
                discriminant_Response::Timeout => {
                    core::mem::transmute::<core::mem::MaybeUninit<Response>, Response>(
                        core::mem::MaybeUninit::uninit(),
                    )
                }
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_Response::BadStatus => unsafe {
                discriminant_Response::BadStatus.hash(state);
                self.BadStatus.hash(state);
            },
            discriminant_Response::BadUrl => unsafe {
                discriminant_Response::BadUrl.hash(state);
                self.BadUrl.hash(state);
            },
            discriminant_Response::GoodStatus => unsafe {
                discriminant_Response::GoodStatus.hash(state);
                self.GoodStatus.hash(state);
            },
            discriminant_Response::NetworkError => discriminant_Response::NetworkError.hash(state),
            discriminant_Response::Timeout => discriminant_Response::Timeout.hash(state),
        }
    }
}

impl core::fmt::Debug for Response {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Response::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Response::BadStatus => f
                    .debug_tuple("BadStatus")
                    .field(&(&*self.BadStatus).f0)
                    .field(&(&*self.BadStatus).f1)
                    .finish(),
                discriminant_Response::BadUrl => {
                    f.debug_tuple("BadUrl").field(&*self.BadUrl).finish()
                }
                discriminant_Response::GoodStatus => f
                    .debug_tuple("GoodStatus")
                    .field(&(&*self.GoodStatus).f0)
                    .field(&(&*self.GoodStatus).f1)
                    .finish(),
                discriminant_Response::NetworkError => f.write_str("NetworkError"),
                discriminant_Response::Timeout => f.write_str("Timeout"),
            }
        }
    }
}

impl U8 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U8 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U8>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U8) {
        let discriminant_ptr: *mut discriminant_U8 = (self as *mut U8).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U8::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U8` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U8::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U8` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U8::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U8 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U8>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U8) {
        let discriminant_ptr: *mut discriminant_U8 = (self as *mut U8).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U8::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U8 {}

impl PartialEq for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U8::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U8::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U8::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U8::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U8::MimeType => unsafe {
                discriminant_U8::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U8 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U8::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U8::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl U7 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U7 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U7>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U7) {
        let discriminant_ptr: *mut discriminant_U7 = (self as *mut U7).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U7::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U7` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U7::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U7` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U7::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U7 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U7>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U7) {
        let discriminant_ptr: *mut discriminant_U7 = (self as *mut U7).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U7::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U7 {}

impl PartialEq for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U7::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U7::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U7::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U7::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U7::MimeType => unsafe {
                discriminant_U7::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U7 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U7::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U7::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl U6 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U6 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U6>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U6) {
        let discriminant_ptr: *mut discriminant_U6 = (self as *mut U6).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U6::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U6` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U6::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U6` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U6::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U6 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U6>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U6) {
        let discriminant_ptr: *mut discriminant_U6 = (self as *mut U6).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U6::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U6 {}

impl PartialEq for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U6::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U6::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U6::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U6::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U6::MimeType => unsafe {
                discriminant_U6::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U6 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U6::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U6::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl U4 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U4 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U4>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U4) {
        let discriminant_ptr: *mut discriminant_U4 = (self as *mut U4).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U4::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U4` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U4::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U4` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U4::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U4 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U4>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U4) {
        let discriminant_ptr: *mut discriminant_U4 = (self as *mut U4).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U4::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U4 {}

impl PartialEq for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U4::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U4::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U4::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U4::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U4::MimeType => unsafe {
                discriminant_U4::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U4 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U4::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U4::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl U2 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U2 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U2>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U2) {
        let discriminant_ptr: *mut discriminant_U2 = (self as *mut U2).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U2::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U2` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U2::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U2` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U2::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U2 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U2>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U2) {
        let discriminant_ptr: *mut discriminant_U2 = (self as *mut U2).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U2::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U2 {}

impl PartialEq for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U2::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U2::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U2::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U2::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U2::MimeType => unsafe {
                discriminant_U2::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U2 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U2::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U2::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}

impl Timeout {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_Timeout {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_Timeout>(*bytes.as_ptr().add(8))
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_Timeout) {
        let discriminant_ptr: *mut discriminant_Timeout = (self as *mut Timeout).cast();

        unsafe {
            *(discriminant_ptr.add(8)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// A tag named NoTimeout, which has no payload.
    pub const NoTimeout: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<Timeout>()];

        bytes[8] = discriminant_Timeout::NoTimeout as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<Timeout>()], Timeout>(bytes)
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NoTimeout tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NoTimeout(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NoTimeout tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_NoTimeout(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `Timeout`, with the appropriate payload
    pub fn Timeout(arg: f64) -> Self {
        let mut answer = Self { Timeout: arg };

        answer.set_discriminant(discriminant_Timeout::Timeout);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Timeout` has a `.discriminant()` of `Timeout` and convert it to `Timeout`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Timeout`.
    pub unsafe fn into_Timeout(self) -> f64 {
        debug_assert_eq!(self.discriminant(), discriminant_Timeout::Timeout);

        let payload = self.Timeout;

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `Timeout` has a `.discriminant()` of `Timeout` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `Timeout`.
    pub unsafe fn as_Timeout(&self) -> &f64 {
        debug_assert_eq!(self.discriminant(), discriminant_Timeout::Timeout);

        let payload = &self.Timeout;

        &payload
    }
}

impl Drop for Timeout {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_Timeout::NoTimeout => {}
            discriminant_Timeout::Timeout => {}
        }
    }
}

impl PartialEq for Timeout {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_Timeout::NoTimeout => true,
                discriminant_Timeout::Timeout => self.Timeout == other.Timeout,
            }
        }
    }
}

impl PartialOrd for Timeout {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_Timeout::NoTimeout => Some(core::cmp::Ordering::Equal),
                discriminant_Timeout::Timeout => self.Timeout.partial_cmp(&other.Timeout),
            }
        }
    }
}

// error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor
//     --> src/glue.rs:4399:1
//      |
// 4399 | impl Copy for Timeout {}
//      | ^^^^^^^^^^^^^^^^^^^^^^^^ Copy not allowed on types with destructors
//
// For more information about this error, try `rustc --explain E0184`.
//
// impl Ord for Timeout {
//     #[cfg(any(
//         target_arch = "arm",
//         target_arch = "aarch64",
//         target_arch = "wasm32",
//         target_arch = "x86",
//         target_arch = "x86_64"
//     ))]
//     fn cmp(&self, other: &Self) -> core::cmp::Ordering {
//         match self.discriminant().cmp(&other.discriminant()) {
//             core::cmp::Ordering::Equal => {}
//             not_eq => return not_eq,
//         }

//         unsafe {
//             match self.discriminant() {
//                 discriminant_Timeout::NoTimeout => core::cmp::Ordering::Equal,
//                 discriminant_Timeout::Timeout => self.Timeout.cmp(&other.Timeout),
//             }
//         }
//     }
// }

// impl Copy for Timeout {}

impl Clone for Timeout {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_Timeout::NoTimeout => {
                    core::mem::transmute::<core::mem::MaybeUninit<Timeout>, Timeout>(
                        core::mem::MaybeUninit::uninit(),
                    )
                }
                discriminant_Timeout::Timeout => Self {
                    Timeout: self.Timeout.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

// error[E0599]: no method named `hash` found for type `f64` in the current scope
//     --> src/glue.rs:4450:30
//      |
// 4450 |                 self.Timeout.hash(state);
//      |                              ^^^^ method not found in `f64`
//
// For more information about this error, try `rustc --explain E0599`.
//
// impl core::hash::Hash for Timeout {
//     #[cfg(any(
//         target_arch = "arm",
//         target_arch = "aarch64",
//         target_arch = "wasm32",
//         target_arch = "x86",
//         target_arch = "x86_64"
//     ))]
//     fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
//         match self.discriminant() {
//             discriminant_Timeout::NoTimeout => discriminant_Timeout::NoTimeout.hash(state),
//             discriminant_Timeout::Timeout => unsafe {
//                 discriminant_Timeout::Timeout.hash(state);
//                 self.Timeout.hash(state);
//             },
//         }
//     }
// }

impl core::fmt::Debug for Timeout {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("Timeout::")?;

        unsafe {
            match self.discriminant() {
                discriminant_Timeout::NoTimeout => f.write_str("NoTimeout"),
                discriminant_Timeout::Timeout => {
                    f.debug_tuple("Timeout").field(&self.Timeout).finish()
                }
            }
        }
    }
}

impl ProgressTracking {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ProgressTracking {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ProgressTracking>(*bytes.as_ptr().add(12))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ProgressTracking) {
        let discriminant_ptr: *mut discriminant_ProgressTracking =
            (self as *mut ProgressTracking).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// A tag named NoProgressTracking, which has no payload.
    pub const NoProgressTracking: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ProgressTracking>()];

        bytes[12] = discriminant_ProgressTracking::NoProgressTracking as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ProgressTracking>()], ProgressTracking>(
            bytes,
        )
    };

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `into_` methods return a payload, but since the NoProgressTracking tag
    /// has no payload, this does nothing and is only here for completeness.
    pub fn into_NoProgressTracking(self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Other `as` methods return a payload, but since the NoProgressTracking tag
    /// has no payload, this does nothing and is only here for completeness.
    pub unsafe fn as_NoProgressTracking(&self) {
        ()
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `ProgressTrackingId`, with the appropriate payload
    pub fn ProgressTrackingId(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            ProgressTrackingId: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_ProgressTracking::ProgressTrackingId);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `ProgressTracking` has a `.discriminant()` of `ProgressTrackingId` and convert it to `ProgressTrackingId`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `ProgressTrackingId`.
    pub unsafe fn into_ProgressTrackingId(mut self) -> roc_std::RocStr {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_ProgressTracking::ProgressTrackingId
        );

        let payload = core::mem::ManuallyDrop::take(&mut self.ProgressTrackingId);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `ProgressTracking` has a `.discriminant()` of `ProgressTrackingId` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `ProgressTrackingId`.
    pub unsafe fn as_ProgressTrackingId(&self) -> &roc_std::RocStr {
        debug_assert_eq!(
            self.discriminant(),
            discriminant_ProgressTracking::ProgressTrackingId
        );

        let payload = &self.ProgressTrackingId;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_ProgressTracking {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_ProgressTracking>(*bytes.as_ptr().add(24))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_ProgressTracking) {
        let discriminant_ptr: *mut discriminant_ProgressTracking =
            (self as *mut ProgressTracking).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// A tag named NoProgressTracking, which has no payload.
    pub const NoProgressTracking: Self = unsafe {
        let mut bytes = [0; core::mem::size_of::<ProgressTracking>()];

        bytes[24] = discriminant_ProgressTracking::NoProgressTracking as u8;

        core::mem::transmute::<[u8; core::mem::size_of::<ProgressTracking>()], ProgressTracking>(
            bytes,
        )
    };
}

impl Drop for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_ProgressTracking::NoProgressTracking => {}
            discriminant_ProgressTracking::ProgressTrackingId => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.ProgressTrackingId)
            },
        }
    }
}

impl Eq for ProgressTracking {}

impl PartialEq for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_ProgressTracking::NoProgressTracking => true,
                discriminant_ProgressTracking::ProgressTrackingId => {
                    self.ProgressTrackingId == other.ProgressTrackingId
                }
            }
        }
    }
}

impl PartialOrd for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_ProgressTracking::NoProgressTracking => {
                    Some(core::cmp::Ordering::Equal)
                }
                discriminant_ProgressTracking::ProgressTrackingId => self
                    .ProgressTrackingId
                    .partial_cmp(&other.ProgressTrackingId),
            }
        }
    }
}

impl Ord for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_ProgressTracking::NoProgressTracking => core::cmp::Ordering::Equal,
                discriminant_ProgressTracking::ProgressTrackingId => {
                    self.ProgressTrackingId.cmp(&other.ProgressTrackingId)
                }
            }
        }
    }
}

impl Clone for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_ProgressTracking::NoProgressTracking => {
                    core::mem::transmute::<core::mem::MaybeUninit<ProgressTracking>, ProgressTracking>(
                        core::mem::MaybeUninit::uninit(),
                    )
                }
                discriminant_ProgressTracking::ProgressTrackingId => Self {
                    ProgressTrackingId: self.ProgressTrackingId.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_ProgressTracking::NoProgressTracking => {
                discriminant_ProgressTracking::NoProgressTracking.hash(state)
            }
            discriminant_ProgressTracking::ProgressTrackingId => unsafe {
                discriminant_ProgressTracking::ProgressTrackingId.hash(state);
                self.ProgressTrackingId.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for ProgressTracking {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("ProgressTracking::")?;

        unsafe {
            match self.discriminant() {
                discriminant_ProgressTracking::NoProgressTracking => {
                    f.write_str("NoProgressTracking")
                }
                discriminant_ProgressTracking::ProgressTrackingId => f
                    .debug_tuple("ProgressTrackingId")
                    .field(&*self.ProgressTrackingId)
                    .finish(),
            }
        }
    }
}

impl U1 {
    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(11))
        }
    }

    #[cfg(any(target_arch = "arm", target_arch = "wasm32", target_arch = "x86"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(11)) = discriminant;
        }
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Construct a tag named `MimeType`, with the appropriate payload
    pub fn MimeType(arg: roc_std::RocStr) -> Self {
        let mut answer = Self {
            MimeType: core::mem::ManuallyDrop::new(arg),
        };

        answer.set_discriminant(discriminant_U1::MimeType);

        answer
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `MimeType` and convert it to `MimeType`'s payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn into_MimeType(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U1::MimeType);

        let payload = core::mem::ManuallyDrop::take(&mut self.MimeType);

        payload
    }

    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    /// Unsafely assume the given `U1` has a `.discriminant()` of `MimeType` and return its payload.
    /// (Always examine `.discriminant()` first to make sure this is the correct variant!)
    /// Panics in debug builds if the `.discriminant()` doesn't return `MimeType`.
    pub unsafe fn as_MimeType(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant(), discriminant_U1::MimeType);

        let payload = &self.MimeType;

        &payload
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_U1 {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_U1>(*bytes.as_ptr().add(23))
        }
    }

    #[cfg(any(target_arch = "aarch64", target_arch = "x86_64"))]
    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_U1) {
        let discriminant_ptr: *mut discriminant_U1 = (self as *mut U1).cast();

        unsafe {
            *(discriminant_ptr.add(23)) = discriminant;
        }
    }
}

impl Drop for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_U1::MimeType => unsafe {
                core::mem::ManuallyDrop::drop(&mut self.MimeType)
            },
        }
    }
}

impl Eq for U1 {}

impl PartialEq for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn eq(&self, other: &Self) -> bool {
        if self.discriminant() != other.discriminant() {
            return false;
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::MimeType => self.MimeType == other.MimeType,
            }
        }
    }
}

impl PartialOrd for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
        match self.discriminant().partial_cmp(&other.discriminant()) {
            Some(core::cmp::Ordering::Equal) => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::MimeType => self.MimeType.partial_cmp(&other.MimeType),
            }
        }
    }
}

impl Ord for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
        match self.discriminant().cmp(&other.discriminant()) {
            core::cmp::Ordering::Equal => {}
            not_eq => return not_eq,
        }

        unsafe {
            match self.discriminant() {
                discriminant_U1::MimeType => self.MimeType.cmp(&other.MimeType),
            }
        }
    }
}

impl Clone for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn clone(&self) -> Self {
        let mut answer = unsafe {
            match self.discriminant() {
                discriminant_U1::MimeType => Self {
                    MimeType: self.MimeType.clone(),
                },
            }
        };

        answer.set_discriminant(self.discriminant());

        answer
    }
}

impl core::hash::Hash for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        match self.discriminant() {
            discriminant_U1::MimeType => unsafe {
                discriminant_U1::MimeType.hash(state);
                self.MimeType.hash(state);
            },
        }
    }
}

impl core::fmt::Debug for U1 {
    #[cfg(any(
        target_arch = "arm",
        target_arch = "aarch64",
        target_arch = "wasm32",
        target_arch = "x86",
        target_arch = "x86_64"
    ))]
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("U1::")?;

        unsafe {
            match self.discriminant() {
                discriminant_U1::MimeType => {
                    f.debug_tuple("MimeType").field(&*self.MimeType).finish()
                }
            }
        }
    }
}
